var testing = false
var allowtesting = true
const Discord = require('discord.js')
const disbut = require('discord-buttons')
const request = require('request')
const cheerio = require('cheerio')
const { Builder, By, until } = require('selenium-webdriver')
const chrome = require('selenium-webdriver/chrome')
const Tesseract = require('tesseract.js')
const fs = require('fs');
const archiver = require('archiver')
const Jimp = require('jimp');
const fileType = require('file-type')
const fetch = require('node-fetch').default
const { exec } = require('child_process')
const util = require('util')
const deepai = require('deepai')
const noblox = require('noblox.js')
const gis = require('g-i-s')
const catbox = require('catbox.moe')
const os = require('os')
const Catbox = new catbox.Catbox()
deepai.setApiKey(process.env.DEEPAIKEY)
const imageToBraille = require('./other_modules/imgtobraille')
const { getAllData, updateAllData } = require('./other_modules/dataGathering')
const brainfuck = require('./other_modules/brainfuck')
const tobrainfuck = require('./other_modules/tobrainfuck')
const gibberish = require('./other_modules/gibberish')
const randomip = require('./other_modules/randomip')
var data = JSON.parse(fs.readFileSync('data.json', 'utf8'))
var data2 = {};
const bot = new Discord.Client()
disbut(bot)
var ownerids = ['464438783866175489', '454732245425455105', '613501149282172970'];
var illKillYouIfYouUseEval = ['535467581881188354'] // this will never happen
var sizelimit = 20
var exceptionsizelimit = 100
const validUrl = /^(http|https):\/\/[^ "]+$/
const emojiRegex = require('emoji-regex/RGI_Emoji')()
const gifFormats = ['gif', 'apng']
const symbolreplacements = [
    {
        target: ['â€˜', 'â€™', 'â€›', 'â›', 'âœ'],
        replacement: '\''
    },
    {
        target: ['â€œ', 'â€', 'â€Ÿ'],
        replacement: '"'
    },
]

var arabDictionary = ['punapea6', 'dream', 'soup land', 'phexonia studios', 'idfsgs', 'penis', 'sex', 'hentai', 'area', 'World', 'throat', 'Mongolian', 'finnish', 'Malagasy', 'Iraqi', 'polish', 'ethiopian', 'canadian', 'ukrainian', 'iranian', 'irish', 'swedish', 'danish', 'french', 'chips', 'spanish', 'racist', 'superbrohouse', 'deinx', 'bubbley', 'deinbag', 'another', 'crypyth', 'tordenask', 'lead', 'lumin', 'wovxzers', 'dootings', 'bartekoklol', 'tuca', 'ballfish', 'whisky', 'kleio', 'crazy', 'cinna', 'btn', 'tree', 'gritzy', 'ruki', 'henry', 'empsy', 'maks', 'henhen', 'phex', 'icre8', 'bilon', 'fnepp', 'zekkriel', 'tranzst', 'mance', 'luigistar', 'makos', 'spellbunny', 'scriptedsand', 'puppet', 'josh', 'spooky', 'catfishhotdog', 'robuk', 'pl0x7', 'lemoardo', 'dundeed', 'notsam', 'luigiluis', 'trongal', 'mysterymeatwad', 'carlito', 'azureblob', 'simpremove', 'gobby', 'sayori', 'concern', 'euth', 'dullminecraftsteve', 'gunk', 'betteruser', 'tix', 'charleh', 'jlol', 'Featured', 'Vesteria', 'Rogue Lineage', 'madness', 'tricky', 'zardy', 'madness combat', 'splatoon', 'babis', 'wiki', 'fandom', 'milk', 'carrot', 'vinegar', 'mushroom', 'stew', 'shroom', 'peashooter', 'eyed', 'pea', 'frank', 'carl', 'oil', 'sunflower', 'chomper', 'piranha', 'fishes', 'fishe', 'fish', 'salami', 'lid', 'â‰¥wâ‰¤', 'furry', 'nya', 'uwu', 'owo', '^w^', 'freedom', 'dick', 'flip', 'bottle', 'pork', 'demotion', 'promotion', 'Error', 'Scream', 'spoon', 'knife', 'all over', 'african', 'land', 'ðŸ˜‚', 'yup', 'pee', 'piss', 'stranger language', 'edition', 'version', 'turtle', 'language', 'stranger', 'persian', 'people', 'Freddy', 'FNAF', 'giraffe', 'hippopotamus', 'program', 'coding', 'ocean', 'treasure', 'egg', 'tool', 'lad', 'lad village', 'GPU', 'CPU', 'lag', 'imposter', 'Among Us', 'sus', 'homework', 'markov', 'moment', 'nervous', 'shy', 'CHICKEN', 'sosig', 'brogle', 'Dad', 'Grand', 'Windows 95', 'Windows XP', 'big fat', 'blender', 'group', 'Phexonia', 'venezuelan', 'tf2', 'Bastard', 'obby', 'david', 'WARIO', 'sandals', 'livestream', 'youtube', 'minimum', 'pickle', 'NSFW', 'hot', 'RALEIGH', 'PEED FAMILY', 'gif', 'nostalgia critic', 'Britain', 'America', 'United Kingdom', 'soup', 'United States of America', 'WOMEN', 'wife', 'cat', 'marselo', 'tech support', 'indian', 'australian', 'japanese', 'Plants vs Zombies', 'Joe Biden', 'chinese', 'Chinese Republic', 'french fries', 'german', 'SWITZERLAND', 'denmark', 'Donald Trump', 'portuguese', 'nigerian', 'russian', 'beach', 'alpha', 'beta', 'theaters', 'Movie', 'Trailer', 'Lego', 'chalk', 'Documentation', 'mcdrive', 'Boner', 'Big', 'Giant', 'Small', 'Awesome', 'STOLEN', 'no', 'yes', 'car', 'Rigby', 'Mordecai', 'BENSON', 'park', 'blaster', 'gaster', 'Undertale', 'phil', 'Anvil', 'halloween', 'pumpkin', 'shut up', 'platinum', 'cheats', 'farms', 'GOLD', 'cake day', 'pizza slice', 'lasagna', 'quesadilla', 'enchilada', 'Miner\'s Haven', 'berezaa', 'LEGENDARY', 'Bee Swarm Simulator', 'beta tester', 'member', 'creator', 'family', 'Empire', 'Warfare', 'upvotes', 'downvotes', 'redditor', 'reddit', 'reddit arguments', 'twitter', 'twitter arguments', 'amongla', 'virus', 'viruses', 'INSTALL NOW', 'FL Studio VST', 'Torrent', 'Github', 'the ESSENCE', 'soup satan', 'soup god', 'quesley', 'empsy', 'illegal', 'legal', 'regal', 'deflorestation', 'DONKEY KONG', 'piss shit come', 'gay chains', 'Tss crazed', 'ralsei', 'ðŸ‘¶', 'âœ…', 'PIG', 'cucumber', 'mark\'s pizzeria', 'dominus pizza', 'pizza hut', 'wendy\'s', 'hat', 'tool', 'burger king', 'mcdonalds', 'nugget', 'fat', 'WTF', 'ROFL', 'XD', 'LMAO', 'LOL', 'Lad', 'Piid', 'LOUD', 'griefed', 'Fitmc', '2b2t', 'POPBOB', 'mommy', 'Survival', 'Jeff', 'Slender', 'Piggy', 'ðŸ–', 'artistic', 'Burrito', 'fart channel', 'ðŸ’“', 'Banjo', 'guitarist', 'guitar', 'chords', 'instruments', 'bingus', 'sussy', 'Big ass', 'crewmate', 'Imposter', 'choccy milk', 'thwomp', 'ðŸ¡', 'brain rot', 'your mom', 'baby', 'baby farting', 'Admin', 'EMOTE GAME', 'Sega', 'Sega Genesis', 'Newgrounds', 'Gamejolt', 'Steam', 'Epic Games', 'basket', 'update released', 'Soup Land', 'ROCKET', 'clash of clans', 'clothes', 'lore', 'fart machine', 'mech', 'Angry Birds', 'Bad Piggies', 'vlog', 'Poopy', 'machine', 'Thanos', 'porn', 'New emote', 'bought', 'Sun', 'Moon', 'Friday Night Funkin', 'Mod', 'Minecraft', 'Terraria', 'Roblox', 'Shaders', '2012', '2016', 'peter', 'GTA 6', 'GTA', 'bananas', 'shanky', 'PEED', 'Hollow Knight', 'Burrito Bison', 'Taco', 'taxes', 'budget', 'dollars', 'british', 'fluffy', 'brocolli', 'brain', 'SHIT', 'HELL', 'naked', 'babis', 'kingdom', 'HAHAHA', 'arabic', 'Rocket League', 'Fortnite', 'mrflimflam', 'Flamingo', 'rap', 'bitch', 'Poop', 'MARIO', 'crAck', 'Harambe', 'hellish', 'crimes', 'cordy', 'Halal', 'HARAM', 'Chungus', 'president', 'santa', 'idiot', 'WOW', 'SANS', 'FART', 'Garfield', 'POG', 'DEINX', 'discord', 'Super', 'Market', 'Mark', 'EXPLOSIVE', 'combat', 'oyster', 'Epico', 'Grammar', 'SUS', 'fresh', 'matilda', 'sonic', 'corpses', 'Egyptian', 'White', 'BLACK', 'wacky', 'card', 'credit', 'Tycoon', 'tunas', 'Israelite', 'Saudi', 'brazilian', 'Luigi', 'shawty']
var tenorDictionary = ['punapea6', 'dream', 'soup land', 'phexonia studios', 'idfsgs', 'chips', 'racist', 'superbrohouse', 'deinx', 'bubbley', 'deinbag', 'another', 'crypyth', 'tordenask', 'lead', 'lumin', 'wovxzers', 'dootings', 'bartekoklol', 'tuca', 'ballfish', 'whisky', 'kleio', 'crazy', 'cinna', 'btn', 'tree', 'gritzy', 'ruki', 'henry', 'empsy', 'maks', 'henhen', 'phex', 'icre8', 'bilon', 'fnepp', 'zekkriel', 'tranzst', 'mance', 'luigistar', 'makos', 'spellbunny', 'scriptedsand', 'puppet', 'josh', 'spooky', 'catfishhotdog', 'robuk', 'pl0x7', 'lemoardo', 'dundeed', 'notsam', 'luigiluis', 'trongal', 'mysterymeatwad', 'carlito', 'azureblob', 'simpremove', 'gobby', 'sayori', 'concern', 'euth', 'dullminecraftsteve', 'gunk', 'betteruser', 'tix', 'charleh', 'jlol', 'Vesteria', 'Rogue Lineage', 'tricky', 'zardy', 'madness combat', 'splatoon', 'babis', 'carrot', 'vinegar', 'mushroom', 'stew', 'shroom', 'peashooter', 'frank', 'carl', 'oil', 'sunflower', 'chomper', 'piranha', 'fishes', 'fishe', 'fish', 'salami', 'furry', 'uwu', 'owo', 'flip', 'bottle', 'pork', 'demotion', 'promotion', 'Error', 'spoon', 'knife', 'african', 'ðŸ˜‚', 'yup', 'turtle', 'persian', 'Freddy', 'FNAF', 'giraffe', 'hippopotamus', 'coding', 'ocean', 'egg', 'tool', 'lad', 'lad village', 'GPU', 'CPU', 'lag', 'imposter', 'Among Us', 'sus', 'homework', 'CHICKEN', 'sosig', 'brogle', 'Windows 95', 'Windows XP', 'blender', 'Phexonia', 'tf2', 'Bastard', 'obby', 'david', 'WARIO', 'sandals', 'livestream', 'youtube', 'pickle', 'hot', 'RALEIGH', 'PEED FAMILY', 'gif', 'nostalgia critic', 'Britain', 'America', 'United Kingdom', 'soup', 'United States of America', 'WOMEN', 'cat', 'marselo', 'tech support', 'indian', 'japanese', 'Plants vs Zombies', 'Joe Biden', 'chinese', 'Chinese Republic', 'french fries', 'german', 'SWITZERLAND', 'denmark', 'Donald Trump', 'portuguese', 'nigerian', 'russian', 'beach', 'Lego', 'Documentation', 'mcdrive', 'no', 'yes', 'Rigby', 'Mordecai', 'BENSON', 'park', 'phil', 'Anvil', 'halloween', 'pumpkin', 'shut up', 'platinum', 'cheats', 'GOLD', 'cake day', 'pizza slice', 'lasagna', 'quesadilla', 'enchilada', 'Miner\'s Haven', 'berezaa', 'LEGENDARY', 'Bee Swarm Simulator', 'beta tester', 'creator', 'upvotes', 'downvotes', 'redditor', 'reddit', 'reddit arguments', 'twitter', 'twitter arguments', 'amongla', 'virus', 'viruses', 'INSTALL NOW', 'Torrent', 'Github', 'the ESSENCE', 'soup satan', 'soup god', 'quesley', 'empsy', , 'regal', 'deflorestation', 'DONKEY KONG', 'gay chains', 'Tss crazed', 'ralsei', 'ðŸ‘¶', 'âœ…', 'PIG', 'cucumber', 'mark\'s pizzeria', 'dominus pizza', 'pizza hut', 'wendy\'s', 'burger king', 'mcdonalds', 'nugget', 'fat', 'WTF', 'ROFL', 'XD', 'LMAO', 'LOL', 'Lad', 'griefed', 'Fitmc', '2b2t', 'POPBOB', 'Jeff', 'Slender', 'Piggy', 'ðŸ–', 'Burrito', 'fart channel', 'ðŸ’“', 'Banjo', 'guitarist', 'guitar', 'instruments', 'bingus', 'sussy', 'crewmate', 'Imposter', 'choccy milk', 'thwomp', 'ðŸ¡', 'baby', 'Admin', 'EMOTE GAME', 'Sega', 'Sega Genesis', 'Newgrounds', 'Gamejolt', 'Steam', 'Epic Games', 'basket', 'update released', 'Soup Land', 'ROCKET', 'clash of clans', 'lore', 'mech', 'Angry Birds', 'Bad Piggies', 'machine', 'Thanos', 'Sun', 'Moon', 'Friday Night Funkin', 'Mod', 'Minecraft', 'Terraria', 'Roblox', 'Shaders', '2012', '2016', 'peter', 'GTA 6', 'GTA', 'bananas', 'Hollow Knight', 'Burrito Bison', 'Taco', 'taxes', 'budget', 'dollars', 'british', 'brocolli', 'HELL', 'babis', 'kingdom', 'HAHAHA', 'arabic', 'Rocket League', 'Fortnite', 'mrflimflam', 'Flamingo', 'rap', 'MARIO', 'crimes', 'cordy', 'Halal', 'HARAM', 'Chungus', 'president', 'santa', 'WOW', 'FART', 'Garfield', 'POG', 'DEINX', 'discord', 'Market', 'Mark', 'EXPLOSIVE', 'combat', 'oyster', 'Epico', 'Grammar', 'SUS', 'fresh', 'matilda', 'sonic', 'Egyptian', 'White', 'BLACK', 'Tycoon', 'tunas', 'brazilian', 'Luigi']
var arabConnectors = ['basically', 'literally', 'unexpected', 'expected', 'lost', 'lost his shit', 'grinds', 'since', 'I\'m', 'he\'s', 'she\'s', 'le', 'now', 'says', 'shitted', 'promoted', 'demoted', 'buttered', 'lagging', 'praying', 'died', 'streaming', 'skydiving', 'trolled', 'goes viral', 'fight', 'gets fired', 'like', 'love', 'driving', 'could', 'can', 'that', 'this', 'these', 'those', 'who', 'WHEN', 'so', 'called out', 'on', 'sued', 'cancelled', 'installed', 'removed', 'muting', 'am', 'are', 'arrested', 'i', 'you', 'he', 'his', 'her', 'she', 'it', 'that', 'the', 'is', 'was', 'a', 'an', 'watch', 'play', 'gotta', 'get', 'gaming', 'balling', 'yours', 'mine', 'your', 'you\'re', 'we\'re', 'they\'re', 'our', 'we', 'they', 'them', 'their', 'wipe', 'born', 'pissing', 'taken off', 'holed', 'off', 'out', 'flood', 'spamming', 'buy', 'hacking', 'smelling', 'have', 'become', 'be', 'watching', 'Added',]
var punctuation = ['?', '.', '!', '...', ',']
var TOKEN = testing ? process.env.POOPYTOKEN2 : process.env.POOPYTOKEN
var globalPrefix = 'p:';
var psFiles = []
var psPasta = []
var emojiImages = []

async function getPsFiles() {
    return new Promise(resolve => {
        request.get('https://raw.githubusercontent.com/raIeigh/ps-media-json/main/psfiles.json', (_, __, body) => {
            resolve(JSON.parse(body).data)
        })
    })
}

async function getPsPasta() {
    return new Promise(resolve => {
        request.get('https://raw.githubusercontent.com/raIeigh/ps-media-json/main/pspasta.json', (_, __, body) => {
            resolve(JSON.parse(body).data)
        })
    })
}

async function getEmojiImages() {
    return new Promise(resolve => {
        request.get(`https://emojipedia.org/twitter/`, (_, __, body) => {
            var $ = cheerio.load(body)
            var gridEmojis = $('.emoji-grid').children()
            var emojis = []
            for (var i in gridEmojis) {
                if (!isNaN(Number(i))) {
                    var emoji = gridEmojis[i]
                    var emojisAttribs = emoji.children.find(child => child.name === 'a').children.find(child => child.name === 'img').attribs
                    emojis.push(emojisAttribs['data-srcset'] ? emojisAttribs['data-srcset'].replace('/144/', '/240/').replace(' 2x', '') : emojisAttribs.srcset.replace('/144/', '/240/').replace(' 2x', ''))
                }
            }
            resolve(emojis)
        })
    })
}

async function waitForChromeSessionEnd(msg) {
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    return new Promise(async resolve => {
        var waitMessage
        while (chromeWindow) {
            if (!waitMessage) waitMessage = await msg.channel.send('A Chrome session is currently occurring, and I can\'t have more than one or I crash, so you\'ll have to wait for it to end.').catch(() => { })
            await sleep(1000)
        }
        if (waitMessage) await waitMessage.delete().catch(() => { })
        resolve()
    })
}

function editDistance(s1, s2) {
    s1 = s1.toLowerCase();
    s2 = s2.toLowerCase();

    var costs = new Array();
    for (var i = 0; i <= s1.length; i++) {
        var lastValue = i;
        for (var j = 0; j <= s2.length; j++) {
            if (i == 0)
                costs[j] = j;
            else {
                if (j > 0) {
                    var newValue = costs[j - 1];
                    if (s1.charAt(i - 1) != s2.charAt(j - 1))
                        newValue = Math.min(Math.min(newValue, lastValue),
                            costs[j]) + 1;
                    costs[j - 1] = lastValue;
                    lastValue = newValue;
                }
            }
        }
        if (i > 0)
            costs[s2.length] = lastValue;
    }
    return costs[s2.length];
}

function similarity(s1, s2) {
    var longer = s1;
    var shorter = s2;
    if (s1.length < s2.length) {
        longer = s2;
        shorter = s1;
    }
    var longerLength = longer.length;
    if (longerLength == 0) {
        return 1.0;
    }
    return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
}

function chunkArray(myArray, chunk_size) {
    var index = 0;
    var arrayLength = myArray.length;
    var tempArray = [];

    for (index = 0; index < arrayLength; index += chunk_size) {
        myChunk = myArray.slice(index, index + chunk_size);
        tempArray.push(myChunk);
    }

    return tempArray;
}

function chunkObject(object, chunk_size) {
    var values = Object.values(object);
    var final = [];
    var counter = 0;
    var portion = {};

    for (var key in object) {
        if (counter !== 0 && counter % chunk_size === 0) {
            final.push(portion);
            portion = {};
        }
        portion[key] = values[counter];
        counter++
    }
    final.push(portion);

    return final
}

var special = {
    keys: {
        _rkeyword: {
            desc: "Returns a random keyword.",

            func: (msg) => {
                var keys = []
                for (var k in special.keys) {
                    if (k !== '_rkeyword') keys.push(k)
                }
                return special.keys[keys[Math.floor(Math.random() * keys.length)]].func(msg)
            },
        },

        _puncmark: {
            desc: "Returns a random punctuation mark.",

            func: () => {
                return punctuation[Math.floor(Math.random() * punctuation.length)]
            },
        },

        _word: {
            desc: "Returns a random word.",

            func: () => {
                var wordJSON = JSON.parse(fs.readFileSync('./templates/json/words.json'))
                return wordJSON.data[Math.floor(Math.random() * wordJSON.data.length)].word.value
            },
        },

        _country: {
            desc: "Returns a random country.",

            func: () => {
                var countryJSON = JSON.parse(fs.readFileSync('./templates/json/countries.json'))
                return countryJSON[Math.floor(Math.random() * countryJSON.length)].en_short_name
            },
        },

        _nationality: {
            desc: "Returns a random nationality.",

            func: () => {
                var countryJSON = JSON.parse(fs.readFileSync('./templates/json/countries.json'))
                return countryJSON[Math.floor(Math.random() * countryJSON.length)].nationality.toLowerCase()
            },
        },

        _restaurantfood: {
            desc: "Returns a random food from a restaurant.",

            func: () => {
                var restaurantJSON = JSON.parse(fs.readFileSync('./templates/json/foods.json'))
                var restaurant = restaurantJSON[Math.floor(Math.random() * restaurantJSON.length)]
                return restaurant.foodItems[Math.floor(Math.random() * restaurant.foodItems.length)].foodName
            },
        },

        _restaurant: {
            desc: "Returns a random restaurant.",

            func: () => {
                var restaurantJSON = JSON.parse(fs.readFileSync('./templates/json/foods.json'))
                return restaurantJSON[Math.floor(Math.random() * restaurantJSON.length)].restaurant
            },
        },

        _food: {
            desc: "Returns a random food.",

            func: () => {
                var foods = ["apple", "apricot", "artichoke", "arugula", "avocado", "bacon", "bagel", "baked ziti", "bamboo shoot", "banana", "barbecue", "beef", "bell pepper", "berry", "biscuits and gravy", "bitter melon", "blackberry", "boiled peanuts", "boysenberry", "bread", "breakfast burrito", "breakfast cereal", "breakfast sandwich", "breakfast sausage", "broad bean", "broccoli", "brussels sprout", "buffalo burger", "buffalo wing", "butter", "cabbage", "calzone", "cantaloupe", "carambola", "carrot", "cauliflower", "celery", "cereal", "chard", "chayote", "cherimoya", "cherry", "chicken and waffles", "chicken divan", "chicken fingers", "chicken fried steak", "chicken meat", "chicken soup", "chicory", "chili con carne", "chili pepper", "chocolate chip cookie", "chocolate milk", "cinnamon roll", "clam chowder", "coconut", "coffee", "common fig", "condiment", "corn chowder", "cornbread", "corned beef", "cottage cheese", "crab cake", "cracker", "cranberry", "cream cheese", "croissant", "cucumber", "daikon", "date palm", "doughnut", "durian", "egg as food", "eggplant", "eggs benedict", "enchilada", "endive", "energy bar", "english muffin", "fajita", "fettuccine alfredo", "fortune cookie", "french toast", "fried chicken", "fried egg", "fried fish", "frito pie", "fruit", "frybread", "garden asparagus", "garden rhubarb", "garlic", "gooseberry", "grape", "grapefruit", "gravy", "green bean", "green bean casserole", "grits", "gumbo", "hamburger", "hash browns", "herb", "hoppin' john", "horned melon", "hot dog", "huevos rancheros", "jambalaya", "jell-o", "jerky", "juice", "jujube", "kale", "kiwifruit", "kohlrabi", "kumquat", "lasagne", "leek", "lemon", "lettuce", "lime", "lobster roll", "longan", "loquat", "lychee", "macaroni and cheese", "maize", "mango", "marrow-stem kale", "meat", "meatloaf", "milk", "mozzarella", "muffin", "muffuletta", "muskmelon", "mustard greens", "napa cabbage", "noodle", "oatmeal", "okra", "olive", "omelette", "onion", "orange", "orange juice", "pancake", "papaya", "parmigiana", "parsnip", "passion fruit", "pasta", "pea", "peach", "peanut butter", "pear", "persimmon", "pineapple", "pitaya", "pizza", "pomegranate", "pomelo", "popcorn", "pork", "potato", "prune", "purple mangosteen", "quiche", "quince", "radish", "rapini", "raspberry", "red cabbage", "rice", "roast chicken", "rutabaga", "salad", "sandwich", "sauce", "sausage", "scallion", "scrambled eggs", "seafood", "seasoning", "shallot", "sloppy joe", "smoothie", "soursop", "spaghetti", "spinach", "steak", "strawberry", "stuffing", "taco", "taco salad", "taco soup", "tangelo", "tangerine", "tea", "thanksgiving dinner", "tomato", "tortellini", "turnip", "turnip greens", "waffle", "watercress", "watermelon", "yogurt", "zucchini"]
                return foods[Math.floor(Math.random() * foods.length)]
            },
        },

        _fruit: {
            desc: "Returns a random fruit.",

            func: () => {
                var fruits = ["apple", "apricot", "avocado", "banana", "berry", "blackberry", "boysenberry", "cantaloupe", "carambola", "cherimoya", "cherry", "coconut", "common fig", "cranberry", "date palm", "durian", "gooseberry", "grape", "grapefruit", "horned melon", "jujube", "kiwifruit", "kumquat", "lemon", "lime", "longan", "loquat", "lychee", "mango", "muskmelon", "olive", "orange", "papaya", "passion fruit", "peach", "pear", "persimmon", "pineapple", "pitaya", "pomegranate", "pomelo", "prune", "purple mangosteen", "quince", "raspberry", "soursop", "strawberry", "tangelo", "tangerine", "watermelon"]
                return fruits[Math.floor(Math.random() * fruits.length)]
            },
        },

        _vegetable: {
            desc: "Returns a random vegetable.",

            func: () => {
                var vegetables = ["artichoke", "arugula", "bamboo shoot", "bell pepper", "bitter melon", "broad bean", "broccoli", "brussels sprout", "cabbage", "carrot", "cauliflower", "celery", "chard", "chayote", "chicory", "chili pepper", "cucumber", "daikon", "eggplant", "endive", "garden asparagus", "garden rhubarb", "garlic", "green bean", "herb", "kale", "kohlrabi", "leek", "lettuce", "maize", "marrow-stem kale", "mustard greens", "napa cabbage", "okra", "onion", "parsnip", "pea", "potato", "radish", "rapini", "red cabbage", "rutabaga", "scallion", "shallot", "spinach", "tomato", "turnip", "turnip greens", "watercress", "zucchini"]
                return vegetables[Math.floor(Math.random() * vegetables.length)]
            },
        },

        _sentence: {
            desc: "Returns a random sentence.",

            func: () => {
                var sentenceJSON = JSON.parse(fs.readFileSync('./templates/json/sentences.json'))
                return sentenceJSON.data[Math.floor(Math.random() * sentenceJSON.data.length)].sentence
            },
        },

        _name: {
            desc: "Returns a random name.",

            func: () => {
                var nameJSON = JSON.parse(fs.readFileSync('./templates/json/names.json'))
                var surnames = nameJSON.surname
                var names = nameJSON.male.concat(nameJSON.female)
                return `${names[Math.floor(Math.random() * names.length)].name.value} ${surnames[Math.floor(Math.random() * surnames.length)].name.value}`
            },
        },

        _noun: {
            desc: "Returns a random noun.",

            func: () => {
                var nounJSON = JSON.parse(fs.readFileSync('./templates/json/nouns.json'))
                return nounJSON.data[Math.floor(Math.random() * nounJSON.data.length)].noun
            },
        },

        _verb: {
            desc: "Returns a random verb.",

            func: () => {
                var verbJSON = JSON.parse(fs.readFileSync('./templates/json/verbs.json'))
                return verbJSON.data[Math.floor(Math.random() * verbJSON.data.length)].verb
            },
        },

        _adj: {
            desc: "Returns a random adjective.",

            func: () => {
                var adjJSON = JSON.parse(fs.readFileSync('./templates/json/adjectives.json'))
                return adjJSON.data[Math.floor(Math.random() * adjJSON.data.length)].adjective
            },
        },

        _emoji: {
            desc: "Returns a random Unicode emoji.",

            func: () => {
                var emojiJSON = JSON.parse(fs.readFileSync('./templates/json/emoji.json'))
                return emojiJSON[Math.floor(Math.random() * emojiJSON.length)].emoji
            },
        },

        _serveremoji: {
            desc: "Returns a random server emoji.",

            func: (msg) => {
                var emojis = msg.guild.emojis.cache;
                var emojis2 = [];
                emojis.forEach(emoji => emojis2.push({ animated: emoji.animated, id: emoji.id, name: emoji.name }))
                var emoji = emojis2[Math.floor(Math.random() * emojis2.length)]
                return `<${emoji.animated ? 'a' : ''}:${emoji.name}:${emoji.id}>`
            },
        },

        _arabw: {
            desc: "Returns a completely nonsensical word that doesn't even exist.",

            func: () => {
                var vowels = ['a', 'e', 'i', 'o', 'u']
                var consonants = []
                for (i = 97; i <= 122; i++) {
                    var char = String.fromCharCode(i)
                    if (!vowels.find(letter => letter == char)) {
                        consonants.push(char)
                    }
                }
                var word = ''
                for (i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                    word += consonants[Math.floor(Math.random() * consonants.length)] + vowels[Math.floor(Math.random() * vowels.length)]
                }
                return word
            },
        },

        _arabottify: {
            desc: "Returns a random arabottify phrase.",

            func: (msg) => {
                var arabArray = []
                var dict = 1
                var conn = 1
                for (var i = 0; i < Math.floor(Math.random() * 40) + 1; i++) {
                    var randomFactor = Math.floor(Math.random() * 8)
                    if (randomFactor === 8) {
                        dict = 1
                        conn = 1
                        arabArray.push(msg.member.nickname || msg.author.username + ((Math.floor(Math.random() * 5) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                    } else {
                        function chooseWord() {
                            if (Math.floor(Math.random() * dict) + 1 === (dict === 3 ? 0 : 1)) {
                                conn = 1
                                dict++
                                arabArray.push(arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + ((Math.floor(Math.random() * 5) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                            } else if (Math.floor(Math.random() * conn) + 1 === (conn === 3 ? 0 : 1)) {
                                dict = 1
                                conn++
                                arabArray.push(arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + ((Math.floor(Math.random() * 5) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                            } else {
                                chooseWord()
                            }
                        }

                        chooseWord()
                    }
                }

                return arabArray.join(' ')
            },
        },

        _arabfriendly: {
            desc: "Returns a random word from the arabottify command's dictionary, except it doesn't include words like \"sex\" or \"penis\".",

            func: () => {
                return tenorDictionary[Math.floor(Math.random() * tenorDictionary.length)]
            },
        },

        _arabconnector: {
            desc: "Returns a random connector from the arabottify command's connector dictionary.",

            func: () => {
                return arabConnectors[Math.floor(Math.random() * arabConnectors.length)]
            },
        },

        _arab: {
            desc: "Returns a random word from the arabottify command's dictionary.",

            func: () => {
                return arabDictionary[Math.floor(Math.random() * arabDictionary.length)]
            },
        },

        _fnaf: {
            desc: "Returns a random phrase based on FNAF, like \"fred\" or \"Fred five nights\".",

            func: () => {
                var fnaf = [
                    'fred',
                    'FRED!',
                    'Fred five nights',
                    'fred five.',
                    'the night of freddy',
                    'FIVE FREDDY NIGHTS',
                    'Fred night at',
                    'Fred at night',
                    'Fred night',
                    'at the freddy night',
                    'five freddy nights',
                    'nig',
                    'Freddy\'s',
                    'At\'s fredyd',
                    'les fred de nuit',
                    'Five Night Freddy',
                    'five nights at freddys',
                    'five nights at freddy\'s',
                    'five night\'s at freddy\'s',
                    'fnaf',
                    'fnf',
                    'frede',
                    'feddy',
                    'FEDDY!',
                    '5',
                    'nights',
                    'Fiv\'esg \'ighes at fryed'
                ]
                return fnaf[Math.floor(Math.random() * fnaf.length)]
            },
        },

        _insult: {
            desc: "Returns a random \"insult\". (i honestly don't know what to call it)",

            func: () => {
                var insults = [
                    'gay',
                    'lesbian',
                    'catboy',
                    'catboy maid',
                    'maid',
                    'trans',
                    'bisexual',
                    'pedophile',
                    'degenerate',
                    'femboy',
                    'furry',
                    'tomboy',
                    'retard',
                    'horny',
                    'racist',
                    'underaged'
                ]
                return insults[Math.floor(Math.random() * insults.length)]
            },
        },

        _randomgif: {
            desc: "Returns a random Tenor gif.",

            func: async () => {
                return new Promise(resolve => {
                    function getWord() {
                        var word = tenorDictionary[Math.floor(Math.random() * tenorDictionary.length)]
                        if (!word) {
                            return getWord()
                        }
                        return word.toLowerCase()
                    }

                    request.get(`https://g.tenor.com/v1/search?q=${encodeURIComponent(getWord())}&key=${process.env.TENORKEY}&limit=20`, (_, __, body) => {
                        var parsedBody = JSON.parse(body)
                        resolve(parsedBody.results[Math.floor(Math.random() * parsedBody.results.length)].itemurl)
                    })
                })
            },
        },

        _pspasta: {
            desc: "Returns a random Phexonia Stuiods related copypasta or phrase.",

            func: () => {
                return psPasta[Math.floor(Math.random() * psPasta.length)]
            },
        },

        _ps: {
            desc: "Returns a random Phexonia Stuiods related file.",

            func: () => {
                return psFiles[Math.floor(Math.random() * psFiles.length)]
            },
        },

        _unicode: {
            desc: "Returns a completely random unicode character.",

            func: () => {
                return String.fromCharCode(Math.floor(Math.random() * 15000))
            },
        },

        _ipaddress: {
            desc: "Returns a random IP address.",

            func: () => {
                return randomip()
            },
        },

        _id: {
            desc: "Returns your own id.",

            func: (msg) => {
                return msg.author.id
            },
        },

        _username: {
            desc: "Returns your own username.",

            func: (msg) => {
                return msg.author.username
            },
        },

        _nickname: {
            desc: "Returns your own nickname.",

            func: (msg) => {
                return msg.member.nickname || msg.author.username
            },
        },

        _memberid: {
            desc: "Returns a random member's id from the server.",

            func: (msg) => {
                var datamembers = data['guild-data'][msg.guild.id]['members'];
                var keys = Object.keys(datamembers)
                return keys[Math.floor(Math.random() * keys.length)]
            },
        },

        _member: {
            desc: "Returns a random member from the server.",

            func: async (msg) => {
                var datamembers = data['guild-data'][msg.guild.id]['members'];
                var members = []
                for (var id in datamembers) {
                    var datamember = datamembers[id]
                    if (datamember.username) members.push(datamember.username)
                }
                return members[Math.floor(Math.random() * members.length)]
            },
        },

        _sayori: {
            desc: "returns not sayori ai",

            func: async (msg) => {
                var datamembers = data['guild-data'][msg.guild.id]['members'];
                var members = []
                for (var id in datamembers) {
                    var datamember = datamembers[id]
                    if (datamember.username) members.push(datamember.username)
                }
                var year = new Date(Date.now()).getFullYear()
                var sayoriAdjectives = ['HORNY', 'FARTING', 'RACIST', 'STUPID', 'FEMBOY', 'GAY', 'TRANS', 'UNDERAGED', 'RETARD', 'BITCH', 'ASSHOLE', 'MOTHERFUCKER']
                var adjectives = ['is trans', 'the femboy', 'the futa', 'the idiot', 'the stalker', 'the impostor', 'now sus', 'the nutter', 'the shitter', 'the burger', 'is very annoying', 'big', 'fat', 'is thin', 'is small', 'what', 'is funny', 'noob', 'wtf', 'with pp', 'peed his pants', 'is amongla', 'looks at porn lolololol'];
                var shipAdjectives = ['likes', 'you like', 'loves', 'you love', 'you are in love with', 'you should marry', 'with', 'hug', 'your game is now poopoo for'];
                var fnf = ['dad', 'gf', 'pico', 'skid and pump', 'monster', 'mom', 'senpai', 'tankman', 'whitty', 'carol', 'hex', 'ruv', 'sarvente', 'miku', 'tricky', 'zardy', 'matt', 'garcello', 'shaggy', 'annie', 'cheeky', 'bob', 'tabi', 'agoti', 'kapi', 'neon', 'nene', 'monika', 'cg5', 'updike', 'selever', 'tord', 'impostor', 'trollge', 'tree']
                var consoles = ['pc', 'mobile', 'tablet', 'xbox', 'nintendo switch', 'nintendo 3ds', 'nintendo 2ds', 'psp', 'ps1', 'ps2', 'gamecube', 'ps3', 'ps4', 'ps5', 'wii', 'xbox 360', 'xbox one', 'gameboy', 'nintendo 64', 'sega genesis', 'wii u']
                var options = [
                    { pings: false, text: 'lol https://tenor.com/view/sus-suspect-among-us-gif-18663592' },
                    { pings: false, text: 'https://tenor.com/view/madness-hank-new-grounds-jump-gif-17044581' },
                    { pings: false, text: 'https://tenor.com/view/friday-night-funkin-hey-boyfriend-gif-21180248' },
                    { pings: true, text: 'SHUT UP' },
                    { pings: true, text: 'sussy' },
                    { pings: false, text: 'lol' },
                    { pings: false, text: 'among us impostor in madness tricky mod' },
                    { pings: false, text: 'ehat', edit: 'what' },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + '.' },
                    { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fandom is dying' },
                    { pings: false, text: 'THE VS ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' MOD' },
                    { pings: false, text: 'WHAT A ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() },
                    { pings: false, text: 'they added the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' big ass' },
                    { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fetish' },
                    { pings: false, text: 'finally a ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' game to ' + consoles[Math.floor(Math.random() * consoles.length)] },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' was made in ' + (Math.floor(Math.random() * (year - 1980)) + 1980) + ' xd' },
                    { pings: false, text: 'this will be ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + (Math.floor(Math.random() * (year - 2000)) + 2000) },
                    { pings: false, text: 'YOU DONT KILL ' + (arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' ').repeat(2) + 'KILLS YOU!!!!!!!!!!!!!!!!' },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is in the ' + fnf[Math.floor(Math.random() * fnf.length)] + ' week' },
                    { pings: false, text: 'no not big ass ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: true, text: 'snat' },
                    { pings: false, text: 'STOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPPPPPPPPPPPPPPPP' },
                    { pings: false, text: 'WOOOOOOOOOOOOOOOOOOOOOOOOOOOOO' },
                    { pings: true, text: 'wjat', edit: 'what' },
                    { pings: false, text: 'NO' },
                    { pings: false, text: 'ðŸ¤£ ðŸ¤£ ðŸ¤£ ðŸ¤£ ðŸ¤£ ðŸ¤£' },
                    { pings: false, text: 'STOP' },
                    { pings: false, text: 'WHU', edit: 'WHY' },
                    { pings: true, text: 'WHY' },
                    { pings: false, text: 'GOD HELP ME' },
                    { pings: false, text: 'IM NOT' },
                    { pings: false, text: 'wtf' },
                    { pings: false, text: 'wow' },
                    { pings: false, text: 'no' },
                    { pings: false, text: 'not again' },
                    { pings: false, text: 'IM NOT ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                    { pings: false, text: 'im ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)].toLowerCase() },
                    { pings: false, text: 'nooooo' },
                    { pings: false, text: 'stol', edit: 'stop' },
                    { pings: false, text: 'Hope you realize that people can become not cringe. Maybe. Juuuust maybe. I have stopped doing shit with the "gay chains". If you tried not dwelling on the past maybe you could actually realize how annoying you are. Now let me guess youll respond with a short answer, not answer, respond with what I did, or completely change the topic.' },
                    { pings: true, text: 'no' },
                    { pings: false, text: 'gay' },
                    { pings: false, text: 'i dare someone to post porn on my dm\'s' },
                    { pings: false, text: '._.' },
                    { pings: true, text: '' },
                    { pings: false, text: msg.author.username.toUpperCase() + ' WHY' },
                    { pings: false, text: 'BRUH' },
                    { pings: false, text: 'SUS' },
                    { pings: false, text: 'im underaged' },
                    { pings: true, text: 'YOU SUSSY' },
                    { pings: false, text: 'AMOGUS' },
                    { pings: false, text: 'is that friday night porn' },
                    { pings: true, text: 'flop' },
                    { pings: false, text: 'i like porn ðŸ¥² ðŸ¥² ðŸ¥² ðŸ¥² ðŸ¥² ðŸ¥²' },
                    { pings: true, text: 'stupid ' + msg.author.username.toLowerCase() },
                    { pings: false, text: 'not ' + msg.author.username.toLowerCase() },
                    { pings: false, text: 'wth ' + msg.author.username.toLowerCase() },
                    { pings: false, text: 'lol ' + msg.author.username.toLowerCase() },
                    { pings: false, text: msg.author.username.toLowerCase() + ' ' + adjectives[Math.floor(Math.random() * adjectives.length)] },
                    { pings: false, text: msg.author.username.toLowerCase() + ': ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'no not ' + msg.author.username.toLowerCase() + ' with ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'ahhhhhhhhhh' },
                    { pings: false, text: 'school suuucks' },
                    { pings: false, text: 'why am i a bot' },
                    { pings: false, text: msg.author.username.toLowerCase() + ' ' + shipAdjectives[Math.floor(Math.random() * shipAdjectives.length)] + ' ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                    { pings: false, text: 'is ' + members[Math.floor(Math.random() * members.length)].toLowerCase() + ' hot' },
                    { pings: false, text: 'im not pinging ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                    { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' NOT ME' },
                    { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS THE ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                    { pings: false, text: msg.author.username.toLowerCase() }
                ];

                return options[Math.floor(Math.random() * options.length)].text
            }
        }
    },

    functions: {
        rmodifier: {
            helpf: "(phrase)",

            desc: "chooses A RANDOM mODIFIER that Modifies The Phrase.",

            func: (word) => {
                var f = 'rmodifier'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var funcs = []
                for (var ff in special.functions) {
                    if (ff !== f) funcs.push(ff)
                }
                return special.functions[funcs[Math.floor(Math.random() * funcs.length)]].func(word)
            },
        },

        image: {
            helpf: "(query)",

            desc: "Returns a random image out of the search query.",

            func: async (word) => {
                var f = 'image'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var urls = []

                async function search() {
                    return new Promise(resolve => {
                        gis(word, async function (_, results) {
                            for (var i in results) {
                                var result = results[i]
                                var url = result.url.replace(/\\u([a-z0-9]){4}/g, (match) => {
                                    return String.fromCharCode(Number('0x' + match.substring(2, match.length)))
                                })

                                urls.push(url)
                            }

                            resolve()
                        })
                    })
                }

                await search()

                if (!urls.length) return word

                return urls[Math.floor(Math.random() * urls.length)]
            },
        },

        gif: {
            helpf: "(query)",

            desc: "Returns a random Tenor GIF out of the search query.",

            func: async (word) => {
                var f = 'gif'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var urls = []

                async function search() {
                    return new Promise(resolve => {
                        exec(`curl "https://g.tenor.com/v1/search?q=${encodeURIComponent(word)}&key=${process.env.TENORKEY}&limit=100"`, (_, body) => {
                            var parsedBody = JSON.parse(body)

                            for (var i in parsedBody.results) {
                                var result = parsedBody.results[i]
                                urls.push(result)
                            }

                            resolve()
                        })
                    })
                }

                await search()

                if (!urls.length) return word

                return urls[Math.floor(Math.random() * urls.length)].itemurl
            },
        },

        generate: {
            helpf: "(phrase)",

            desc: "Generates subsequent text from the phrase inside the modifier.",

            func: async (word) => {
                var f = 'generate'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]

                var resp = await deepai.callStandardApi("text-generator", {
                    text: word,
                }).catch(() => { })

                if (resp) {
                    return resp.output
                }

                return word
            },
        },

        choice: {
            helpf: "(choice1 | choice2 | choice3 | etc...)",

            desc: "Chooses a random option out of the options inside the phrase. Each option should be separated by \"|\".",

            func: (word) => {
                var f = 'choice'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var split = word.split(/ ?\| ?/)
                return split[Math.floor(Math.random() * split.length)]
            },
        },

        randomnumber: {
            helpf: "(min | max)",

            desc: "Returns a random number between min and max. They should be separated by \"|\".",

            func: (word) => {
                var f = 'randomnumber'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var split = word.split(/ ?\| ?/)
                var min = Math.round(Number(split[0])) || 0
                var max = Math.round(Number(split[split.length - 1])) || 0
                return Math.floor(Math.random() * (max + 1 - min)) + min
            },
        },

        arg: {
            helpf: "(number)",

            desc: "Returns the argument in the message with the index <number>. Putting \"+\" after the number means all other arguments after it.",

            func: (word, msg, content) => {
                var f = 'arg'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var index = Number(word.replace(/\+/g, '')) <= 0 ? 0 : Math.round(Number(word.replace(/\+/g, ''))) || 0
                var words = content.split(' ')
                for (var i in words) {
                    if (words[i] ? words[i].match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i')) : undefined) words[i] = ''
                }
                if (word.endsWith('+')) return words.slice(index).join(' ') || ''
                return words[index] || ''
            },
        },

        repeat: {
            helpf: "(phrase | times)",

            desc: "Repeats the phrase inside the function by <times>. The phrase and the times to repeat should be separated by \"|\".",

            func: (word) => {
                var f = 'repeat'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var split = word.split(/ ?\| ?/)
                var repeat = split.splice(split.length - 1)
                repeat = isNaN(Number(repeat)) ? 2 : Number(repeat) <= 1 ? 1 : Number(repeat) >= 100000 ? 100000 : Number(repeat) || 2
                return split.join(' ').repeat(Number(repeat) || 2)
            },
        },

        changewords: {
            helpf: "(phrase)",

            desc: "Replaces all of the words in the phrase with different ones.",

            func: (word) => {
                var f = 'changewords'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var wrdJSON = JSON.parse(fs.readFileSync('./templates/json/words.json'))
                var wrds = []
                var wrdsR = []
                for (var i in wrdJSON.data) {
                    var wrd = wrdJSON.data[i]
                    wrds.push(wrd.word.value)
                    wrdsR.push('^' + wrd.word.value)
                }
                var wrdRegex = new RegExp(`${wrdsR.join('|')}`, 'i')
                var words = word.split(' ')
                for (var i in words) {
                    if (words[i].match(wrdRegex)) words[i] = words[i].replace(wrdRegex, (word) => {
                        var wrd = wrds[Math.floor(Math.random() * wrds.length)]
                        if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return wrd
                        else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return wrd.substring(0, 1).toUpperCase() + wrd.substring(1).toLowerCase()
                        else return wrd.toUpperCase()
                    })
                }
                return words.join(' ')
            },
        },

        changenouns: {
            helpf: "(phrase)",

            desc: "Replaces all of the nouns in the phrase with different ones.",

            func: (word) => {
                var f = 'changenouns'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var nounJSON = JSON.parse(fs.readFileSync('./templates/json/nouns.json'))
                var nouns = []
                var nounsR = []
                for (var i in nounJSON.data) {
                    var noun = nounJSON.data[i]
                    nouns.push(noun.noun)
                    nounsR.push('^' + noun.noun)
                }
                var nounRegex = new RegExp(`${nounsR.join('|')}`, 'i')
                var words = word.split(' ')
                for (var i in words) {
                    if (words[i].match(nounRegex)) words[i] = words[i].replace(nounRegex, (word) => {
                        var noun = nouns[Math.floor(Math.random() * nouns.length)]
                        if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return noun
                        else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return noun.substring(0, 1).toUpperCase() + noun.substring(1).toLowerCase()
                        else return noun.toUpperCase()
                    })
                }
                return words.join(' ')
            },
        },

        changeverbs: {
            helpf: "(phrase)",

            desc: "Replaces all of the verbs in the phrase with different ones.",

            func: (word) => {
                var f = 'changeverbs'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var verbJSON = JSON.parse(fs.readFileSync('./templates/json/verbs.json'))
                var verbs = []
                var verbsR = []
                for (var i in verbJSON.data) {
                    var verb = verbJSON.data[i]
                    verbs.push(verb.verb)
                    verbsR.push('^' + verb.verb)
                }
                var verbRegex = new RegExp(`${verbsR.join('|')}`, 'i')
                var words = word.split(' ')
                for (var i in words) {
                    if (words[i].match(verbRegex)) words[i] = words[i].replace(verbRegex, (word) => {
                        var verb = verbs[Math.floor(Math.random() * verbs.length)]
                        if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return verb
                        else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return verb.substring(0, 1).toUpperCase() + verb.substring(1).toLowerCase()
                        else return verb.toUpperCase()
                    })
                }
                return words.join(' ')
            },
        },

        changeadjs: {
            helpf: "(phrase)",

            desc: "Replaces all of the adjectives in the phrase with different ones.",

            func: (word) => {
                var f = 'changeadjs'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var adjJSON = JSON.parse(fs.readFileSync('./templates/json/adjectives.json'))
                var adjs = []
                var adjsR = []
                for (var i in adjJSON.data) {
                    var adj = adjJSON.data[i]
                    adjs.push(adj.adjective)
                    adjsR.push('^' + adj.adjective)
                }
                var adjRegex = new RegExp(`${adjsR.join('|')}`, 'i')
                var words = word.split(' ')
                for (var i in words) {
                    if (words[i].match(adjRegex)) words[i] = words[i].replace(adjRegex, (word) => {
                        var adj = adjs[Math.floor(Math.random() * adjs.length)]
                        if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return adj
                        else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return adj.substring(0, 1).toUpperCase() + adj.substring(1).toLowerCase()
                        else return adj.toUpperCase()
                    })
                }
                return words.join(' ')
            },
        },

        lower: {
            helpf: "(phrase)",

            desc: "makes the phrase all lowercase.",

            func: (word) => {
                var f = 'lower'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                return word.toLowerCase()
            },
        },

        upper: {
            helpf: "(phrase)",

            desc: "MAKES THE PHRASE ALL UPPERCASE!",

            func: (word) => {
                var f = 'upper'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                return word.toUpperCase()
            },
        },

        cap: {
            helpf: "(phrase)",

            desc: "Makes the phrase inside the modifier start with a capital.",

            func: (word) => {
                var f = 'cap'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                return word.substring(0, 1).toUpperCase() + word.substring(1, word.length)
            }
        },

        capall: {
            helpf: "(phrase)",

            desc: "Makes Every Word In The Phrase Inside The Modifier Start With A Capital.",

            func: (word) => {
                var f = 'capall'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var words = word.split(' ')
                for (var i in words) {
                    var w = words[i]
                    words[i] = w.substring(0, 1).toUpperCase() + w.substring(1, w.length)
                }
                return words.join(' ')
            }
        },

        swapcase: {
            helpf: "(phrase)",

            desc: "sWAPS ALL THE CASES IN THE PHRASE INSIDE THE MODIFIER!",

            func: (word) => {
                var f = 'swapcase'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var swapword = ''
                for (var i = 0; i < word.length; i++) {
                    if (word[i] === word[i].toLowerCase()) {
                        swapword += word[i].toUpperCase()
                    } else {
                        swapword += word[i].toLowerCase()
                    }
                }
                return swapword
            }
        },

        scramble: {
            helpf: "(phrase)",

            desc: "the phrase Scrambles the modifier. inside",

            func: (word) => {
                var f = 'scramble'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var words = word.split(' ')
                var scrambled = []
                var scrambled2 = []
                for (var i in words) {
                    var w = words[i]
                    scrambled.push({ word: w, randomness: Math.random() })
                }
                scrambled.sort(function (a, b) {
                    return a.randomness - b.randomness
                })
                for (var i in scrambled) {
                    var word = scrambled[i]
                    scrambled2.push(word.word)
                }
                return scrambled2.join(' ')
            }
        },

        stroke: {
            helpf: "(phrase)",

            desc: "ion into a stroke.  thnernn rhr rie tiaotsee pec",

            func: (word) => {
                var f = 'stroke'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                return gibberish(word)
            }
        },

        arabottify: {
            helpf: "(phrase)",

            desc: "born the adds it. and WHEN inside modifier words he's phrase to the it. Scrambles extra to",

            func: (word, msg) => {
                var f = 'arabottify'
                word = word.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))[1]
                var arabArray = word.split(' ')
                var arabArray2 = []
                arabArray.forEach(word => {
                    for (var i = 0; i < ((Math.floor(Math.random() * 5) === 1 && 2) || 1); i++) {
                        arabArray2.push({ word: word + ((Math.floor(Math.random() * 7) === 6 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                    }
                    if (Math.floor(Math.random() * 4) === 3) {
                        var randomFactor = Math.floor(Math.random() * 8)
                        if (randomFactor === 7) {
                            arabArray2.push({ word: msg.member.nickname || msg.author.username + ((Math.floor(Math.random() * 7) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        } else if (randomFactor >= 0 && randomFactor <= 3) {
                            arabArray2.push({ word: arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + ((Math.floor(Math.random() * 7) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        } else {
                            arabArray2.push({ word: arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + ((Math.floor(Math.random() * 7) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        }
                    }
                })
                arabArray2.sort(function (a, b) {
                    return a.randomness - b.randomness
                })
                arabArray = []
                arabArray2.forEach(word => {
                    arabArray.push(word.word)
                })
                return arabArray.join(' ')
            }
        },
    }
}

var chunkkeyfields = chunkObject(special.keys, 10)
var keyfields = []

for (var kg in chunkkeyfields) {
    var keygroup = chunkkeyfields[kg]
    keyfields[kg] = []
    for (var k in keygroup) {
        var key = keygroup[k]
        keyfields[kg].push({
            name: k,
            value: key.desc
        })
    }
}

var chunkfuncfields = chunkObject(special.functions, 10)
var funcfields = []

for (var fg in chunkfuncfields) {
    var funcgroup = chunkfuncfields[fg]
    funcfields[fg] = []
    for (var f in funcgroup) {
        var func = funcgroup[f]
        funcfields[fg].push({
            name: f + func.helpf,
            value: func.desc
        })
    }
}

var commands = [
    {
        name: ["destroy", "kill", "shutdown"],
        execute: async function (msg) {
            var ownerid = ownerids.find(id => id == msg.author.id);
            if (ownerid === undefined) {
                msg.channel.send('Owner only!').catch(() => { })
                return
            }
            else {
                msg.channel.send('The salami lid')
                    .then(() => {
                        bot.destroy()
                        process.exit()
                    })
                    .catch(() => { })
            };
        },
        help: {
            "name": "destroy/kill/shutdown",
            "value": "Causes Poopy to shutdown."
        },
        type: "Owner"
    },

    {
        name: ["reset", "restart", "reboot"],
        execute: async function (msg) {
            var ownerid = ownerids.find(id => id == msg.author.id);
            if (ownerid === undefined) {
                msg.channel.send('Owner only!').catch(() => { })
                return
            }
            else {
                await msg.channel.send('The chorizo slice').catch(() => { })
                clearInterval(statusInterval)
                bot.destroy()
                exec('node .')
            };
        },
        help: {
            "name": "reset/restart/reboot",
            "value": "Resets Poopy."
        },
        cooldown: 60000,
        type: "Owner"
    },

    {
        name: ["invite"],
        execute: async function (msg) {
            msg.channel.startTyping().catch(() => { })
            msg.channel.send(`Bot invite link: https://discord.com/oauth2/authorize?client_id=${bot.user.id}&scope=bot&permissions=8\nOfficial Discord server link: https://discord.gg/R4nEBP5Ymf`).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "invite",
            "value": "Generates Poopy's invite and Discord server links."
        },
        cooldown: 2500,
        type: "Info"
    },

    {
        name: ["impostor", "imposter", "sus"],
        execute: async function (msg, args) {
            if (msg.member.hasPermission('MANAGE_WEBHOOKS') || msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                if (!msg.mentions.members.size) {
                    var user = args[1]
                    if (args[1] === undefined) {
                        user = msg.author.id
                    }

                    async function getUser(id) {
                        await msg.guild.members.fetch(id)
                            .then(function (user) {
                                if (!data['guild-data'][msg.guild.id]) {
                                    data['guild-data'][msg.guild.id] = {}
                                }
                                if (!data['guild-data'][msg.guild.id]['members'][user.id]) {
                                    data['guild-data'][msg.guild.id]['members'][user.id] = {}
                                }
                                if (!data['guild-data'][msg.guild.id]['members'][user.id]['impostor']) {
                                    data['guild-data'][msg.guild.id]['members'][user.id]['impostor'] = false
                                }
                                if (data['guild-data'][msg.guild.id]['members'][user.id]['impostor'] === false) {
                                    data['guild-data'][msg.guild.id]['members'][user.id]['impostor'] = true
                                    msg.channel.send(user.user.username + ' is now the Impostor.', {
                                        allowedMentions: {
                                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                } else {
                                    data['guild-data'][msg.guild.id]['members'][user.id]['impostor'] = false
                                    msg.channel.send(user.user.username + ' is not the Impostor.', {
                                        allowedMentions: {
                                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                }
                            })
                            .catch(function () {
                                msg.channel.send('Invalid user ID: **' + user + '**', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            })
                    }

                    getUser(user)
                } else {
                    if (!data['guild-data'][msg.guild.id]) {
                        data['guild-data'][msg.guild.id] = {}
                    }
                    if (!data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]) {
                        data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id] = {}
                    }
                    if (!data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor']) {
                        data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] = false
                    }
                    if (data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] === false) {
                        data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] = true
                        msg.channel.send(msg.mentions.members.first().user.username + ' is now the Impostor.', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    } else {
                        data['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] = false
                        msg.channel.send(msg.mentions.members.first().user.username + ' is not the Impostor.', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    }
                }
            }
            else {
                msg.channel.send('You need to have the manage webhooks permission to execute that!').catch(() => { })
                return;
            };
        },
        help: {
            "name": "impostor/imposter/sus [user] (manage webhooks permission only)",
            "value": "Trap someone in the impostor forcefully"
        },
        cooldown: 2500,
        perms: ["ADMINISTRATOR", "MANAGE_WEBHOOKS"],
        type: "Fun"
    },

    {
        name: ["toggledms", "tdms"],
        execute: async function (msg) {
            if (!data['user-data'][msg.author.id]) {
                data['user-data'][msg.author.id] = {}
            }
            if (data['user-data'][msg.author.id]['dms'] === undefined) {
                data['user-data'][msg.author.id]['dms'] = true
            }
            if (data['user-data'][msg.author.id]['dms'] === false) {
                data['user-data'][msg.author.id]['dms'] = true
                msg.channel.send('Unrelated DMs from `dm` will **be sent** to you now.', {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            } else {
                data['user-data'][msg.author.id]['dms'] = false
                msg.channel.send('Unrelated DMs from `dm` will **not be sent** to you now.', {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            }

        },
        help: {
            "name": "toggledms/tdms",
            "value": "Disables/enables Poopy's ability to send you DMs through the `dm` command."
        },
        cooldown: 2500,
        type: "Settings"
    },

    {
        name: ["customhook"],
        execute: async function (msg, args) {
            if (msg.member.hasPermission('MANAGE_WEBHOOKS') || msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                var user = args[1]
                if (args[1] === undefined || (args[1] ? (args[1].startsWith('"') || validUrl.test(args[1])) : false)) {
                    user = msg.author.id
                }
                var userMention = msg.mentions.members.first()

                if (!userMention) {
                    async function getUser(id) {
                        await msg.guild.members.fetch(id)
                            .then(async function (user) {
                                if (!data['guild-data'][msg.guild.id]) {
                                    data['guild-data'][msg.guild.id] = {}
                                }
                                if (!data['guild-data'][msg.guild.id]['members'][user.id]) {
                                    data['guild-data'][msg.guild.id]['members'][user.id] = {}
                                }
                                if (!data['guild-data'][msg.guild.id]['members'][user.id]['custom']) {
                                    data['guild-data'][msg.guild.id]['members'][user.id]['custom'] = false
                                }
                                if (data['guild-data'][msg.guild.id]['members'][user.id]['custom'] === false) {
                                    var saidMessage = args.join(' ').substring(args[0].length + 1)
                                    var symbolReplacedMessage
                                    symbolreplacements.forEach(symbolReplacement => {
                                        symbolReplacement.target.forEach(target => {
                                            symbolReplacedMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                                        })
                                    })
                                    var matchedTextes = symbolReplacedMessage.match(/"([\s\S]*?)"/)
                                    if (!matchedTextes) {
                                        msg.channel.send('Where\'s the name?!').catch(() => { })
                                        return
                                    }
                                    if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                                        msg.channel.send('Where\'s the avatar?!').catch(() => { })
                                        return
                                    }
                                    var name = matchedTextes[1]
                                    var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                                    var allBlank = true

                                    for (var i = 0; i < name.length; i++) {
                                        var letter = name[i]
                                        if (letter !== ' ') {
                                            allBlank = false
                                        }
                                    }

                                    if (allBlank) {
                                        msg.channel.send('Invalid name.').catch(() => { })
                                        return
                                    }
                                    var fetchAvatar = await fetch(currenturl).catch(() => { })
                                    if (!fetchAvatar) {
                                        msg.channel.send('Invalid avatar.').catch(() => { })
                                        return
                                    }
                                    var avatarFiletype = await fileType.fromStream(fetchAvatar.body).catch(() => { })
                                    if (!avatarFiletype) {
                                        msg.channel.send('Invalid avatar.').catch(() => { })
                                        return
                                    }
                                    if (!(avatarFiletype.mime.startsWith('image'))) {
                                        msg.channel.send('Invalid avatar.').catch(() => { })
                                        return
                                    }
                                    var avatar = currenturl

                                    data['guild-data'][msg.guild.id]['members'][user.id]['custom'] = {
                                        name: allBlank ? 'â €' : name,
                                        avatar: avatar
                                    }
                                    msg.channel.send(user.user.username + ` is now ${name}.`, {
                                        allowedMentions: {
                                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                } else {
                                    msg.channel.send(user.user.username + ` is not ${data['guild-data'][msg.guild.id]['members'][user.id]['custom']['name']}.`, {
                                        allowedMentions: {
                                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    data['guild-data'][msg.guild.id]['members'][user.id]['custom'] = false
                                }
                            })
                            .catch(function () {
                                msg.channel.send('Invalid user ID: **' + user + '**', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            })
                    }

                    getUser(user)
                } else {
                    if (!data['guild-data'][msg.guild.id]) {
                        data['guild-data'][msg.guild.id] = {}
                    }
                    if (!data['guild-data'][msg.guild.id]['members'][userMention.id]) {
                        data['guild-data'][msg.guild.id]['members'][userMention.id] = {}
                    }
                    if (!data['guild-data'][msg.guild.id]['members'][userMention.id]['custom']) {
                        data['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] = false
                    }
                    if (data['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] === false) {
                        var saidMessage = args.join(' ').substring(args[0].length + 1)
                        var symbolReplacedMessage
                        symbolreplacements.forEach(symbolReplacement => {
                            symbolReplacement.target.forEach(target => {
                                symbolReplacedMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                            })
                        })
                        var matchedTextes = symbolReplacedMessage.match(/"([\s\S]*?)"/)
                        if (!matchedTextes) {
                            msg.channel.send('Where\'s the name?!').catch(() => { })
                            return
                        }
                        if (!validUrl.test(args[args.length - 1])) {
                            msg.channel.send('Where\'s the avatar?!').catch(() => { })
                            return
                        }
                        var name = matchedTextes[1]
                        var fetchAvatar = await fetch(args[args.length - 1]).catch(() => { })
                        if (!fetchAvatar) {
                            msg.channel.send('Invalid avatar.').catch(() => { })
                            return
                        }
                        var avatarFiletype = await fileType.fromStream(fetchAvatar.body).catch(() => { })
                        if (!avatarFiletype) {
                            msg.channel.send('Invalid avatar.').catch(() => { })
                            return
                        }
                        if (!(avatarFiletype.mime.startsWith('image'))) {
                            msg.channel.send('Invalid avatar.').catch(() => { })
                            return
                        }
                        var avatar = args[args.length - 1]

                        data['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] = {
                            name: name,
                            avatar: avatar
                        }
                        msg.channel.send(userMention.user.username + ` is now ${name}.`, {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    } else {
                        msg.channel.send(userMention.user.username + ` is not ${data['guild-data'][msg.guild.id]['members'][user.id]['custom']['name']}.`, {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        data['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] = false
                    }
                }
            }
            else {
                msg.channel.send('You need to have the manage webhooks permission to execute that!').catch(() => { })
                return;
            };
        },
        help: {
            "name": "customhook [user] (manage webhooks permission only)",
            "value": "Turn someone into the webhook you specified."
        },
        cooldown: 2500,
        perms: ["ADMINISTRATOR", "MANAGE_WEBHOOKS"],
        type: "Fun"
    },

    {
        name: ["say", "talk", "speak"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[1] === undefined && attachments.length <= 0) {
                msg.channel.send('What is the message to say?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            msg.channel.send(saidMessage, {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                },
                files: attachments
            })
                .then(() => {
                    if (!msg.deleted) {
                        msg.delete().catch(() => { })
                    }
                })
                .catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "say/talk/speak <message>",
            "value": "Poopy says the message after the command."
        },
        type: "Fun"
    },

    {
        name: ["brainfuck", "bf"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the code to compile?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var sent = false
            var compiledTimeout = setTimeout(async () => {
                var compiled = await brainfuck(saidMessage)
                await msg.channel.send(compiled || 'â€‹', {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.stopTyping(true)
                sent = true
            }, 0)
            setTimeout(async () => {
                if (!sent) {
                    clearTimeout(compiledTimeout)
                    await msg.channel.send('Infinite loop detected.').catch(() => { })
                    msg.channel.stopTyping(true)
                }
            }, 5000)
        },
        help: {
            "name": "brainfuck/bf <code>",
            "value": "Compiles the Brainfuck code supplied."
        },
        type: "Fun"
    },

    {
        name: ["stroke", "gibberish"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the message?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            msg.channel.send(gibberish(saidMessage), {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "stroke/gibberish <message>",
            "value": "teral stroket  kknerhxtiarhxtlo k"
        },
        type: "Fun"
    },

    {
        name: ["tobrainfuck", "tobf"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the message to convert?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            msg.channel.send(tobrainfuck(saidMessage), {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(async () => {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)
                fs.writeFileSync(`temp/file${currentcount}/tobrainfuck.txt`, tobrainfuck(saidMessage))
                await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/tobrainfuck.txt`)).catch(() => { })
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
            })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "tobrainfuck/tobf <message>",
            "value": "Converts the message into Brainfuck."
        },
        type: "Fun"
    },

    {
        name: ["weirdcore", "text2img", "text2image", "t2i"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (validUrl.test(saidMessage)) {
                msg.channel.send('URLs in this command will break it.').catch(() => { })
                msg.channel.stopTyping(true)
                return
            }
            var resp = await deepai.callStandardApi("text2img", {
                text: saidMessage,
            }).catch(err => {
                msg.channel.send(err.message, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            })
            if (resp) {
                msg.channel.send(new Discord.MessageAttachment(resp.output_url)).catch(() => { })
            }
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "weirdcore/text2img/text2image/t2i <message>",
            "value": "Generates a picture depending on what the text is. It can look weird and eerie sometimes."
        },
        type: "Fun"
    },

    {
        name: ["burningtext", "firetext"],
        execute: async function (msg, args) {
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            function waitForAttributeValueNot(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result !== value;
                    });
                };
            }

            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)
            await waitForChromeSessionEnd(msg)
            chromeWindow = true
            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
            await driver.get('https://cooltext.com/Logo-Design-Burning').catch(() => { })
            var Text = await driver.findElement(By.id('Text')).catch(() => { })
            var PreviewImage = await driver.findElement(By.id('PreviewImage')).catch(() => { })
            var defaultImage = await PreviewImage.getAttribute('src').catch(() => { })
            await Text.clear().catch(() => { })
            await Text.sendKeys(saidMessage).catch(() => { })
            await driver.wait(waitForAttributeValueNot(PreviewImage, 'src', defaultImage), 600000).catch(() => { })
            var RenderButton = await driver.findElement(By.css('input[id="RenderButton"]')).catch(() => { })
            await RenderButton.click().catch(() => { })
            await driver.wait(until.titleIs('Generated Image')).catch(() => { })
            var Download = await driver.findElement(By.css('a[title="Download"]')).catch(() => { })
            await Download.click().catch(() => { })
            await sleep(10000)
            await driver.quit().catch(() => { })
            chromeWindow = false
            var files = fs.readdirSync(`temp/file${currentcount}`)
            var file = files.find(f => f.includes('cooltext'))
            try {
                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
            } catch (_) {
                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return
            }
            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
            if (!fileMsg) {
                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                if (fileLink) {
                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                    if (!fileLinkMsg) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                } else {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                }
            }
            msg.channel.stopTyping(true)
            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
        },
        help: {
            "name": "burningtext/firetext <text>",
            "value": "Generates a burning text. (powered by https://cooltext.com/)"
        },
        type: "Fun"
    },

    {
        name: ["uberduck", "tts"],
        execute: async function (msg, args) {
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined) {
                msg.channel.send('What is the voice?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (args[2] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var saidVoice = args[1]
            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2).replace(/\\n/g, ' ')
            if (saidMessage.length < 3) {
                msg.channel.send('Text must be longer than 3 digits.').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)
            await waitForChromeSessionEnd(msg)
            chromeWindow = true
            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
            await driver.get(`https://uberduck.ai/#voice=${saidVoice.toLowerCase()}`).catch(() => { })
            await sleep(500)
            await driver.manage().addCookie({ name: '__Secure-next-auth.session-token', value: process.env.UBERDUCKTOKEN }).catch(() => { })
            await driver.navigate().refresh().catch(() => { })
            await sleep(1000)
            var weirdal = await driver.findElement(By.xpath(`//*[text()='"Weird Al" Yankovic (by JacobLenstar)']`)).catch(() => { })
            if ((weirdal && saidVoice.toLowerCase() === 'weird-al') || (!weirdal && saidVoice.toLowerCase() !== 'weird-al')) {
                var textInput = await driver.findElement(By.id('synthesizeTextarea')).catch(() => { })
                var synthesize = await driver.findElement(By.xpath('//*[text()="Synthesize"]')).catch(() => { })
                await textInput.sendKeys(saidMessage).catch(() => { })
                await sleep(500)
                await synthesize.click().catch(() => { })
                await driver.wait(async function () {
                    return await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                }, 120000).catch(() => { })
                var download = await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                if (download) {
                    await download.click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`temp/file${currentcount}`)
                    var file = files.find(f => f.includes('audio'))
                    try {
                        fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.wav`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.stopTyping(true)
                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.wav`)).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.wav`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                } else {
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    msg.channel.send('Sorry, but your request failed.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return;
                }
            } else {
                await driver.quit().catch(() => { })
                chromeWindow = false
                msg.channel.send('Not a valid voice. Go to https://uberduck.ai/quack-help for a list of voices.').catch(() => { })
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return;
            }
        },
        help: {
            "name": "<:newpoopy:839191885310066729> uberduck/tts <voice> <text>",
            "value": "Generates TTS with Uberduck AI. A list of voices can be found at https://uberduck.ai/quack-help (powered by https://uberduck.ai/, but that was already made clear)"
        },
        type: "Fun"
    },

    /*{
        name: ["uberduckaudio", "uberduckmusic", "ttsaudio", "ttsmusic"],
        execute: async function (msg, args) {
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined) {
                msg.channel.send('What is the voice?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (args[2] === undefined) {
                msg.channel.send('What is the reference audio?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (args[3] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var saidVoice = args[1]
            var saidAudio = args[2]
            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2).replace(/\\n/g, ' ')
            if (saidMessage.length < 3) {
                msg.channel.send('Text must be longer than 3 digits.').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (validUrl.test(saidAudio)) {
                fetch(saidAudio)
                    .then(response => {
                        fileType.fromStream(response.body)
                            .then(async type => {
                                var body = await response.text()
                                if (body.length / 1048576 > 1) {
                                    msg.channel.send(`that file exceeds uberduck's size limit of 1 mb hahahaha`)
                                    msg.channel.stopTyping(true)
                                    return;
                                }
                                if (type.mime.startsWith('audio')) {
                                    var currentcount = filecount
                                    filecount = filecount + 1
                                    fs.mkdirSync(`temp/file${currentcount}`)

                                    var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                    require(saidAudio.startsWith('https') ? 'https' : 'http').get(saidAudio, (response) => {
                                        response.pipe(writeStream)
                                        writeStream.on('finish', async () => {
                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            bagd = driver
                                            await driver.get('https://uberduck.ai/').catch(() => { })
                                            await sleep(500)
                                            await driver.manage().addCookie({ name: '__Secure-next-auth.session-token', value: process.env.UBERDUCKTOKEN }).catch(() => { })
                                            await driver.navigate().refresh().catch(() => { })
                                            await sleep(1000)
                                            var audioMode = await driver.findElement(By.css('label[aria-label="Singing mode"]')).catch(() => { })
                                            await audioMode.click().catch(() => { })
                                            await sleep(500)
                                            var selectVoice = await driver.findElement(By.id('selectVoice')).catch(() => { })
                                            var showCustomAudio = await driver.findElement(By.xpath('//*[text()="Show"]')).catch(() => { })
                                            var textInput = await driver.findElement(By.id('synthesizeTextarea')).catch(() => { })
                                            var synthesize = await driver.findElement(By.xpath('//*[text()="Synthesize"]')).catch(() => { })
                                            await textInput.sendKeys(saidMessage).catch(() => { })
                                            await sleep(500)
                                            await selectVoice.click().catch(() => { })
                                            await sleep(2000)
                                            var voices = await driver.findElements(By.css('.select-voice__option')).catch(() => { })
                                            var voiceIndex
                                            for (var i in voices) {
                                                var voice = voices[i]
                                                var voiceName = await voice.getAttribute('innerText')
                                                if (voiceName.replace(/\(.*\)| |\[|\]/g, '').toLowerCase().includes(saidVoice.toLowerCase())) {
                                                    voiceIndex = i
                                                    break
                                                }
                                            }
                                            if (voiceIndex) {
                                                var voice = voices[voiceIndex]
                                                driver.executeScript(`var voices = document.querySelectorAll('.select-voice__option')\nvoices[${voiceIndex}].scrollIntoView()`)
                                                await sleep(500)
                                                await voice.click().catch(() => { })
                                                await sleep(500)
                                                await showCustomAudio.click().catch(() => { })
                                                await sleep(500)
                                                var uploadAudio = await driver.findElement(By.id('reference-file-upload')).catch(() => { })
                                                await uploadAudio.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                                await sleep(500)
                                                await synthesize.click().catch(() => { })
                                                await driver.wait(async function () {
                                                    return await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                                                }, 120000).catch(() => { })
                                                var download = await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                                                if (download) {
                                                    await download.click().catch(() => { })
                                                    await sleep(5000)
                                                    await driver.quit().catch(() => { })
                                                    chromeWindow = false
                                                    var files = fs.readdirSync(`temp/file${currentcount}`)
                                                    var file = files.find(f => f.includes('audio'))
                                                    try {
                                                        fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.wav`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.wav`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.wav`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                } else {
                                                    await driver.quit().catch(() => { })
                                                    chromeWindow = false
                                                    msg.channel.send('Sorry, but your request failed.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return;
                                                }
                                            } else {
                                                await driver.quit().catch(() => { })
                                                chromeWindow = false
                                                msg.channel.send('Not a valid voice.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return;
                                            }
                                        })
                                    })
                                } else {
                                    msg.channel.send(`Unsupported file: \`${saidAudio}\``, {
                                        allowedMentions: {
                                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.stopTyping(true)
                                    return
                                }
                            })
                            .catch(() => {
                                msg.channel.send(`Unsupported file: \`${saidAudio}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            })
                    })
                    .catch(err => {
                        msg.channel.send(err.message, {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                        return
                    })
            } else {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)
                await waitForChromeSessionEnd(msg)
                chromeWindow = true
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                bagd = driver
                await driver.get('https://uberduck.ai/').catch(() => { })
                await sleep(500)
                await driver.manage().addCookie({ name: '__Secure-next-auth.session-token', value: process.env.UBERDUCKTOKEN }).catch(() => { })
                await driver.navigate().refresh().catch(() => { })
                await sleep(1000)
                var audioMode = await driver.findElement(By.css('label[aria-label="Singing mode"]')).catch(() => { })
                await audioMode.click().catch(() => { })
                await sleep(500)
                var selectVoice = await driver.findElement(By.id('selectVoice')).catch(() => { })
                var selectAudio = await driver.findElement(By.id('selectReferenceAudio')).catch(() => { })
                var textInput = await driver.findElement(By.id('synthesizeTextarea')).catch(() => { })
                var synthesize = await driver.findElement(By.xpath('//*[text()="Synthesize"]')).catch(() => { })
                await selectVoice.click().catch(() => { })
                await sleep(2000)
                var voices = await driver.findElements(By.css('.select-voice__option')).catch(() => { })
                var voiceIndex
                for (var i in voices) {
                    var voice = voices[i]
                    var voiceName = await voice.getAttribute('innerText')
                    if (voiceName.replace(/\(.*\)| |\[|\]/g, '').toLowerCase().includes(saidVoice.toLowerCase())) {
                        voiceIndex = i
                        break
                    }
                }
                if (voiceIndex) {
                    var voice = voices[voiceIndex]
                    driver.executeScript(`var voices = document.querySelectorAll('.select-voice__option')\nvoices[${voiceIndex}].scrollIntoView()`)
                    await sleep(500)
                    await voice.click().catch(() => { })
                    await sleep(500)
                    await selectAudio.click().catch(() => { })
                    await sleep(2000)
                    var audios = await driver.findElements(By.css('.select-referenceaudio__option')).catch(() => { })
                    var audioIndex
                    for (var i in audios) {
                        var audio = audios[i]
                        var audioName = await audio.getAttribute('innerText')
                        if (audioName.replace(/\(.*\)| |\[|\]/g, '').toLowerCase().includes(saidAudio.toLowerCase())) {
                            audioIndex = i
                            break
                        }
                    }
                    if (audioIndex) {
                        await sleep(500)
                        await textInput.sendKeys(saidMessage).catch(() => { })
                        await sleep(500)
                        await synthesize.click().catch(() => { })
                        await driver.wait(async function () {
                            return await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                        }, 120000).catch(() => { })
                        var download = await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                        if (download) {
                            await download.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`temp/file${currentcount}`)
                            var file = files.find(f => f.includes('audio'))
                            try {
                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.wav`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.stopTyping(true)
                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.wav`)).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.wav`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.stopTyping(true)
                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                        } else {
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            msg.channel.send('Sorry, but your request failed.').catch(() => { })
                            msg.channel.stopTyping(true)
                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                            return;
                        }
                    } else {
                        await driver.quit().catch(() => { })
                        chromeWindow = false
                        msg.channel.send('Not a valid reference audio.').catch(() => { })
                        msg.channel.stopTyping(true)
                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                        return;
                    }
                } else {
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    msg.channel.send('Not a valid voice.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return;
                }
            }
        },
        help: {
            "name": "<:newpoopy:839191885310066729> uberduckaudio/uberduckmusic/ttsaudio/ttsmusic <voice> <referenceaudio (text or url)> <text>",
            "value": "Generates TTS with Uberduck AI using the reference audio. (powered by https://uberduck.ai/)"
        },
        type: "Fun"
    },*/

    {
        name: ["badtranslate"],
        execute: async function (msg, args) {
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            function waitForAttributeValueNot(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result !== value;
                    });
                };
            }

            function waitForAttributeValue(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result === value;
                    });
                };
            }

            async function clickLanguage(driver, l) {
                driver.executeScript('window.scrollTo(0, 0)')
                var error
                var language = l || languages[Math.floor(Math.random() * languages.length)]
                await language.click().catch(err => {
                    error = err
                })
                if (error) {
                    await clickLanguage(driver, l)
                }
            }

            msg.channel.startTyping().catch(() => { })
            var languagen = 5
            var languagesindex = args.indexOf('-languages')
            if (languagesindex > -1) {
                languagen = isNaN(Number(args[languagesindex + 1])) ? 5 : Number(args[languagesindex + 1]) <= 1 ? 1 : Number(args[languagesindex + 1]) >= 5 ? 5 : Math.round(Number(args[languagesindex + 1])) || 5
                args.splice(languagesindex, 2)
            }
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }

            await waitForChromeSessionEnd(msg)
            chromeWindow = true
            var driver = await new Builder().forBrowser('chrome').build().catch(() => { })
            await driver.get('https://translate.google.com/?hl=en-EN').catch(() => { })

            if (testing) {
                var agree = await driver.findElement(By.css('button[aria-label="Agree to the use of cookies and other data for the purposes described"]')).catch(() => { })
                await agree.click().catch(() => { })
            }

            var sourcetext = await driver.findElement(By.css('textarea[jsname="BJE2fc"]')).catch(() => { })
            var swapbutton = await driver.findElement(By.css('button[jsname="dnDxad"]')).catch(() => { })
            var languagebutton = await driver.findElement(By.css('button[jsname="zumM6d"]')).catch(() => { })
            var menus = await driver.findElement(By.css('c-wiz[class="bvzp8c"]')).catch(() => { })
            var languages = await driver.findElements(By.css('div[class="ykTHSe"] div[class="pEyuac X4hZJc"] div[class="dykxn MeCBDd j33Gae"] div[class="vSUSRc"] div[class="F29iQc"] div[jsname="sgblj"][class="qSb8Pe"]')).catch(() => { })

            await sourcetext.sendKeys(saidMessage).catch(() => { })
            driver.executeScript('window.scrollTo(0, 0)')

            for (var i = 0; i < languagen; i++) {
                await languagebutton.click().catch(() => { })
                await driver.wait(waitForAttributeValueNot(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
                await sleep(500)
                await clickLanguage(driver)
                await sleep(1000)
                driver.executeScript('window.scrollTo(0, 0)')
                await swapbutton.click().catch(() => { })
                await driver.wait(waitForAttributeValue(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
                await sleep(500)
                driver.executeScript('window.scrollTo(0, 0)')
            }

            await languagebutton.click().catch(() => { })
            await driver.wait(waitForAttributeValueNot(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
            await sleep(500)
            var english = await driver.findElement(By.css('div[class="ykTHSe"] div[class="pEyuac X4hZJc"] div[class="dykxn MeCBDd j33Gae"] div[class="vSUSRc"] div[class="F29iQc"] div[data-language-code="en"]')).catch(() => { })
            await clickLanguage(driver, english)
            await sleep(1000)
            driver.executeScript('window.scrollTo(0, 0)')
            await swapbutton.click().catch(() => { })
            await driver.wait(waitForAttributeValue(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
            await sleep(500)
            driver.executeScript('window.scrollTo(0, 0)')

            var translation = await sourcetext.getAttribute('value').catch(() => { })

            await msg.channel.send(translation.replace(/nigg[as?|ers?] ?/ig, '')).catch(() => { })

            await driver.quit().catch(() => { })
            chromeWindow = false
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "badtranslate <text> [-languages <number (max 5)>]",
            "value": "Passes the text through multiple languages until it becomes a complete mess. Default number of languages is 5."
        },
        type: "Fun"
    },

    {
        name: ["verbose"],
        execute: async function (msg, args) {
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            function waitForAttributeValueNot(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result !== value;
                    });
                };
            }

            function waitForAttributeValue(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result === value;
                    });
                };
            }

            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }

            await waitForChromeSessionEnd(msg)
            chromeWindow = true
            var driver = await new Builder().forBrowser('chrome').build().catch(() => { })
            await driver.get('https://lingojam.com/ExtremeVerboseTranslatorforExtremeHomosapiens').catch(() => { })

            var sourcetext = await driver.findElement(By.id('english-text')).catch(() => { })
            var targettext = await driver.findElement(By.id('ghetto-text')).catch(() => { })

            await sourcetext.clear().catch(() => { })
            await sourcetext.sendKeys(saidMessage).catch(() => { })

            await driver.wait(waitForAttributeValueNot(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })
            await driver.wait(waitForAttributeValue(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })

            await sleep(500)

            var translation = await targettext.getAttribute('value').catch(() => { })

            await msg.channel.send(translation).catch(() => { })

            await driver.quit().catch(() => { })
            chromeWindow = false

            msg.channel.stopTyping(true)
        },
        help: {
            "name": "verbose <text>",
            "value": "Adds verbose to the text making it more complex."
        },
        type: "Fun"
    },

    {
        name: ["opposite"],
        execute: async function (msg, args) {
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            function waitForAttributeValueNot(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result !== value;
                    });
                };
            }

            function waitForAttributeValue(element, attribute, value) {
                return function () {
                    return element.getAttribute(attribute).then(result => {
                        return result === value;
                    });
                };
            }

            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the text?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }

            await waitForChromeSessionEnd(msg)
            chromeWindow = true
            var driver = await new Builder().forBrowser('chrome').build().catch(() => { })
            await driver.get('https://lingojam.com/OppositeWordTranslator').catch(() => { })

            var sourcetext = await driver.findElement(By.id('english-text')).catch(() => { })
            var targettext = await driver.findElement(By.id('ghetto-text')).catch(() => { })

            await sourcetext.clear().catch(() => { })
            await sourcetext.sendKeys(saidMessage).catch(() => { })

            await driver.wait(waitForAttributeValueNot(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })
            await driver.wait(waitForAttributeValue(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })

            await sleep(500)

            var translation = await targettext.getAttribute('value').catch(() => { })

            await msg.channel.send(translation).catch(() => { })

            await driver.quit().catch(() => { })
            chromeWindow = false

            msg.channel.stopTyping(true)
        },
        help: {
            "name": "opposite <text>",
            "value": "Makes all words in the text the opposite."
        },
        type: "Fun"
    },

    {
        name: ["heartlocket"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var makesweeturl = 'https://makesweet.com/my/heart-locket'
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['" "', ' ']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                        var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })

                                        if (args.indexOf('-swap') > -1) {
                                            await textbtn.click().catch(() => { })
                                            await sleep(1000)
                                            var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                            var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                            await textbox.clear().catch(() => { })
                                            await textbox.sendKeys(text).catch(() => { })
                                            await textdonebtn.click().catch(() => { })
                                            await addbtn.click().catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        } else {
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                            await addbtn.click().catch(() => { })
                                            await textbtn.click().catch(() => { })
                                            await sleep(1000)
                                            var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                            var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                            await textbox.clear().catch(() => { })
                                            await textbox.sendKeys(text).catch(() => { })
                                            await textdonebtn.click().catch(() => { })
                                        }

                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                            var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })

                                            if (args.indexOf('-swap') > -1) {
                                                await textbtn.click().catch(() => { })
                                                await sleep(1000)
                                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                                await textbox.clear().catch(() => { })
                                                await textbox.sendKeys(text).catch(() => { })
                                                await textdonebtn.click().catch(() => { })
                                                await addbtn.click().catch(() => { })
                                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            } else {
                                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                                await addbtn.click().catch(() => { })
                                                await textbtn.click().catch(() => { })
                                                await sleep(1000)
                                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                                await textbox.clear().catch(() => { })
                                                await textbox.sendKeys(text).catch(() => { })
                                                await textdonebtn.click().catch(() => { })
                                            }

                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "heartlocket \"[text]\" <file> [-swap]",
            "value": "Creates a Makesweet heartlocket with the file. (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["goldheartlocket", "heartlocket2"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var makesweeturl = 'https://makesweet.com/my/gold-heart-locket'
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['" "', ' ']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                        var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })

                                        if (args.indexOf('-swap') > -1) {
                                            await textbtn.click().catch(() => { })
                                            await sleep(1000)
                                            var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                            var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                            await textbox.clear().catch(() => { })
                                            await textbox.sendKeys(text).catch(() => { })
                                            await textdonebtn.click().catch(() => { })
                                            await addbtn.click().catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        } else {
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                            await addbtn.click().catch(() => { })
                                            await textbtn.click().catch(() => { })
                                            await sleep(1000)
                                            var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                            var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                            await textbox.clear().catch(() => { })
                                            await textbox.sendKeys(text).catch(() => { })
                                            await textdonebtn.click().catch(() => { })
                                        }

                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                            var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })

                                            if (args.indexOf('-swap') > -1) {
                                                await textbtn.click().catch(() => { })
                                                await sleep(1000)
                                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                                await textbox.clear().catch(() => { })
                                                await textbox.sendKeys(text).catch(() => { })
                                                await textdonebtn.click().catch(() => { })
                                                await addbtn.click().catch(() => { })
                                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            } else {
                                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                                await addbtn.click().catch(() => { })
                                                await textbtn.click().catch(() => { })
                                                await sleep(1000)
                                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                                await textbox.clear().catch(() => { })
                                                await textbox.sendKeys(text).catch(() => { })
                                                await textdonebtn.click().catch(() => { })
                                            }

                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "goldheartlocket/heartlocket2 \"[text]\" <file> [-swap]",
            "value": "Creates a golden Makesweet heartlocket with the file. (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["gift", "heartgift"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var makesweeturl = 'https://makesweet.com/my/gift-box'
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['" "', ' ']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                        var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })

                                        if (args.indexOf('-swap') > -1) {
                                            await textbtn.click().catch(() => { })
                                            await sleep(1000)
                                            var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                            var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                            await textbox.clear().catch(() => { })
                                            await textbox.sendKeys(text).catch(() => { })
                                            await textdonebtn.click().catch(() => { })
                                            await addbtn.click().catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        } else {
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                            await addbtn.click().catch(() => { })
                                            await textbtn.click().catch(() => { })
                                            await sleep(1000)
                                            var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                            var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                            await textbox.clear().catch(() => { })
                                            await textbox.sendKeys(text).catch(() => { })
                                            await textdonebtn.click().catch(() => { })
                                        }

                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                            var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })

                                            if (args.indexOf('-swap') > -1) {
                                                await textbtn.click().catch(() => { })
                                                await sleep(1000)
                                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                                await textbox.clear().catch(() => { })
                                                await textbox.sendKeys(text).catch(() => { })
                                                await textdonebtn.click().catch(() => { })
                                                await addbtn.click().catch(() => { })
                                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            } else {
                                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                                await addbtn.click().catch(() => { })
                                                await textbtn.click().catch(() => { })
                                                await sleep(1000)
                                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                                await textbox.clear().catch(() => { })
                                                await textbox.sendKeys(text).catch(() => { })
                                                await textdonebtn.click().catch(() => { })
                                            }

                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "gift/heartgift \"[text]\" <file> [-swap]",
            "value": "im bri'ish (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["billboard", "sign"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var makesweeturl = 'https://makesweet.com/my/billboard-cityscape'
            var textincluded = true
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                textincluded = false
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            if (textincluded) {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }

                await waitForChromeSessionEnd(msg)
                chromeWindow = true
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                await driver.get(makesweeturl).catch(() => { })
                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                await textbtn.click().catch(() => { })
                await sleep(1000)
                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                await textbox.clear().catch(() => { })
                await textbox.sendKeys(text).catch(() => { })
                await textdonebtn.click().catch(() => { })
                await animatebtn.click().catch(() => { })
                await animategifbtn.click().catch(() => { })
                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                await savebtn.click().catch(() => { })
                await sleep(5000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`temp/file${currentcount}`)
                var file = files.find(f => f.includes('makesweet'))
                try {
                    fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return
            }

            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                        await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "billboard/sign <file> or \"<text>\"",
            "value": "Billboard for sale! (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["flyingflag"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var makesweeturl = 'https://makesweet.com/my/flag'
            var textincluded = true
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                textincluded = false
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            if (textincluded) {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }

                await waitForChromeSessionEnd(msg)
                chromeWindow = true
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                await driver.get(makesweeturl).catch(() => { })
                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                await textbtn.click().catch(() => { })
                await sleep(1000)
                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                await textbox.clear().catch(() => { })
                await textbox.sendKeys(text).catch(() => { })
                await textdonebtn.click().catch(() => { })
                await animatebtn.click().catch(() => { })
                await animategifbtn.click().catch(() => { })
                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                await savebtn.click().catch(() => { })
                await sleep(5000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`temp/file${currentcount}`)
                var file = files.find(f => f.includes('makesweet'))
                try {
                    fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return
            }

            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                        await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "flyingflag <file> or \"<text>\"",
            "value": "the flag of my home country (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["flyingflag2"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var makesweeturl = 'https://makesweet.com/my/blue-sky-flag'
            var textincluded = true
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                textincluded = false
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            if (textincluded) {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }

                await waitForChromeSessionEnd(msg)
                chromeWindow = true
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                await driver.get(makesweeturl).catch(() => { })
                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                await textbtn.click().catch(() => { })
                await sleep(1000)
                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                await textbox.clear().catch(() => { })
                await textbox.sendKeys(text).catch(() => { })
                await textdonebtn.click().catch(() => { })
                await animatebtn.click().catch(() => { })
                await animategifbtn.click().catch(() => { })
                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                await savebtn.click().catch(() => { })
                await sleep(5000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`temp/file${currentcount}`)
                var file = files.find(f => f.includes('makesweet'))
                try {
                    fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return
            }

            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                        await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "flyingflag2 <file> or \"<text>\"",
            "value": "the new flag of my home country (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["sun", "heartsun"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var makesweeturl = 'https://makesweet.com/my/valentine'
            var textincluded = true
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                textincluded = false
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            if (textincluded) {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }

                await waitForChromeSessionEnd(msg)
                chromeWindow = true
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                await driver.get(makesweeturl).catch(() => { })
                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                await textbtn.click().catch(() => { })
                await sleep(1000)
                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                await textbox.clear().catch(() => { })
                await textbox.sendKeys(text).catch(() => { })
                await textdonebtn.click().catch(() => { })
                await animatebtn.click().catch(() => { })
                await animategifbtn.click().catch(() => { })
                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                await savebtn.click().catch(() => { })
                await sleep(5000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`temp/file${currentcount}`)
                var file = files.find(f => f.includes('makesweet'))
                try {
                    fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return
            }

            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                        await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "sun/heartsun <file> or \"<text>\"",
            "value": "im underaged (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["fortunecookie", "fortune"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var makesweeturl = 'https://makesweet.com/my/fortune-cookie'
            var textincluded = true
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                textincluded = false
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            if (textincluded) {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }

                await waitForChromeSessionEnd(msg)
                chromeWindow = true
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                await driver.get(makesweeturl).catch(() => { })
                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                await textbtn.click().catch(() => { })
                await sleep(1000)
                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                await textbox.clear().catch(() => { })
                await textbox.sendKeys(text).catch(() => { })
                await textdonebtn.click().catch(() => { })
                await animatebtn.click().catch(() => { })
                await animategifbtn.click().catch(() => { })
                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                await savebtn.click().catch(() => { })
                await sleep(5000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`temp/file${currentcount}`)
                var file = files.find(f => f.includes('makesweet'))
                try {
                    fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.stopTyping(true)
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                return
            }

            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get(makesweeturl).catch(() => { })
                                        var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                        var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                        var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                        var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                        var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                        await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animatebtn.click().catch(() => { })
                                        await animategifbtn.click().catch(() => { })
                                        await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                        await savebtn.click().catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('makesweet'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, async () => {
                                            function sleep(ms) {
                                                return new Promise(resolve => setTimeout(resolve, ms));
                                            }

                                            function waitForAttributeValue(element, attribute, value) {
                                                return function () {
                                                    return element.getAttribute(attribute).then(result => {
                                                        return result === value;
                                                    });
                                                };
                                            }

                                            await waitForChromeSessionEnd(msg)
                                            chromeWindow = true
                                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                            await driver.get(makesweeturl).catch(() => { })
                                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/frame.png`).catch(() => { })
                                            await animatebtn.click().catch(() => { })
                                            await animategifbtn.click().catch(() => { })
                                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                            await savebtn.click().catch(() => { })
                                            await sleep(5000)
                                            await driver.quit().catch(() => { })
                                            chromeWindow = false
                                            var files = fs.readdirSync(`temp/file${currentcount}`)
                                            var file = files.find(f => f.includes('makesweet'))
                                            try {
                                                fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "fortunecookie/fortune <file> or \"<text>\"",
            "value": "Reveals your fortune...? (powered by https://makesweet.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["cube"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Horiz. Rotating Cube'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "cube <image/gif>",
            "value": "Creates a 3D rotating cube out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["diagonalcube"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Diag. Rotating Cube'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "diagonalcube <image/gif>",
            "value": "Creates a 3D diagonal rotating cube out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["pyramid"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Pyramid'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "pyramid <image/gif>",
            "value": "Creates a 3D rotating pyramid out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["sphere"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Rotating Sphere'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "sphere <image/gif>",
            "value": "Creates a 3D rotating sphere out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["donut"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Rotating Donut'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "donut <image/gif>",
            "value": "Creates a 3D rotating donut out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["planet", "solarsystem"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Sun and Planet'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "planet/solarsystem <image/gif>",
            "value": "Creates a 3D rotating solar system out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["3dspin"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = '360 Spin'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "3dspin <image/gif>",
            "value": "Creates a 3D spinning image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["3dflip"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Front Flip'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "3dflip <image/gif>",
            "value": "Creates a 3D front flipping image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["tiltedzoom", "tiltzoom"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Tilted Zoom'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "tiltedzoom/tiltzoom <image/gif>",
            "value": "a family friendly command (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["insidesphere"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Inside Sphere'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "insidesphere <image/gif>",
            "value": "Makes it look like as if you were inside the image/GIF. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["balloon"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Expanding Balloon'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('50').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "balloon <image/gif>",
            "value": "Makes the image/GIF expand in the shape of a sphere. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["spiralshrink", "spiralvanish", "undertale"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Spiral and Vanish'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('40').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "spiralshrink/spiralvanish/undertale <image/gif>",
            "value": "Shrinks the image/GIF while also rotating it. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["squishy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var animationname = 'Squishy'
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        function sleep(ms) {
                                            return new Promise(resolve => setTimeout(resolve, ms));
                                        }

                                        function waitForAttributeValue(element, attribute, value) {
                                            return function () {
                                                return element.getAttribute(attribute).then(result => {
                                                    return result === value;
                                                });
                                            };
                                        }

                                        await waitForChromeSessionEnd(msg)
                                        chromeWindow = true
                                        var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}` })).build().catch(() => { })
                                        await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                                        var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                                        var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                                        var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                                        var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                                        var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                                        var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                                        await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/temp/file${currentcount}/input.${type.ext}`).catch(() => { })
                                        await animationmenu.click().catch(() => { })
                                        var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                                        await animation.click().catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await fps.clear().catch(() => { })
                                        await fps.sendKeys('65').catch(() => { })
                                        await fpspencil.click().catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await frames.clear().catch(() => { })
                                        await frames.sendKeys('30').catch(() => { })
                                        await framespencil.click().catch(() => { })
                                        await transparentcheck.click().catch(() => { })
                                        await downloadgif.click().catch(() => { })
                                        var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                                        await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                                        await sleep(5000)
                                        await driver.quit().catch(() => { })
                                        chromeWindow = false
                                        var files = fs.readdirSync(`temp/file${currentcount}`)
                                        var file = files.find(f => f.includes('3dgifmaker'))
                                        try {
                                            fs.renameSync(`temp/file${currentcount}/${file}`, `temp/file${currentcount}/output.gif`)
                                        } catch (_) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            return
                                        }
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "squishy <image/gif>",
            "value": "Makes the image/GIF very squishy. (powered by https://www.3dgifmaker.com/)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["describeimage", "describe"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the image to describe?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image')) {
                                var resp = await deepai.callStandardApi("neuraltalk", {
                                    image: currenturl,
                                }).catch(err => {
                                    msg.channel.send(err.message, {
                                        allowedMentions: {
                                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                })
                                if (resp) {
                                    msg.channel.send(resp.output).catch(() => { })
                                }
                                msg.channel.stopTyping(true)
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "describeimage/describe <image>",
            "value": "Describes the content of the image."
        },
        type: "Fun"
    },

    {
        name: ["generatetext", "predicttext"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            if (args[1] === undefined) {
                msg.channel.send('What is the text to generate?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (validUrl.test(saidMessage)) {
                msg.channel.send('URLs in this command will break it.').catch(() => { })
                msg.channel.stopTyping(true)
                return
            }
            var resp = await deepai.callStandardApi("text-generator", {
                text: saidMessage,
            }).catch(err => {
                msg.channel.send(err.message, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            })
            if (resp) {
                msg.channel.send(resp.output, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            }
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "generatetext/predicttext <message>",
            "value": "Tries to predict subsequent text from the specified message."
        },
        type: "Fun"
    },

    {
        name: ["spam", "flood"],
        execute: async function (msg, args) {
            if (msg.member.hasPermission('MANAGE_MESSAGES') || msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) {
                if (args[1] === undefined && args[2] === undefined) {
                    msg.channel.send('How much do I spam?!').catch(() => { })
                    return;
                }
                msg.channel.startTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                var numToRepeat = Number(args[1]);
                if (isNaN(numToRepeat)) {
                    msg.channel.send('Invalid number: **' + args[1] + '**', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return;
                }
                else if (numToRepeat > 25) {
                    msg.channel.send('Number must be smaller or equal to **25**.').catch(() => { })
                    msg.channel.stopTyping(true)
                    return;
                }
                if (args[2] === undefined && attachments.length <= 0) {
                    msg.channel.send('What is the message to spam?!').catch(() => { })
                    msg.channel.stopTyping(true)
                    return;
                };
                for (var i = 0; i < numToRepeat; i++) {
                    msg.channel.send(saidMessage, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: attachments
                    })
                        .then(() => {
                            if (!msg.deleted) {
                                msg.delete().catch(() => { })
                            }
                        })
                        .catch(() => { })
                };
                msg.channel.stopTyping(true)
            }
            else {
                msg.channel.send('You need to have the manage messages permission to execute that!').catch(() => { })
                return;
            };
        },
        help: {
            "name": "spam/flood <times> <message> (manage messages permission only)",
            "value": "Spam a message! Limit is 25.\nExample usage: p:spam 5 stupid"
        },
        cooldown: 10000,
        perms: ["MANAGE_MESSAGES", "ADMINISTRATOR"],
        type: "Fun"
    },

    {
        name: ["eval", "execute"],
        execute: async function (msg, args) {
            var ownerid = (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id));
            if (ownerid === undefined) {
                msg.channel.send('Owner only!').catch(() => { })
                return
            }
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            try {
                var evalMessage = eval(saidMessage)
                msg.channel.send(typeof (evalMessage) === 'string' && evalMessage || util.inspect(evalMessage), { split: true }).catch(() => {
                    msg.channel.send('â€‹').catch(() => { })
                    return
                })
            } catch (error) {
                msg.channel.send(error.message, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                return
            }
        },
        help: {
            "name": "eval/execute {code}",
            "value": "Evaluation command. (pretty much execute the code you want)"
        },
        type: "Owner"
    },

    {
        name: ["dm"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined) {
                msg.channel.send('Who do I DM?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[2] === undefined && attachments.length <= 0) {
                msg.channel.send('What is the message to DM?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            if (!msg.mentions.members.size) {
                var ids = args[1].split(',');
                ids.forEach(async id => {
                    var member = await bot.users.fetch(id)
                        .catch(function () {
                            msg.channel.send('Invalid user id: **' + id + '**', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        });

                    if (member) {
                        if (!data['user-data'][member.id]) {
                            data['user-data'][member.id] = {}
                        }
                        if (data['user-data'][member.id]['dms'] === undefined) {
                            data['user-data'][member.id]['dms'] = true
                        }
                        if (data['user-data'][member.id]['dms'] === false) {
                            msg.channel.send('I don\'t have the permission to send unrelated DMs to this user.').catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        }
                        member.send(saidMessage, attachments)
                            .then(function () {
                                msg.react('âœ…').catch(() => { })
                                msg.channel.stopTyping(true)
                            })
                            .catch(function () {
                                msg.channel.send('Couldn\'t send a message to this user. Make sure they share any of the servers I\'m in, or not have me blocked.').catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            })
                    }
                })
            }
            else {
                msg.mentions.members.forEach(member => {
                    if (!data['user-data'][member.id]) {
                        data['user-data'][member.id] = {}
                    }
                    if (data['user-data'][member.id]['dms'] === undefined) {
                        data['user-data'][member.id]['dms'] = true
                    }
                    if (data['user-data'][member.id]['dms'] === false) {
                        msg.channel.send('I don\'t have the permission to send unrelated DMs to this user.').catch(() => { })
                        msg.channel.stopTyping(true)
                        return
                    }
                    member.send(saidMessage, attachments)
                        .then(function () {
                            msg.react('âœ…').catch(() => { })
                            msg.channel.stopTyping(true)
                        }
                        )
                        .catch(function () {
                            msg.channel.send('Couldn\'t send a message to this user. Make sure they share any of the servers I\'m in, or not have me blocked.').catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
            }
        },
        help: {
            "name": "dm <users> <message>",
            "value": "Allows Poopy to DM multiple users the message inside the command. (each user should be separated with \",\")"
        },
        type: "Fun"
    },

    {
        name: ["react"],
        execute: async function (msg, args) {
            if (args[1] === undefined) {
                msg.channel.send('Where are the arguments?!').catch(() => { })
                return;
            }
            msg.channel.startTyping().catch(() => { })
            var saidEmojis = args[1];
            var saidMessage = args[2];

            if (saidMessage === undefined) {
                saidMessage = msg.id
            }

            if (saidEmojis) {
                var saidEmojisArray = saidEmojis.split(',');
                saidEmojisArray.forEach(
                    saidEmoji => {
                        async function getMessage(id) {
                            var messageToReact = await msg.channel.messages.fetch(id)
                                .catch(function () {
                                    {
                                        msg.channel.send('Invalid message id: **' + id + '**', {
                                            allowedMentions: {
                                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                        msg.channel.stopTyping(true)
                                        return
                                    }
                                })

                            if (messageToReact) {
                                messageToReact.react(saidEmoji)
                                    .then(function () {
                                        msg.channel.stopTyping(true)
                                    })
                                    .catch(function () {
                                        msg.channel.send('Invalid emoji: **' + saidEmoji + '**', {
                                            allowedMentions: {
                                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                        msg.channel.stopTyping(true)
                                        return;
                                    })
                            }
                        }

                        getMessage(saidMessage)
                    }
                )
            };
        },
        help: {
            "name": "react <emojis> {messageid}",
            "value": "React to a message inside the channel with an emoji. (each emoji should be separated with \",\")"
        },
        type: "Fun"
    },

    {
        name: ["avatar", "av", "pfp"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined) {
                var avatar = new Discord.MessageAttachment(msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }));
                msg.channel.send(msg.author.username + '\'s avatar is:', {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    },
                    files: [avatar]
                }).catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            if (!msg.mentions.members.size) {
                async function getMember(id) {
                    var member = await bot.users.fetch(id)
                        .catch(function () {
                            msg.channel.send('Invalid user id: **' + id + '**', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })

                    if (member) {
                        var avatar = new Discord.MessageAttachment(member.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }));
                        msg.channel.send(member.username + '\'s avatar is:', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            },
                            files: [avatar]
                        }).catch(() => { })
                    }
                }

                getMember(args[1]);
            }
            else {
                var mention = msg.mentions.members.first();
                var avatar = new Discord.MessageAttachment(mention.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }));
                msg.channel.send(mention.user.username + '\'s avatar is:', {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    },
                    files: [avatar]
                }).catch(() => { })
            }
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "avatar/av/pfp [user]",
            "value": "Replies with the user's avatar."
        },
        cooldown: 2500,
        type: "Utility"
    },

    {
        name: ["poop"],
        execute: async function (msg) {
            const poopPhrases = [
                'I farted loudly.',
                'I pooped again.',
                'Poopy',
                'Funny farts',
                'Poooooop',
                '<:poopy:621064531908755467>',
                'My poop is powerful.',
                'I pooped on your carpet.',
                'arabotto please come home',
                '<:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467>',
                'Ungh *farts*',
                'I have passed gas.',
                'Poopy Poopy Stinky Ew',
                '<@454732245425455105>',
                'You live in a VAN!',
                'gondal',
                'ðŸ˜‚',
                'ðŸŽ…ðŸ¿',
                'L is real',
                'Do you fart?',
                'I have over ' + Math.floor(Math.random() * 300) + ' confirmed farts.',
                '<@' + msg.author.id + '>' + ' shut up',
                'Optimus prime',
                'ðŸ‘ðŸ‘„ðŸ‘',
                'ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®',
                'Lol XD funny large fart POOP big burger two watermelon fish',
                'Quesley is a mysterious figure, yes.',
                'Regal is quite stingy.',
                'One bighead is much stronger than the others...',
                'peed',
                'What the hell do you want?',
                'ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜†ðŸ˜…ðŸ˜‚ðŸ¤£â˜ºï¸ðŸ˜ŠðŸ˜‡ðŸ™‚ðŸ™ƒðŸ˜‰ðŸ˜ŒðŸ˜ðŸ¥°ðŸ˜˜ðŸ˜—ðŸ˜™ðŸ˜šðŸ˜‹ðŸ˜›ðŸ˜ðŸ˜œðŸ¤ªðŸ¤¨ðŸ§ðŸ¤“ðŸ˜ŽðŸ¤©ðŸ¥³ðŸ˜ðŸ˜’ðŸ˜žðŸ˜”ðŸ˜ŸðŸ˜•ðŸ™â˜¹ï¸ðŸ˜£ðŸ˜–ðŸ˜«ðŸ˜©ðŸ¥ºðŸ˜¢ðŸ˜­ðŸ˜¤ðŸ˜ ðŸ˜¡ðŸ¤¬ðŸ¤¯ðŸ˜³ðŸ¥µðŸ¥¶ðŸ˜±ðŸ˜¨ðŸ˜°ðŸ˜¥ðŸ˜“ðŸ¤—ðŸ¤”ðŸ¤­ðŸ¤«ðŸ¤¥ðŸ˜¶ðŸ˜ðŸ˜‘ðŸ˜¬ðŸ™„ðŸ˜¯ðŸ˜¦ðŸ˜§ðŸ˜®ðŸ˜²ðŸ¥±ðŸ˜´ðŸ¤¤ðŸ˜ªðŸ˜µðŸ¤ðŸ¥´ðŸ¤¢ðŸ¤®ðŸ¤§ðŸ˜·ðŸ¤’ðŸ¤•ðŸ¤‘ðŸ¤ ðŸ˜ˆðŸ‘¿ðŸ‘¹ðŸ‘ºðŸ¤¡ðŸ’©ðŸ‘»ðŸ’€â˜ ï¸ðŸ‘½ðŸ‘¾ðŸ¤–ðŸŽƒðŸ˜ºðŸ˜¸ðŸ˜¹ðŸ˜»ðŸ˜¼ðŸ˜½ðŸ™€ðŸ˜¿ðŸ˜¾ðŸ¤²ðŸ‘ðŸ™ŒðŸ‘ðŸ¤ðŸ‘ðŸ‘ŽðŸ‘ŠâœŠðŸ¤›ðŸ¤œðŸ¤žâœŒï¸ðŸ¤ŸðŸ¤˜ðŸ‘ŒðŸ¤ðŸ‘ˆðŸ‘‰ðŸ‘†ðŸ‘‡â˜ï¸âœ‹ðŸ¤šðŸ–ðŸ––ðŸ‘‹ðŸ¤™',
                'The ocean is hiding something.',
                'I don\'t think itâ€™s possible that anyone could poop more than me.',
                'c',
                '<@' + msg.author.id + '>' + ' please go away',
                'You will die of spicy diarrhea in ' + Math.floor((Math.random() * 58) + 1) + ' seconds.',
                'The lad race is widespread on many planets.',
                'Dude Iâ€™m buying groceries.',
                'Dude Iâ€™m taking a bath.',
                'Doge is watching us intently...',
                'Lore? Hmm, keep using this command and I might give you some.',
                'Soup Arena? Never heard of it.',
                'I will poop on you if you donâ€™t fucking stop.',
                'I will crap in your mouth!',
                'OMG NO WAY HE',
                'Superbrohouse',
                'I canâ€™t',
                'YOU CANT STOP THEM.',
                'If the Essence wins...',
                'Itâ€™s raining men!',
                'I might actually not be made of poop.',
                'I used to be yellow, just like my bretheren.',
                'Are you expecting something?',
                'My favorite food is sugar cookies.',
                'Planet travel is much easier thanks to me...',
                'Amateur Sailor will be a great sailor one day!',
                'omgbroyoucrazywhyyouusethiscommandsomuchidiotstinkyperson',
                'Quoth the raven, "nevermore".',
                'Nah fam',
                'Uniting the legendary items will finally complete the prophecy...',
                'Iâ€™ll never forget the day...',
                'Deinx if youâ€™re reading this youâ€™re fat hahahahaha',
                'The prototype I am building has endless capabilities.',
                'The others donâ€™t appreciate me, but they should.',
                'Youâ€™ll never find my secret base!',
                'Iâ€™ve been keeping a close eye on you for a while now.',
                'You are dumb.',
                'We captured the spy!',
                'Pood',
                'Paad',
                'Piid',
                'Puud',
                'You will never reach the truth.',
                'Yo.',
                'fack you',
                'Me when',
                'Ballfish is actually at-',
                'No',
                'Yes',
                'Wired were the eyes of a horse on a jet pilot, one that smiled when they flew over the bay!',
                'Chop Suey!',
                'What is wrong with you?',
                'I may not look it, but my intelligence is far beyond.',
                'is soup remastered ever getting a thumbnail',
                'Response',
                'Plain Text',
                'is krima?',
                'theres 104 days of summer vacation',
                'I farted quietly.',
                'Ha! Sand in the eye! Youâ€™ll never get my lore!',
                'Words can not describe how much I absolutely despise stew.',
                'My home planet is so far...',
                'Will my brethren ever accept me again?',
                'Skibidi bop mm dada',
                ':hole <@613501149282172970>',
                'Entity 1 will not stop until he has gained all the power.',
                'The entities have massacred 24 planets so far, and you\'re next.',
                'Soup rains will come soon, but they will be a bit different.',
                'Regal will have karma someday...',
                'Stew aliens are building a weapon to melt planet Soup\'s surface. You must stop them.',
                '**UPDATE 999** - Add shit - Add shat - Add shot - Add shut - Add shet',
                'WTFNOOOO!',
                'Leave right now.',
                'THE LE-D-R',
                'CO-Râ€”TI-N',
                'I want legs for Christmas.',
                'The crystals grow ever more aggravated...',
                'Nobody will miss 2020.',
                'Gork rights!',
                'My prototype is enormous, and it\'s equipped with all kinds of powerful weapons!'
            ]

            msg.channel.startTyping().catch(() => { })
            msg.channel.send(poopPhrases[Math.floor(Math.random() * poopPhrases.length)], {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "poop",
            "value": "Poopy says a random funny."
        },
        type: "Fun"
    },

    {
        name: ["stats", "botstats"],
        execute: async function (msg) {
            var totalSeconds = (bot.uptime / 1000);
            var days = Math.floor(totalSeconds / 86400);
            totalSeconds %= 86400;
            var hours = Math.floor(totalSeconds / 3600);
            totalSeconds %= 3600;
            var minutes = Math.floor(totalSeconds / 60);
            var seconds = Math.floor(totalSeconds % 60);
            var mused = process.memoryUsage().heapUsed / 1024 / 1024
            var cusage = process.cpuUsage()
            var cused = (cusage.user + cusage.system) / 1024 / 1024
            var cpu = os.cpus()[0].model
            var servers = bot.guilds.cache.size
            var channels = bot.channels.cache.size
            var emojis = bot.emojis.cache.size
            var files = fs.readdirSync('temp').length
            var types = ['dm', 'text', 'news']

            var statsEmbed = {
                title: 'Poopy\'s Stats',
                color: 0x472604,
                footer: {
                    icon_url: bot.user.avatarURL(),
                    text: `Poopy`
                },
                fields: [
                    {
                        name: "Servers",
                        value: servers,
                        inline: true
                    },
                    {
                        name: "Channels",
                        value: channels,
                        inline: true
                    },
                    {
                        name: "Messages",
                        value: data['bot-data']['bot']['messages'],
                        inline: true
                    },
                    {
                        name: "Emojis",
                        value: emojis,
                        inline: true
                    },
                    {
                        name: "Users",
                        value: Object.keys(data['user-data']).length,
                        inline: true
                    },
                    {
                        name: "Uptime",
                        value: `${days}d ${hours}h ${minutes}m ${seconds}s`,
                        inline: true
                    },
                    {
                        name: "Commands",
                        value: commands.length,
                        inline: true
                    },
                    {
                        name: "Processed Commands",
                        value: data['bot-data']['bot']['commands'],
                        inline: true
                    },
                    {
                        name: "Commands per Second",
                        value: cps,
                        inline: true
                    },
                    {
                        name: "File Count",
                        value: filecount,
                        inline: true
                    },
                    {
                        name: "Processing Files",
                        value: files,
                        inline: true
                    },
                    {
                        name: "CPU",
                        value: cpu,
                        inline: true
                    },
                    {
                        name: "Memory Usage",
                        value: `${Math.round(mused * 100) / 100} MB`,
                        inline: true
                    },
                    {
                        name: "CPU Usage",
                        value: `${Math.round(cused * 100) / 100} MB`,
                        inline: true
                    },
                ]
            }

            msg.channel.send({
                embed: statsEmbed,
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(() => { })
        },
        help: {
            "name": "stats/botstats",
            "value": "Shows Poopy's stats."
        },
        cooldown: 2500,
        type: "Info"
    },

    {
        name: ["specialkeys", "keywords", "modifiers"],
        execute: async function (msg, args) {
            var keynumber = 1
            var modnumber = 1
            var infoEmbed = {
                "title": 'Special Keywords/Modifiers',
                "color": 0x472604,
                "footer": {
                    icon_url: bot.user.avatarURL(),
                    text: `Poopy`
                },
                "fields": [
                    {
                        "name": "WHAT are keywords and modifiers?",
                        "value": "Keywords and modifiers are special words that can be used in any command which are replaced with something new (keywords), or modify the way the text inside their parentheses looks like (modifiers), depending on their purpose.",
                    },
                    {
                        "name": "Example Usages",
                        "value": "```\np:say _member really likes _member\n```\n```\np:img _word\n```\n```\np:meme4 \"lower(FOOL)\"\n```\n```\np:meme4 \"upper(_arab)!\"\n```\n```\np:spam 25 _sayori\n```\n```\np:say choice(da minion | da bob)\n```",
                    },
                ]
            }
            var keyEmbed = {
                "title": `Special Keywords`,
                "description": "Here's a list of all keywords that can be used.",
                "color": 0x472604,
                "footer": {
                    "icon_url": bot.user.avatarURL(),
                    "text": `Page ${keynumber}/${keyfields.length}`
                },
                "fields": keyfields[keynumber - 1]
            };
            var modEmbed = {
                "title": `Special Modifiers`,
                "description": "Here's a list of all modifiers that can be used.",
                "color": 0x472604,
                "footer": {
                    "icon_url": bot.user.avatarURL(),
                    "text": `Page ${modnumber}/${funcfields.length}`
                },
                "fields": funcfields[modnumber - 1]
            };
            var keyreactions = [
                {
                    reaction: "861253229723123762",
                    function: () => {
                        return 1
                    },
                },
                {
                    reaction: "861253229726793728",
                    function: (number) => {
                        return number - 1
                    },
                },
                {
                    reaction: "861253230070988860",
                    function: () => {
                        return Math.floor(Math.random() * keyfields.length) + 1
                    },
                },
                {
                    reaction: "861253229798621205",
                    function: (number) => {
                        return number + 1
                    },
                },
                {
                    reaction: "861253229740556308",
                    function: () => {
                        return keyfields.length
                    },
                },
            ]

            var funcreactions = [
                {
                    reaction: "861253229723123762",
                    function: () => {
                        return 1
                    },
                },
                {
                    reaction: "861253229726793728",
                    function: (number) => {
                        return number - 1
                    },
                },
                {
                    reaction: "861253230070988860",
                    function: () => {
                        return Math.floor(Math.random() * funcfields.length) + 1
                    },
                },
                {
                    reaction: "861253229798621205",
                    function: (number) => {
                        return number + 1
                    },
                },
                {
                    reaction: "861253229740556308",
                    function: () => {
                        return funcfields.length
                    },
                },
            ]

            var keybuttonRow = new disbut.MessageActionRow()
            keyreactions.forEach(reaction => {
                var button = new disbut.MessageButton()
                    .setStyle('blurple')
                    .setEmoji(reaction.reaction)
                    .setID(reaction.reaction)
                keybuttonRow.addComponent(button)
            })

            var funcbuttonRow = new disbut.MessageActionRow()
            funcreactions.forEach(reaction => {
                var button = new disbut.MessageButton()
                    .setStyle('blurple')
                    .setEmoji(reaction.reaction)
                    .setID(reaction.reaction)
                funcbuttonRow.addComponent(button)
            })

            await msg.author.send({
                embed: infoEmbed
            }).catch(() => {
                msg.channel.send('Couldn\'t send info to you. Do you have me blocked?')
                return
            })

            await msg.author.send({
                embed: keyEmbed,
                components: keybuttonRow
            }).then(async sentMessage => {
                var helpMessage = sentMessage
                var filter = (button) => {
                    if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                        button.defer()
                        return
                    }
                    if (keyreactions.find(findreaction => findreaction.reaction === button.id).function(keynumber) > keyfields.length || keyreactions.find(findreaction => findreaction.reaction === button.id).function(keynumber) < 1) {
                        button.defer()
                        return
                    }
                    keynumber = keyreactions.find(findreaction => findreaction.reaction === button.id).function(keynumber)
                    keyEmbed = {
                        "title": `Keywords`,
                        "description": "Here's a list of all keywords that can be used.",
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Page ${keynumber}/${keyfields.length}`
                        },
                        "fields": keyfields[keynumber - 1]
                    };
                    helpMessage.edit({
                        embed: keyEmbed,
                        components: keybuttonRow
                    }).catch(() => { })
                    button.defer()
                }
                helpMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                    if (!helpMessage) return
                    helpMessage.edit({
                        embed: keyEmbed
                    }).catch(() => { })
                })
            })
                .catch(() => {
                    msg.channel.send('Couldn\'t send keywords to you. Do you have me blocked?')
                    return
                })

            await msg.author.send({
                embed: modEmbed,
                components: funcbuttonRow
            }).then(async sentMessage => {
                var helpMessage = sentMessage
                var filter = (button) => {
                    if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                        button.defer()
                        return
                    }
                    if (funcreactions.find(findreaction => findreaction.reaction === button.id).function(modnumber) > funcfields.length || funcreactions.find(findreaction => findreaction.reaction === button.id).function(modnumber) < 1) {
                        button.defer()
                        return
                    }
                    modnumber = funcreactions.find(findreaction => findreaction.reaction === button.id).function(modnumber)
                    modEmbed = {
                        "title": `Modifiers`,
                        "description": "Here's a list of all modifiers that can be used.",
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Page ${modnumber}/${funcfields.length}`
                        },
                        "fields": funcfields[modnumber - 1]
                    };
                    helpMessage.edit({
                        embed: modEmbed,
                        components: funcbuttonRow
                    }).catch(() => { })
                    button.defer()
                }
                helpMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                    if (!helpMessage) return
                    helpMessage.edit({
                        embed: modEmbed
                    }).catch(() => { })
                })
            })
                .catch(() => {
                    msg.channel.send('Couldn\'t send modifiers to you. Do you have me blocked?')
                    return
                })

            msg.channel.send(':white_check_mark: Check your DMs.').catch(() => { })
        },
        help: {
            "name": "specialkeys/keywords/modifiers",
            "value": "DMs you a list of special keywords that can be used for all commands."
        },
        cooldown: 2500,
        type: "Info"
    },

    {
        name: ["battlestats", "userstats"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined) {
                if (!data['user-data'][msg.author.id]) {
                    data['user-data'][msg.author.id] = {}
                }
                if (!data['user-data'][msg.author.id]['health']) {
                    data['user-data'][msg.author.id]['health'] = 100
                }
                var statsEmbed = {
                    title: msg.author.username + '\'s Stats',
                    color: 0x472604,
                    footer: {
                        icon_url: bot.user.avatarURL(),
                        text: `Poopy`
                    },
                    fields: [
                        {
                            name: "Health",
                            value: data['user-data'][msg.author.id]['health'] + ' HP'
                        }
                    ]
                }
                msg.channel.send({
                    embed: statsEmbed,
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (!msg.mentions.members.size) {
                async function getMember(id) {
                    var member = await bot.users.fetch(id)
                        .catch(function () {
                            {
                                msg.channel.send('Invalid user id: **' + id + '**', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })

                    if (member) {
                        if (!data['user-data'][member.id]) {
                            data['user-data'][member.id] = {}
                        }
                        if (!data['user-data'][member.id]['health']) {
                            data['user-data'][member.id]['health'] = 100
                        }
                        var statsEmbed = {
                            title: member.username + '\'s Stats',
                            color: 0x472604,
                            footer: {
                                icon_url: bot.user.avatarURL(),
                                text: `Poopy`
                            },
                            fields: [
                                {
                                    name: "Health",
                                    value: data['user-data'][member.id]['health'] + ' HP'
                                }
                            ]
                        }
                        msg.channel.send({
                            embed: statsEmbed,
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                    }
                }

                getMember(args[1]);
            }
            else {
                var mention = msg.mentions.members.first();
                if (!data['user-data'][mention.id]) {
                    data['user-data'][mention.id] = {}
                }
                if (!data['user-data'][mention.id]['health']) {
                    data['user-data'][mention.id]['health'] = 100
                }
                var statsEmbed = {
                    title: mention.user.username + '\'s Stats',
                    color: 0x472604,
                    footer: {
                        icon_url: bot.user.avatarURL(),
                        text: `Poopy`
                    },
                    fields: [
                        {
                            name: "Health",
                            value: data['user-data'][mention.id]['health'] + ' HP'
                        }
                    ]
                }
                msg.channel.send({
                    embed: statsEmbed,
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.stopTyping(true)
            }
        },
        help: {
            "name": "battlestats/userstats {user}",
            "value": "Shows the user's battle stats."
        },
        cooldown: 2500,
        type: "Battling"
    },

    {
        name: ["restricted"],
        execute: async function (msg) {
            if (msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                data['guild-data'][msg.guild.id]['restricted'] = !data['guild-data'][msg.guild.id]['restricted']
                msg.channel.send('Set to **' + data['guild-data'][msg.guild.id]['restricted'] + '**.').catch(() => { })
            }
            else {
                msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                return;
            };
        },
        help: {
            "name": "restricted (admin only)",
            "value": "Restrict Poopy's use to admins. Useful if you don't want anyone to mess with me."
        },
        cooldown: 5000,
        perms: ["ADMINISTRATOR"],
        type: "Settings"
    },

    {
        name: ["tcommands", "toggledcommands", "togglecommands"],
        execute: async function (msg, args) {
            var options = {
                list: async (msg) => {
                    var list = []

                    data['guild-data'][msg.guild.id]['disabled'].forEach(cmd => {
                        list.push(`- \`${cmd.join('/')}\``)
                    })

                    if (!list.length) {
                        list = ['None.']
                    }

                    var listEmbed = {
                        title: `List of disabled commands for ${msg.guild.name}`,
                        description: list.join('\n'),
                        color: 0x472604,
                        footer: {
                            icon_url: bot.user.avatarURL(),
                            text: `Poopy`
                        }
                    }

                    msg.channel.send({
                        embed: listEmbed,
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                },

                toggle: async (msg, args) => {
                    if (msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                        if (!args[2]) {
                            msg.channel.send('You gotta specify a command!')
                            return
                        }

                        var findCommand = commands.find(cmd => cmd.name.find(n => n === args[2].toLowerCase()))

                        if (findCommand) {
                            var findDCommand = data['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === args[2].toLowerCase()))

                            if (findDCommand) {
                                var index = data['guild-data'][msg.guild.id]['disabled'].findIndex(cmd => {
                                    return cmd.find(n => {
                                        return n === args[2].toLowerCase()
                                    })
                                })

                                data['guild-data'][msg.guild.id]['disabled'].splice(index, 1)

                                msg.channel.send(`Enabled \`${findCommand.name.join('/')}\`.`)
                            } else {
                                if (findCommand.name.find(n => n === args[0].toLowerCase())) {
                                    msg.channel.send(`You can't disable the disabling command!`)
                                    return
                                }

                                data['guild-data'][msg.guild.id]['disabled'].push(findCommand.name)

                                msg.channel.send(`Disabled \`${findCommand.name.join('/')}\`.`)
                            }
                        } else {
                            msg.channel.send('Not a valid command.')
                            return
                        }
                    } else {
                        msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                        return;
                    };
                },
            }

            if (!args[1]) {
                msg.channel.send({
                    embed: {
                        "title": "Available Options",
                        "description": "**list** - Gets a list of disabled commands.\n**toggle** <command> (admin only) - Disables/enables a command, if it exists.",
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Poopy`
                        },
                    }
                }).catch(() => { })
                return
            }

            if (!options[args[1].toLowerCase()]) {
                msg.channel.send('Not a valid option.')
                return
            }

            await options[args[1].toLowerCase()](msg, args)
        },
        help: {
            "name": "tcommands/toggledcommands/togglecommands <option>",
            "value": "**list** - Gets a list of disabled commands.\n**toggle** <command> (admin only) - Disables/enables a command, if it exists."
        },
        cooldown: 5000,
        type: "Settings"
    },

    {
        name: ["localcommands", "localcmds", "servercommands", "servercmds"],
        execute: async function (msg, args) {
            var options = {
                list: async (msg) => {
                    var number = 1
                    var localCmdsArray = []
                    for (var i in data['guild-data'][msg.guild.id]['localcmds']) {
                        var cmd = data['guild-data'][msg.guild.id]['localcmds'][i]
                        localCmdsArray.push(`- ${cmd.name}`)
                    }
                    var localCmds = localCmdsArray.length ? chunkArray(localCmdsArray, 10) : [['None.']]
                    var cmdEmbed = {
                        "title": `List of local commands for ${msg.guild.name}`,
                        "description": localCmds[number - 1].join('\n'),
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Page ${number}/${localCmds.length}`
                        },
                    };
                    var reactions = [
                        {
                            reaction: "861253229723123762",
                            function: () => {
                                return 1
                            },
                        },
                        {
                            reaction: "861253229726793728",
                            function: (number) => {
                                return number - 1
                            },
                        },
                        {
                            reaction: "861253230070988860",
                            function: () => {
                                return Math.floor(Math.random() * localCmds.length) + 1
                            },
                        },
                        {
                            reaction: "861253229798621205",
                            function: (number) => {
                                return number + 1
                            },
                        },
                        {
                            reaction: "861253229740556308",
                            function: () => {
                                return localCmds.length
                            },
                        },
                    ]
                    var buttonRow = new disbut.MessageActionRow()
                    reactions.forEach(reaction => {
                        var button = new disbut.MessageButton()
                            .setStyle('blurple')
                            .setEmoji(reaction.reaction)
                            .setID(reaction.reaction)
                        buttonRow.addComponent(button)
                    })

                    await msg.channel.send({
                        embed: cmdEmbed,
                        components: buttonRow
                    }).then(async sentMessage => {
                        var helpMessage = sentMessage
                        var filter = (button) => {
                            if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                            if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                                button.defer()
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.id).function(number) > localCmds.length || reactions.find(findreaction => findreaction.reaction === button.id).function(number) < 1) {
                                button.defer()
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.id).function(number)
                            cmdEmbed = {
                                "title": `List of local commands for ${msg.guild.name}`,
                                "description": localCmds[number - 1].join('\n'),
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.avatarURL(),
                                    "text": `Page ${number}/${localCmds.length}`
                                },
                            };
                            helpMessage.edit({
                                embed: cmdEmbed,
                                components: buttonRow
                            }).catch(() => { })
                            button.defer()
                        }
                        for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                            if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                            }
                        }
                        var p = helpMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                    break
                                }
                            }
                            if (!helpMessage) return
                            helpMessage.edit({
                                embed: cmdEmbed
                            }).catch(() => { })
                        })
                        data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                    })
                        .catch(() => { })
                },

                add: async (msg, args) => {
                    if (msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify a command name!')
                            return
                        }
                        if (!args[2]) {
                            msg.channel.send('You gotta specify a command phrase!')
                            return
                        }

                        var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                        var findCommand = commands.find(cmd => cmd.name.find(n => n === args[1].toLowerCase())) || data['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === args[1].toLowerCase())

                        if (findCommand) {
                            msg.channel.send(`That name is already taken!`)
                            return
                        } else {
                            data['guild-data'][msg.guild.id]['localcmds'].push({
                                name: args[1].toLowerCase(),
                                phrase: saidMessage
                            })

                            msg.channel.send(`Added \`${args[1].toLowerCase()}\` command with phrase ${saidMessage}`)
                        }
                    } else {
                        msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                        return;
                    };
                },

                edit: async (msg, args) => {
                    if (msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify a command name!')
                            return
                        }
                        if (!args[2]) {
                            msg.channel.send('You gotta specify a command phrase!')
                            return
                        }

                        var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                        var findCommand = data['guild-data'][msg.guild.id]['localcmds'].findIndex(cmd => cmd.name === args[1].toLowerCase())

                        if (findCommand > -1) {
                            data['guild-data'][msg.guild.id]['localcmds'][findCommand] = {
                                name: args[1].toLowerCase(),
                                phrase: saidMessage
                            }

                            msg.channel.send(`Edited \`${args[1].toLowerCase()}\` command with phrase ${saidMessage}`)
                        } else {
                            msg.channel.send(`Not a valid command.`)
                            return
                        }
                    } else {
                        msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                        return;
                    };
                },

                delete: async (msg, args) => {
                    if (msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify a command name!')
                            return
                        }

                        var findCommand = data['guild-data'][msg.guild.id]['localcmds'].findIndex(cmd => cmd.name === args[1].toLowerCase())

                        if (findCommand > -1) {
                            data['guild-data'][msg.guild.id]['localcmds'].splice(findCommand, 1)

                            msg.channel.send(`Removed \`${args[1].toLowerCase()}\` command.`)
                        } else {
                            msg.channel.send(`Not a valid command.`)
                            return
                        }
                    } else {
                        msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                        return;
                    };
                },
            }

            if (!args[1]) {
                msg.channel.send({
                    embed: {
                        "title": "Available Options",
                        "description": "**list** - Gets a list of local commands.\n**add** <commandname> <phrase> (admin only) - Adds a new local command, if the name is available for use.\n**edit** <commandname> <phrase> (admin only) - Edits the local command, if it exists.\n**delete** <commandname> (admin only) - Deletes the local command, if it exists.",
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Poopy`
                        },
                    }
                }).catch(() => { })
                return
            }

            if (!options[args[1].toLowerCase()]) {
                msg.channel.send('Not a valid option.')
                return
            }

            await options[args[1].toLowerCase()](msg, args.slice(1))
        },
        help: {
            "name": "localcommands/localcmds <option>",
            "value": "Note: Keywords can be used.\n\n**list** - Gets a list of local commands.\n**add** <commandname> <phrase> (admin only) - Adds a new local command, if the name is available for use.\n**edit** <commandname> <phrase> (admin only) - Edits the local command, if it exists.\n**delete** <commandname> (admin only) - Deletes the local command, if it exists."
        },
        cooldown: 5000,
        type: "Fun"
    },

    {
        name: ["setprefix"],
        execute: async function (msg, args) {
            if (msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id))) {
                if (args[1] === undefined) {
                    msg.channel.send('You must specify a prefix!').catch(() => { })
                    return
                }
                for (var i in args) {
                    var arg = args[i]
                    if (arg == '') {
                        args.splice(i, 1)
                    }
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1).split(/[\s]+/).join(' ')
                if (saidMessage.length > 20) {
                    msg.channel.send('The prefix can\'t be bigger than 20 characters.').catch(() => { })
                    return
                }
                data['guild-data'][msg.guild.id]['prefix'] = saidMessage
                msg.channel.send('The prefix was set to `' + (testing ? `2${data['guild-data'][msg.guild.id]['prefix']}` : data['guild-data'][msg.guild.id]['prefix']) + '` (if this is wrong, mention me with "reset prefix")').catch(() => { })
            } else {
                msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                return;
            };
        },
        help: {
            "name": "setprefix <prefix> (admin only)",
            "value": "Set Poopy's prefix to anything you want.\nPro Tip: mentioning Poopy with \"reset prefix\" will reset it to his default prefix."
        },
        cooldown: 5000,
        perms: ["ADMINISTRATOR"],
        type: "Settings"
    },

    {
        name: ["heyapple"],
        execute: async function (msg) {
            msg.channel.startTyping().catch(() => { })
            var attachment = new Discord.MessageAttachment('templates/heyapple.mp4')
            msg.channel.send(attachment).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "heyapple",
            "value": "Try and hit me if youâ€™re able."
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["canigetadmin"],
        execute: async function (msg) {
            msg.channel.startTyping().catch(() => { })
            var attachment = new Discord.MessageAttachment('templates/no.mp4')
            msg.channel.send(attachment).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "canigetadmin",
            "value": "Yo can I get admin? ðŸ˜‚"
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["baldi"],
        execute: async function (msg) {
            msg.channel.startTyping().catch(() => { })
            var attachment = new Discord.MessageAttachment('templates/baldi.mp4')
            msg.channel.send(attachment).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "baldi",
            "value": "YO MAMA!"
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["punch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[1] === undefined && attachments.length <= 0) {
                msg.channel.send('What/who is the subject?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            if ((Math.floor(Math.random() * 2)) === 0) {
                if (!msg.mentions.members.size) {
                    async function getMember(id) {
                        var member = await bot.users.fetch(id)
                            .catch(function () {
                                msg.channel.send('<@' + msg.author.id + '> punched **' + (saidMessage || 'this') + '**! It did **10** damage!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                            })

                        if (member) {
                            saidMessage = member.username
                            msg.channel.send('<@' + msg.author.id + '> punched **' + (saidMessage || 'this') + '**! It did **10** damage!', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                },
                                files: attachments
                            }).catch(() => { })
                            if (!data['user-data'][member.id]) {
                                data['user-data'][member.id] = {}
                                data['user-data'][member.id]['health'] = 100
                            }
                            data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - 10
                            if (data['user-data'][member.id]['health'] <= 0) {
                                data['user-data'][member.id]['health'] = 100
                                msg.channel.send('**' + member.username + '** died!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                            msg.channel.stopTyping(true)
                        }
                    }

                    getMember(saidMessage);
                }
                else {
                    var member = msg.mentions.members.first()
                    saidMessage = member.user.username
                    msg.channel.send('<@' + msg.author.id + '> punched **' + (saidMessage || 'this') + '**! It did **10** damage!', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: attachments
                    }).catch(() => { })
                    if (!data['user-data'][member.id]) {
                        data['user-data'][member.id] = {}
                        data['user-data'][member.id]['health'] = 100
                    }
                    data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - 10
                    if (data['user-data'][member.id]['health'] <= 0) {
                        data['user-data'][member.id]['health'] = 100
                        msg.channel.send('**' + member.user.username + '** died!', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                        return
                    }
                    msg.channel.stopTyping(true)
                }
            }
            else {
                msg.channel.send('You missed!').catch(() => { })
                msg.channel.stopTyping(true)
            }
        },
        help: {
            "name": "punch <subject>",
            "value": "Punch something!"
        },
        type: "Battling"
    },

    {
        name: ["slap"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[1] === undefined && attachments.length <= 0) {
                msg.channel.send('What/who is the subject?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            if ((Math.floor(Math.random() * 3)) > 0) {
                if (!msg.mentions.members.size) {
                    async function getMember(id) {
                        var member = await bot.users.fetch(id)
                            .catch(function () {
                                msg.channel.send('<@' + msg.author.id + '> slapped **' + (saidMessage || 'this') + '**! It did **5** damage!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                            })

                        if (member) {
                            saidMessage = member.username
                            msg.channel.send('<@' + msg.author.id + '> slapped **' + (saidMessage || 'this') + '**! It did **5** damage!', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                },
                                files: attachments
                            }).catch(() => { })
                            if (!data['user-data'][member.id]) {
                                data['user-data'][member.id] = {}
                                data['user-data'][member.id]['health'] = 100
                            }
                            data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - 10
                            if (data['user-data'][member.id]['health'] <= 0) {
                                data['user-data'][member.id]['health'] = 100
                                msg.channel.send('**' + member.username + '** died!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                            msg.channel.stopTyping(true)
                        }
                    }

                    getMember(saidMessage);
                }
                else {
                    var member = msg.mentions.members.first()
                    saidMessage = member.user.username
                    msg.channel.send('<@' + msg.author.id + '> slapped **' + (saidMessage || 'this') + '**! It did **5** damage!', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: attachments
                    }).catch(() => { })
                    if (!data['user-data'][member.id]) {
                        data['user-data'][member.id] = {}
                        data['user-data'][member.id]['health'] = 100
                    }
                    data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - 10
                    if (data['user-data'][member.id]['health'] <= 0) {
                        data['user-data'][member.id]['health'] = 100
                        msg.channel.send('**' + member.user.username + '** died!', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                        return
                    }
                    msg.channel.stopTyping(true)
                }
            }
            else {
                msg.channel.send('You missed!').catch(() => { })
                msg.channel.stopTyping(true)
            }
        },
        help: {
            "name": "slap <subject>",
            "value": "Slap something! Has a small chance of missing."
        },
        type: "Battling"
    },

    {
        name: ["slam"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[1] === undefined && attachments.length <= 0) {
                msg.channel.send('What/who is the subject?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            if ((Math.floor(Math.random() * 4)) === 0) {
                if (!msg.mentions.members.size) {
                    async function getMember(id) {
                        var member = await bot.users.fetch(id)
                            .catch(function () {
                                msg.channel.send('<@' + msg.author.id + '> slammed **' + (saidMessage || 'this') + '**! It did **30** damage!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                            })

                        if (member) {
                            saidMessage = member.username
                            msg.channel.send('<@' + msg.author.id + '> slammed **' + (saidMessage || 'this') + '**! It did **30** damage!', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                },
                                files: attachments
                            }).catch(() => { })
                            if (!data['user-data'][member.id]) {
                                data['user-data'][member.id] = {}
                                data['user-data'][member.id]['health'] = 100
                            }
                            data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - 30
                            if (data['user-data'][member.id]['health'] <= 0) {
                                data['user-data'][member.id]['health'] = 100
                                msg.channel.send('**' + member.username + '** died!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                            msg.channel.stopTyping(true)
                        }
                    }

                    getMember(saidMessage);
                }
                else {
                    var member = msg.mentions.members.first()
                    saidMessage = member.user.username
                    msg.channel.send('<@' + msg.author.id + '> slammed **' + (saidMessage || 'this') + '**! It did **30** damage!', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: attachments
                    }).catch(() => { })
                    if (!data['user-data'][member.id]) {
                        data['user-data'][member.id] = {}
                        data['user-data'][member.id]['health'] = 100
                    }
                    data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - 30
                    if (data['user-data'][member.id]['health'] <= 0) {
                        data['user-data'][member.id]['health'] = 100
                        msg.channel.send('**' + member.user.username + '** died!', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                        return
                    }
                }
            }
            else {
                msg.channel.send('You missed!').catch(() => { })
                msg.channel.stopTyping(true)
            }
        },
        help: {
            "name": "slam <subject>",
            "value": "Slam something! Has a high chance of missing."
        },
        type: "Battling"
    },

    {
        name: ["poopallover"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[1] === undefined && attachments.length <= 0) {
                msg.channel.send('What/who is the subject?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            msg.channel.send('**' + (saidMessage || 'this') + '** has been successfully pooped on.', {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                },
                files: attachments
            }).catch(() => { })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "poopallover <subject>",
            "value": "Poop on something."
        },
        type: "Fun"
    },

    {
        name: ["chainpunch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            if (args[1] === undefined && attachments.length <= 0) {
                msg.channel.send('What/who is the subject?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            if ((Math.floor(Math.random() * 2)) === 0) {
                var damage = Math.floor(Math.random() * 18) + 6;
                if (!msg.mentions.members.size) {
                    async function getMember(id) {
                        var member = await bot.users.fetch(id)
                            .catch(function () {
                                msg.channel.send('<@' + msg.author.id + '> chain punched **' + (saidMessage || 'this') + '**! It did **' + damage + '** damage!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                            })

                        if (member) {
                            saidMessage = member.username
                            msg.channel.send('<@' + msg.author.id + '> chain punched **' + (saidMessage || 'this') + '**! It did **' + damage + '** damage!', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                },
                                files: attachments
                            }).catch(() => { })
                            if (!data['user-data'][member.id]) {
                                data['user-data'][member.id] = {}
                                data['user-data'][member.id]['health'] = 100
                            }
                            data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - damage
                            if (data['user-data'][member.id]['health'] <= 0) {
                                data['user-data'][member.id]['health'] = 100
                                msg.channel.send('**' + member.username + '** died!', {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                            msg.channel.stopTyping(true)
                        }
                    }

                    getMember(saidMessage);
                }
                else {
                    var member = msg.mentions.members.first()
                    saidMessage = member.user.username
                    msg.channel.send('<@' + msg.author.id + '> chain punched **' + (saidMessage || 'this') + '**! It did **' + damage + '** damage!', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: attachments
                    }).catch(() => { })
                    if (!data['user-data'][member.id]) {
                        data['user-data'][member.id] = {}
                        data['user-data'][member.id]['health'] = 100
                    }
                    data['user-data'][member.id]['health'] = data['user-data'][member.id]['health'] - damage
                    if (data['user-data'][member.id]['health'] <= 0) {
                        data['user-data'][member.id]['health'] = 100
                        msg.channel.send('**' + member.user.username + '** died!', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                        return
                    }
                }
            }
            else {
                msg.channel.send('You missed!').catch(() => { })
                msg.channel.stopTyping(true)
            }
        },
        help: {
            "name": "chainpunch <subject>",
            "value": "Chain punch something! Does random damage, and has a pretty high chance to miss."
        },
        type: "Battling"
    },

    {
        name: ["ratemyfarts"],
        execute: async function (msg) {
            msg.channel.startTyping().catch(() => { })
            msg.channel.send('Let\'s see...').catch(() => { })
            var fartRating = Math.floor(Math.random() * 100) + 1
            if (!data['user-data'][msg.author.id]) {
                data['user-data'][msg.author.id] = {}
            }
            if (!data['user-data'][msg.author.id]['fartRate']) {
                data['user-data'][msg.author.id]['fartRate'] = fartRating;
            }
            if (!data['user-data'][msg.author.id]['lastFartRate']) {
                data['user-data'][msg.author.id]['lastFartRate'] = Date.now();
            }
            var lastFartRating = Date.now() - data['user-data'][msg.author.id]['lastFartRate']
            if (lastFartRating >= 600000) {
                data['user-data'][msg.author.id]['fartRate'] = fartRating;
                data['user-data'][msg.author.id]['lastFartRate'] = Date.now();
            }
            if (data['user-data'][msg.author.id]['fartRate'] >= 70) {
                msg.channel.send('**' + data['user-data'][msg.author.id]['fartRate'] + '**/100, great farts!').catch(() => { })
            }
            else {
                msg.channel.send('**' + data['user-data'][msg.author.id]['fartRate'] + '**/100').catch(() => { })
            }
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "ratemyfarts",
            "value": "Poopy rates your farts."
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["help", "commands", "cmds"],
        execute: async function (msg, args) {
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var number = 1
            if (saidMessage) {
                var findCmds = [];

                commands.forEach(cmd => {
                    if (cmd.name.find(name => name.toLowerCase().includes(saidMessage.toLowerCase()))) {
                        findCmds.push({
                            title: cmd.help.name,
                            fields: [
                                {
                                    "name": "Description",
                                    "value": cmd.help.value
                                },
                                {
                                    "name": "Cooldown",
                                    "value": cmd.cooldown ? `${cmd.cooldown / 1000} seconds` : 'None'
                                },
                                {
                                    "name": "Type",
                                    "value": cmd.type
                                },
                            ]
                        })

                    }
                })

                if (findCmds.length) {
                    var cmdEmbed = {
                        "title": findCmds[number - 1].title,
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Command ${number}/${findCmds.length}`
                        },
                        "fields": findCmds[number - 1].fields,
                    }
                    var reactions = [
                        {
                            reaction: "861253229723123762",
                            function: () => {
                                return 1
                            },
                        },
                        {
                            reaction: "861253229726793728",
                            function: (number) => {
                                return number - 1
                            },
                        },
                        {
                            reaction: "861253230070988860",
                            function: () => {
                                return Math.floor(Math.random() * findCmds.length) + 1
                            },
                        },
                        {
                            reaction: "861253229798621205",
                            function: (number) => {
                                return number + 1
                            },
                        },
                        {
                            reaction: "861253229740556308",
                            function: () => {
                                return findCmds.length
                            },
                        },
                    ]
                    var buttonRow = new disbut.MessageActionRow()
                    reactions.forEach(reaction => {
                        var button = new disbut.MessageButton()
                            .setStyle('blurple')
                            .setEmoji(reaction.reaction)
                            .setID(reaction.reaction)
                        buttonRow.addComponent(button)
                    })

                    msg.channel.send({
                        embed: cmdEmbed,
                        components: buttonRow
                    }).then(async sentMessage => {
                        var helpMessage = sentMessage
                        var filter = (button) => {
                            if (data2[msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                            if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                                button.defer()
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.id).function(number) > findCmds.length || reactions.find(findreaction => findreaction.reaction === button.id).function(number) < 1) {
                                button.defer()
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.id).function(number)
                            cmdEmbed = {
                                "title": findCmds[number - 1].title,
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.avatarURL(),
                                    "text": `Command ${number}/${findCmds.length}`
                                },
                                "fields": findCmds[number - 1].fields,
                            };
                            helpMessage.edit({
                                embed: cmdEmbed,
                                components: buttonRow
                            }).catch(() => { })
                            button.defer()
                        }
                        for (var i in data2[msg.author.id]['promises']) {
                            if (data2[msg.author.id]['promises'][i]) {
                                data2[msg.author.id]['promises'][i]['active'] = false
                            }
                        }
                        var p = helpMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                            for (var i in data2[msg.author.id]['promises']) {
                                if (data2[msg.author.id]['promises'][i] == p) {
                                    data2[msg.author.id]['promises'][i] = undefined
                                    break
                                }
                            }
                            if (!helpMessage) return
                            helpMessage.edit({
                                embed: cmdEmbed
                            }).catch(() => { })
                        })
                        data2[msg.author.id]['promises'].push({ promise: p, active: true })
                    })
                        .catch(() => { })
                } else {
                    msg.channel.send({
                        embed: {
                            "description": "No commands match your search.",
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.avatarURL(),
                                "text": `Poopy`
                            },
                        }
                    }).catch(() => { })
                }
                return
            }
            var ownerid = ownerids.find(id => id == msg.author.id);
            var cmdEmbed = {
                "title": `${shelpCmds[number - 1].type} Commands`,
                "description": "Arguments between \"<>\" are required.\nArguments between \"[]\" are optional.\nArguments between \"{}\" are optional but should normally be supplied.\nMultiple commands can be executed separating them with \"-|-\".",
                "color": 0x472604,
                "footer": {
                    "icon_url": bot.user.avatarURL(),
                    "text": `Page ${number}/${shelpCmds.length}`
                },
                "fields": shelpCmds[number - 1].commands
            };
            var reactions = [
                {
                    reaction: "861253229723123762",
                    function: () => {
                        return 1
                    },
                },
                {
                    reaction: "861253229726793728",
                    function: (number) => {
                        return number - 1
                    },
                },
                {
                    reaction: "861253230070988860",
                    function: () => {
                        return Math.floor(Math.random() * shelpCmds.length) + 1
                    },
                },
                {
                    reaction: "861253229798621205",
                    function: (number) => {
                        return number + 1
                    },
                },
                {
                    reaction: "861253229740556308",
                    function: () => {
                        return shelpCmds.length
                    },
                },
            ]
            var buttonRow = new disbut.MessageActionRow()
            reactions.forEach(reaction => {
                var button = new disbut.MessageButton()
                    .setStyle('blurple')
                    .setEmoji(reaction.reaction)
                    .setID(reaction.reaction)
                buttonRow.addComponent(button)
            })

            await msg.author.send({
                embed: cmdEmbed,
                components: buttonRow
            }).then(async sentMessage => {
                var helpMessage = sentMessage
                if (ownerid !== undefined) {
                    var devcmdEmbed = {
                        "title": "Owner Commands",
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Poopy`
                        },
                        "fields": devCmds
                    };
                    await msg.author.send({ embed: devcmdEmbed }).catch(() => { })
                }
                msg.channel.send(':white_check_mark: Check your DMs.').catch(() => { })
                var filter = (button) => {
                    if (data2[msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                    if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                        button.defer()
                        return
                    }
                    if (reactions.find(findreaction => findreaction.reaction === button.id).function(number) > shelpCmds.length || reactions.find(findreaction => findreaction.reaction === button.id).function(number) < 1) {
                        button.defer()
                        return
                    }
                    number = reactions.find(findreaction => findreaction.reaction === button.id).function(number)
                    cmdEmbed = {
                        "title": `${shelpCmds[number - 1].type} Commands`,
                        "description": "Arguments between \"<>\" are required.\nArguments between \"[]\" are optional.\nArguments between \"{}\" are optional but should normally be supplied.\nMultiple commands can be executed separating them with \"-|-\".",
                        "color": 0x472604,
                        "footer": {
                            "icon_url": bot.user.avatarURL(),
                            "text": `Page ${number}/${shelpCmds.length}`
                        },
                        "fields": shelpCmds[number - 1].commands
                    };
                    helpMessage.edit({
                        embed: cmdEmbed,
                        components: buttonRow
                    }).catch(() => { })
                    button.defer()
                }
                for (var i in data2[msg.author.id]['promises']) {
                    if (data2[msg.author.id]['promises'][i]) {
                        data2[msg.author.id]['promises'][i]['active'] = false
                    }
                }
                var p = helpMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                    for (var i in data2[msg.author.id]['promises']) {
                        if (data2[msg.author.id]['promises'][i] == p) {
                            data2[msg.author.id]['promises'][i] = undefined
                            break
                        }
                    }
                    if (!helpMessage) return
                    helpMessage.edit({
                        embed: cmdEmbed
                    }).catch(() => { })
                })
                data2[msg.author.id]['promises'].push({ promise: p, active: true })
            })
                .catch(() => {
                    msg.channel.send('Couldn\'t send help to you. Do you have me blocked?')
                    return
                })
        },
        help: {
            "name": "help/commands/cmds [command]",
            "value": "HELP! You can specify [command] if you want help on a certain command."
        },
        cooldown: 2500,
        type: "Info"
    },

    {
        name: ["tango", "deleteembed", "dembed"],
        execute: async function (msg, args) {
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var rulesChannel = msg.guild.channels.cache.find(channel => channel.name.includes('rule'))
            var tangoEmbed = {
                "author": {
                    "name": msg.author.tag,
                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                },
                "description": `**Message sent by <@${msg.author.id}> deleted in <#${rulesChannel && rulesChannel.id || msg.channel.id}>**\n${saidMessage}`,
                "color": 0xFF470F,
                "timestamp": Date.now(),
                "footer": {
                    "text": `Author: ${msg.author.id} | Message ID: ${msg.id}`
                },
            };
            msg.channel.send({
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                },
                embed: tangoEmbed
            }).catch(() => { })
        },
        help: {
            "name": "tango/deleteembed/dembed {message}",
            "value": "tango"
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["img", "image"],
        execute: async function (msg, args) {
            async function image(msg, parts, page) {
                if (page) {
                    parts.splice(parts.length - 2)
                }
                var search = parts.slice(1).join(" ");

                gis(search, async function (error, results) {
                    if (error) {
                        msg.channel.send('Error.').catch(() => { })
                        msg.channel.stopTyping(true)
                        return;
                    }

                    var urls = [];

                    for (var i in results) {
                        var result = results[i]
                        var url = result.url.replace(/\\u([a-z0-9]){4}/g, (match) => {
                            return String.fromCharCode(Number('0x' + match.substring(2, match.length)))
                        })

                        urls.push(url)
                    }

                    if (!urls.length) {
                        msg.channel.send('Not found.').catch(() => { })
                        msg.channel.stopTyping(true)
                        return;
                    }

                    var number = 1
                    if (page) {
                        number = Number(page)
                        if (isNaN(number)) {
                            msg.channel.send('**' + page + '** is not a number.', {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return;
                        };
                        if (number > urls.length) number = urls.length;
                        if (number < 1) number = 1
                        var imgEmbed = {
                            "title": "Image Search Results For " + search,
                            "description": "Use the arrows to navigate.",
                            "color": 0x472604,
                            "footer": {
                                "text": "Image " + number + "/" + urls.length
                            },
                            "image": {
                                "url": urls[number - 1]
                            },
                            "author": {
                                "name": msg.author.tag,
                                "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                            }
                        };
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * urls.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return urls.length
                                },
                            },
                        ]
                        var buttonRow = new disbut.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new disbut.MessageButton()
                                .setStyle('blurple')
                                .setEmoji(reaction.reaction)
                                .setID(reaction.reaction)
                            buttonRow.addComponent(button)
                        })
                        var buttonRow2 = new disbut.MessageActionRow()
                        var benson = new disbut.MessageButton()
                            .setStyle('red')
                            .setEmoji('874406183933444156')
                            .setID('delete')
                        buttonRow2.addComponent(benson)

                        var imgMessage = await msg.channel.send({
                            embed: imgEmbed,
                            components: [buttonRow, buttonRow2]
                        }).catch(() => { })
                        if (!imgMessage) {
                            msg.channel.stopTyping(true)
                            return
                        }
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                        var lastUrls = [urls[number - 1]].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                        lastUrls.splice(100)
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        msg.channel.stopTyping(true)
                        var filter = (button) => {
                            if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                            if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                                button.defer()
                                return
                            }
                            if (button.id === 'delete') {
                                button.defer()
                                imgMessage.delete().catch(() => { })
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.id).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.id).function(number) < 1) {
                                button.defer()
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.id).function(number)
                            imgEmbed = {
                                "title": "Image Search Results For " + search,
                                "description": "Use the arrows to navigate.",
                                "color": 0x472604,
                                "footer": {
                                    "text": "Image " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": urls[number - 1]
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                            var lastUrls = [urls[number - 1]].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            imgMessage.edit({
                                embed: imgEmbed,
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            button.defer()
                        }
                        for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                            if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                            }
                        }
                        var p = imgMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                    break
                                }
                            }
                            if (!imgMessage) return
                            imgMessage.edit({
                                embed: imgEmbed
                            }).catch(() => { })
                        })
                        data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                    } else {
                        var imgEmbed = {
                            "title": "Image Search Results For: " + search,
                            "description": "Use the arrows to navigate.",
                            "color": 0x472604,
                            "footer": {
                                "text": "Image " + number + "/" + urls.length
                            },
                            "image": {
                                "url": urls[number - 1]
                            },
                            "author": {
                                "name": msg.author.tag,
                                "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                            }
                        };
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * urls.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return urls.length
                                },
                            },
                        ]
                        var buttonRow = new disbut.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new disbut.MessageButton()
                                .setStyle('blurple')
                                .setEmoji(reaction.reaction)
                                .setID(reaction.reaction)
                            buttonRow.addComponent(button)
                        })
                        var buttonRow2 = new disbut.MessageActionRow()
                        var benson = new disbut.MessageButton()
                            .setStyle('red')
                            .setEmoji('874406183933444156')
                            .setID('delete')
                        buttonRow2.addComponent(benson)

                        var imgMessage = await msg.channel.send({
                            embed: imgEmbed,
                            components: [buttonRow, buttonRow2]
                        }).catch(() => { })
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                        var lastUrls = [urls[number - 1]].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                        lastUrls.splice(100)
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        msg.channel.stopTyping(true)
                        var filter = (button) => {
                            if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                            if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                                button.defer()
                                return
                            }
                            if (button.id === 'delete') {
                                button.defer()
                                imgMessage.delete().catch(() => { })
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.id).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.id).function(number) < 1) {
                                button.defer()
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.id).function(number)
                            imgEmbed = {
                                "title": "Image Search Results For: " + search,
                                "description": "Use the arrows to navigate.",
                                "color": 0x472604,
                                "footer": {
                                    "text": "Image " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": urls[number - 1]
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                            var lastUrls = [urls[number - 1]].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            imgMessage.edit({
                                embed: imgEmbed,
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            button.defer()

                        }
                        for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                            if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                            }
                        }
                        var p = imgMessage.awaitButtons(filter, { time: 600000 }).then(() => {
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                    break
                                }
                            }
                            if (!imgMessage) return
                            imgMessage.edit({
                                embed: imgEmbed
                            }).catch(() => { })
                        })
                        data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                    }
                });
            }

            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined) {
                msg.channel.send('What do I search for?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            if (!isNaN(Number(args[args.length - 1].substring(5))) && args[args.length - 1].startsWith('page:')) {
                image(msg, args, Number(args[args.length - 1].substring(5)))
            }
            else {
                image(msg, args)
            }
        },
        help: {
            "name": "img/image <query> [page:[page]]",
            "value": "Search for a random image in the Internet.\nExample usage: p:img Burger -page 5"
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["ocr", "recognizetext"],
        execute: async function (msg, args) {
            async function ocr(msg, image, local) {
                Tesseract.recognize(image)
                    .then(({ data: { text } }) => {
                        if (text === '' || text === undefined) {
                            msg.channel.send('No text detected.').catch(() => { })
                            msg.channel.stopTyping(true)
                            if (local) fs.rmSync(local, { force: true, recursive: true })
                            return
                        }
                        msg.channel.send('```\n' + text + '```', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(async () => {
                            var currentcount = filecount
                            filecount = filecount + 1
                            fs.mkdirSync(`temp/file${currentcount}`)
                            fs.writeFileSync(`temp/file${currentcount}/ocr.txt`, text)
                            await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/ocr.txt`)).catch(() => { })
                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                        })
                        msg.channel.stopTyping(true)
                        if (local) fs.rmSync(local, { force: true, recursive: true })
                    }
                    )
                    .catch(function () {
                        msg.channel.send('Unsupported file: ' + image, {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                        if (local) fs.rmSync(local, { force: true, recursive: true })
                        return
                    })
            }

            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file to recognize?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                Jimp.read(currenturl, (_, image) => {
                                    var biggest = { value: (image.bitmap.height > image.bitmap.width) && image.bitmap.height || image.bitmap.width, constraint: (image.bitmap.height > image.bitmap.width) && 'height' || 'width' }
                                    if (biggest.value > 500) {
                                        image.resize(biggest.constraint === 'width' && 500 || Jimp.AUTO, biggest.constraint === 'height' && 500 || Jimp.AUTO)
                                    }
                                    image.write(`temp/file${currentcount}/output.png`)
                                    ocr(msg, `temp/file${currentcount}/output.png`, `temp/file${currentcount}`)
                                })
                            } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                exec(`ffmpeg -i ${currenturl} -vframes 1 temp/file${currentcount}/output.png`, () => {
                                    Jimp.read(`temp/file${currentcount}/output.png`, (_, image) => {
                                        var biggest = { value: (image.bitmap.height > image.bitmap.width) && image.bitmap.height || image.bitmap.width, constraint: (image.bitmap.height > image.bitmap.width) && 'height' || 'width' }
                                        if (biggest.value > 500) {
                                            image.resize(biggest.constraint === 'width' && 500 || Jimp.AUTO, biggest.constraint === 'height' && 500 || Jimp.AUTO)
                                        }
                                        image.write(`temp/file${currentcount}/output.png`)
                                        ocr(msg, `temp/file${currentcount}/output.png`, `temp/file${currentcount}`)
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "ocr/recognizetext <file>",
            "value": "Recognize text within an image with Poopy's mediocre OCR engine..."
        },
        cooldown: 2500,
        type: "Utility"
    },

    {
        name: ["ascii", "braille"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the image to asciify?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var negative = false
            if (saidMessage.includes('-negative')) negative = true
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var braille = await imageToBraille(currenturl, negative)
                                msg.channel.send(braille, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(async () => {
                                    var currentcount = filecount
                                    filecount = filecount + 1
                                    fs.mkdirSync(`temp/file${currentcount}`)
                                    fs.writeFileSync(`temp/file${currentcount}/ascii.txt`, braille)
                                    await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/ascii.txt`)).catch(() => { })
                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                })
                                msg.channel.stopTyping(true)
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "ascii/braille [-negative] <image>",
            "value": "Converts the image to ASCII.\nExample usage: p:ascii -negative https://cdn.discordapp.com/emojis/827634704722165783.png"
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["setstatus", "ss"],
        execute: async function (msg, args) {
            var ownerid = ownerids.find(id => id == msg.author.id);
            if (ownerid === undefined) {
                msg.channel.send('Owner only!').catch(() => { })
                return
            }
            else {
                if (args[1] === undefined && args[2] === undefined && args[3] === undefined) {
                    msg.channel.send('Where are the arguments?!').catch(() => { })
                    return;
                }
                else if (args[2] === undefined && args[3] === undefined) {
                    msg.channel.send('What is the status type?! (Available: **PLAYING**, **LISTENING**, **WATCHING**, **STREAMING**, **COMPETING**)').catch(() => { })
                    return;
                }
                else if (args[3] === undefined) {
                    msg.channel.send('What is the status message?!').catch(() => { })
                    return;
                }
                if (args[1] === 'false' || args[1] === 'true') {
                    if (args[2] === 'PLAYING' || args[2] === 'LISTENING' || args[2] === 'WATCHING' || args[2] === 'STREAMING' || args[2] === 'COMPETING') {
                        var saidMessage = args.join(' ').substring(args[0].length + args[1].length + args[2].length + 3)
                        msg.channel.startTyping().catch(() => { })
                        bot.user.setPresence({
                            status: 'online',
                            activity: {
                                name: saidMessage + ' | p:help',
                                type: args[2],
                                url: 'https://www.youtube.com/watch?v=hr7GyFM7pX4'
                            },
                        });
                        statusChanges = args[1];
                        msg.channel.send('Poopy\'s status set to: **' + saidMessage + ' (' + args[2] + ')**', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                    }
                    else {
                        msg.channel.send('Invalid status type: **' + args[2] + '** (Available: **PLAYING**, **LISTENING**, **WATCHING**, **STREAMING**, **COMPETING**)', {
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.stopTyping(true)
                    }
                }
                else {
                    msg.channel.send('Specify a valid value! (**false** or **true**)').catch(() => { })
                    return;
                }
            };
        },
        help: {
            "name": "setstatus/ss <changes? (false or true)> <type (STREAMING, WATCHING, PLAYING, LISTENING or COMPETING)> <statusMessage>",
            "value": "Allows Poopy to have a custom status.\nExample usage: p:setstatus false STREAMING you, idiot."
        },
        cooldown: 2500,
        type: "Owner"
    },

    {
        name: ["chew"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var chewings = []
            var chewnumber = Math.floor(Math.random() * 11) + 20
            for (var i = 0; i < chewnumber; i++) {
                chewings.push({
                    maskpos: { x: Math.floor(Math.random() * 101) / 100, y: Math.floor(Math.random() * 101) / 100 },
                    masksize: { x: Math.floor(Math.random() * 9) + 2, y: Math.floor(Math.random() * 9) + 2 },
                    maskangle: Math.floor(Math.random() * 361) - 180,
                    chewoffset: { x: Math.floor(Math.random() * 61) - 30, y: Math.floor(Math.random() * 61) - 30 },
                    repetitions: Math.floor(Math.random() * 9) + 1,
                    chew: async (frame, maskpos, masksize, maskangle, chewoffset) => {
                        var patchmask = await Jimp.read(`templates/babismask.png`)
                        var black = await Jimp.read(`templates/black.png`)
                        frame2 = frame.clone()
                        patchmask.resize(frame2.bitmap.width / masksize.x, frame2.bitmap.height / masksize.y)
                        patchmask.rotate(maskangle)
                        black.resize(frame2.bitmap.width, frame2.bitmap.height)
                        black.composite(patchmask, black.bitmap.width * maskpos.x - patchmask.bitmap.width / 2, black.bitmap.height * maskpos.y - patchmask.bitmap.height / 2)
                        frame2.mask(black, 0, 0)
                        frame.composite(frame2, chewoffset.x * (frame.bitmap.width / 250), chewoffset.y * (frame.bitmap.height / 250))
                    }
                })
            }
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                var frame = await Jimp.read(currenturl)
                                for (var i = 0; i < chewings.length; i++) {
                                    var origoffset = chewings[i].chewoffset
                                    var offset = chewings[i].chewoffset
                                    for (var j = 0; j < chewings[i].repetitions; j++) {
                                        await chewings[i].chew(frame, chewings[i].maskpos, chewings[i].masksize, chewings[i].maskangle, offset)
                                        offset.x += (origoffset.x * (frame.bitmap.width / 250)) * chewings[i].repetitions
                                        offset.y += (origoffset.y * (frame.bitmap.height / 250)) * chewings[i].repetitions
                                    }
                                }
                                frame.write(`temp/file${currentcount}/output.png`);
                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                if (!fileMsg) {
                                    try {
                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                    } catch (_) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        return
                                    }
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.stopTyping(true)
                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "chew <image>",
            "value": "Literally chews the image."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["srlogo", "sr", "soupremastered"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/soupremastered.png -filter_complex "[1:v]scale=${width}/3:-1[soup];[0:v][soup]overlay=x=0:y=H-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i templates/soupremastered.png -map 0:a? -filter_complex "[1:v]scale=${width}/3:-1[soup];[0:v][soup]overlay=x=0:y=H-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i templates/soupremastered.png -filter_complex "[1:v]scale=${width}/3:-1[soup];[0:v][soup]overlay=x=0:y=H-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "srlogo/sr/soupremastered <file>",
            "value": "Applies the Soup Remastered Logo to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["reverse"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]areverse[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]areverse[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "reverse <file>",
            "value": "Reverses the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["melt", "trippy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var decay = 95
            var decayindex = args.indexOf('-decay')
            if (decayindex > -1) {
                decay = isNaN(Number(args[decayindex + 1])) ? 95 : Number(args[decayindex + 1]) <= 0 ? 0 : Number(args[decayindex + 1]) >= 100 ? 100 : Number(args[decayindex + 1]) || 95
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.includes('N/A') ? '0' : iduration.replace(/\n|\r/g, ''))

                                            exec(args.indexOf('-loop') > -1 ? `ffmpeg -stream_loop 1 -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]lagfun=decay=${decay / 100},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p -ss ${iduration} temp/file${currentcount}/output.mp4` : `ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]lagfun=decay=${decay / 100},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.includes('N/A') ? '0' : iduration.replace(/\n|\r/g, ''))

                                            exec(args.indexOf('-loop') > -1 ? `ffmpeg -stream_loop 1 -i temp/file${currentcount}/input.${type.ext} -i templates/black.png -filter_complex "[1:v][0:v]scale2ref[black][gif];[black]split[blackw][blackn];[gif]hue=b=10[white];[blackw][white]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[meltalpha];[blackn][0:v]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[melt];[melt][meltalpha]alphamerge,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -ss ${iduration} temp/file${currentcount}/output.gif` : `ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/black.png -filter_complex "[1:v][0:v]scale2ref[black][gif];[black]split[blackw][blackn];[gif]hue=b=10[white];[blackw][white]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[meltalpha];[blackn][0:v]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[melt];[melt][meltalpha]alphamerge,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "melt/trippy <file> [-decay <percentage>] [-loop]",
            "value": "Adds a trippy melting effect to the file. Default decay is 95."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["ytp"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var filterslist = {
                video: [
                    `[v]reverse[2v]`,
                    `[v]negate[2v]`,
                    `[v]negate,reverse[2v]`,
                    `[v]fps=fps=vfps*2,setpts=0.5*PTS[2v]`,
                    `[v]fps=fps=vfps/2,setpts=2*PTS[2v]`,
                    `[v]hue=s=0[2v]`,
                    `[v]hue=s=0,negate[2v]`,
                    `[v]hue=s=-1[2v]`,
                    `[v]hue=s=10[2v]`,
                    `[v]hue=h=180[2v]`,
                    `[v]hue=s=0,curves=r='0/0 1/rrgb':g='0/0 1/rrgb':b='0/0 1/rrgb'[2v]`,
                    `[v]hflip[2v]`,
                    `[v]vflip[2v]`,
                    `[v]rotate=180*PI/180[2v]`,
                    `[v]split[vstack][vstack2];[vstack][vstack2]vstack,split[vvstack][vvstack2];[vvstack][vvstack2]hstack,scale=iw/2:ih/2[2v]`,
                    `[v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[2v]`,
                    `[v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[2v]`,
                    `[v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[2v]`,
                    `[v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[2v]`
                ],

                audio: [
                    `[a]areverse[2a]`,
                    `[a]aresample=44100,asetrate=44100/2,aresample=44100,atempo=2[2a]`,
                    `[a]aresample=44100,asetrate=44100*2,aresample=44100,atempo=0.5[2a]`,
                    `[a]atempo=2[2a]`,
                    `[a]atempo=0.5[2a]`,
                    `[a]acrusher=.1:1:64:0:log[2a]`,
                    `[a][1:a]afir=dry=10:wet=10[2a]`,
                    `[a]aecho=1:1:1000:1[2a]`,
                    `[a]aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1[2a]`,
                    `[a]aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1[2a]`
                ],
            }
            var clips = 10
            var clipsindex = args.indexOf('-clips')
            if (clipsindex > -1) {
                clips = isNaN(Number(args[clipsindex + 1])) ? 10 : Number(args[clipsindex + 1]) <= 1 ? 1 : Number(args[clipsindex + 1]) >= 200 ? 200 : Math.round(Number(args[clipsindex + 1])) || 10
            }
            var repetitions = 1
            var repindex = args.indexOf('-repetitions')
            if (repindex > -1) {
                repetitions = isNaN(Number(args[repindex + 1])) ? 1 : Number(args[repindex + 1]) <= 1 ? 1 : Number(args[repindex + 1]) >= 10 ? 10 : Math.round(Number(args[repindex + 1])) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/clips`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                                    fps = fps.replace(/\n|\r/g, '')

                                                    exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, duration) => {
                                                        duration = Number(duration.replace(/\n|\r/g, ''))
                                                        var clipduration = duration / clips
                                                        var clipsmade = 0
                                                        var clipfiles = []

                                                        var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                                                        for (var i = 1; i <= (clips * repetitions); i++) {
                                                            clipfiles.push(`file '${i}.mp4'`)
                                                        }

                                                        fs.writeFileSync(`temp/file${currentcount}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                                                            return Math.random() - 0.5
                                                        }).join('\n'))

                                                        var clipeditinterval = setInterval(() => {
                                                            clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                                                        }, 5000)

                                                        for (var h = 0; h < repetitions; h++) {
                                                            for (var i = 0; i < clips; i++) {
                                                                var vid = 0
                                                                var audio = 0
                                                                var vidfilters = []
                                                                var audiofilters = []

                                                                for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                                                    var vidfilter = filterslist.video[Math.floor(Math.random() * filterslist.video.length)]
                                                                        .replace(/vfps/g, fps)
                                                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                        .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                                                    if (vidfilter.includes('[v]fps=fps=vfps*2,setpts=0.5*PTS[2v]'
                                                                        .replace(/vfps/g, fps)
                                                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                        .replace(/\[2v\]/g, `[v${vid + 1}]`))) {
                                                                        var audiofilter = '[a]atempo=2[2a]'
                                                                            .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                                                            .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                                                        audiofilters.push(audiofilter)
                                                                        audio++
                                                                    }

                                                                    if (vidfilter.includes('[v]fps=fps=vfps/2,setpts=2*PTS[2v]'
                                                                        .replace(/vfps/g, fps)
                                                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                        .replace(/\[2v\]/g, `[v${vid + 1}]`))) {
                                                                        var audiofilter = '[a]atempo=0.5[2a]'
                                                                            .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                                                            .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                                                        audiofilters.push(audiofilter)
                                                                        audio++
                                                                    }

                                                                    vidfilters.push(vidfilter)
                                                                    vid += 1
                                                                }

                                                                for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                                                    var audiofilter = filterslist.audio[Math.floor(Math.random() * filterslist.audio.length)]
                                                                        .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                                                        .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                                                    if (audiofilter.includes('[a]atempo=2[2a]'
                                                                        .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                                                        .replace(/\[2a\]/g, `[a${audio + 1}]`))) {
                                                                        var vidfilter = '[v]fps=fps=vfps*2,setpts=0.5*PTS[2v]'
                                                                            .replace(/vfps/g, fps)
                                                                            .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                            .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                            .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                                                        vidfilters.push(vidfilter)
                                                                        vid++
                                                                    }

                                                                    if (audiofilter.includes('[a]atempo=0.5[2a]'
                                                                        .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                                                        .replace(/\[2a\]/g, `[a${audio + 1}]`))) {
                                                                        var vidfilter = '[v]fps=fps=vfps/2,setpts=2*PTS[2v]'
                                                                            .replace(/vfps/g, fps)
                                                                            .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                            .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                            .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                                                        vidfilters.push(vidfilter)
                                                                        vid++
                                                                    }

                                                                    audiofilters.push(audiofilter)
                                                                    audio += 1
                                                                }

                                                                var vidfilter = vidfilters.join(';')
                                                                var audiofilter = audiofilters.join(';')

                                                                async function encodeClip() {
                                                                    return new Promise(resolve => {
                                                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} ${audiofilter.includes('afir') ? '-i templates/church.mp3 ' : ''}-t ${clipduration} -ss ${clipduration * i} -filter_complex "${vidfilter}${vidfilter ? `;[v${vid}]` : '[0:v]'}scale=ceil(iw/2)*2:ceil(ih/2)*2[out]${audiofilter ? `;${audiofilter}` : ''}" -map "[out]" -map ${audiofilter ? `"[a${audio}]"` : '0:a'} -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/clips/${clipsmade + 1}.mp4`, (_, __, pedro) => {
                                                                            resolve()
                                                                        })
                                                                    })
                                                                }

                                                                await encodeClip()

                                                                clipsmade++
                                                            }
                                                        }

                                                        clearInterval(clipeditinterval)
                                                        clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                                                        exec(`ffmpeg -f concat -i temp/file${currentcount}/clips/list.txt -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                            clipsmessage.delete().catch(() => { })
                                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                            if (!fileMsg) {
                                                                try {
                                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                                } catch (_) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                    return
                                                                }
                                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                                if (fileLink) {
                                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                    if (!fileLinkMsg) {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    }
                                                                } else {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            }
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        })
                                                    })
                                                })
                                            } else {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                                    fps = fps.replace(/\n|\r/g, '')

                                                    exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, duration) => {
                                                        duration = Number(duration.replace(/\n|\r/g, ''))
                                                        var clipduration = duration / clips
                                                        var clipsmade = 0
                                                        var clipfiles = []

                                                        var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                                                        for (var i = 1; i <= (clips * repetitions); i++) {
                                                            clipfiles.push(`file '${i}.mp4'`)
                                                        }

                                                        fs.writeFileSync(`temp/file${currentcount}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                                                            return Math.random() - 0.5
                                                        }).join('\n'))

                                                        var clipeditinterval = setInterval(() => {
                                                            clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                                                        }, 5000)

                                                        for (var h = 0; h < repetitions; h++) {
                                                            for (var i = 0; i < clips; i++) {
                                                                var vid = 0
                                                                var vidfilters = []

                                                                for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                                                    var vidfilter = filterslist.video[Math.floor(Math.random() * filterslist.video.length)]
                                                                        .replace(/vfps/g, fps)
                                                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                        .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                                                    vidfilters.push(vidfilter)
                                                                    vid += 1
                                                                }

                                                                var vidfilter = vidfilters.join(';')

                                                                async function encodeClip() {
                                                                    return new Promise(resolve => {
                                                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -t ${clipduration} -ss ${clipduration * i} -filter_complex "${vidfilter}${vidfilter ? `;[v${vid}]` : '[0:v]'}scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/clips/${clipsmade + 1}.mp4`, () => {
                                                                            resolve()
                                                                        })
                                                                    })
                                                                }

                                                                await encodeClip()

                                                                clipsmade++
                                                            }
                                                        }

                                                        clearInterval(clipeditinterval)
                                                        clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                                                        exec(`ffmpeg -f concat -i temp/file${currentcount}/clips/list.txt -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                            clipsmessage.delete().catch(() => { })
                                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                            if (!fileMsg) {
                                                                try {
                                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                                } catch (_) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                    return
                                                                }
                                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                                if (fileLink) {
                                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                    if (!fileLinkMsg) {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    }
                                                                } else {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            }
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        })
                                                    })
                                                })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/clips`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, duration) => {
                                                duration = Number(duration.replace(/\n|\r/g, ''))
                                                var clipduration = duration / clips
                                                var clipsmade = 0
                                                var clipfiles = []

                                                var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                                                for (var i = 1; i <= (clips * repetitions); i++) {
                                                    clipfiles.push(`file '${i}.gif'`)
                                                }

                                                fs.writeFileSync(`temp/file${currentcount}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                                                    return Math.random() - 0.5
                                                }).join('\n'))

                                                var clipeditinterval = setInterval(() => {
                                                    clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                                                }, 5000)

                                                for (var h = 0; h < repetitions; h++) {
                                                    for (var i = 0; i < clips; i++) {
                                                        var vid = 0
                                                        var vidfilters = []

                                                        for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                                            var vidfilter = filterslist.video[Math.floor(Math.random() * filterslist.video.length)]
                                                                .replace(/vfps/g, fps)
                                                                .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                                                .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                                                .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                                            vidfilters.push(vidfilter)
                                                            vid += 1
                                                        }

                                                        var vidfilter = vidfilters.join(';')

                                                        async function encodeClip() {
                                                            return new Promise(resolve => {
                                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -t ${clipduration} -ss ${clipduration * i} -filter_complex "${vidfilter}${vidfilter ? `;[v${vid}]` : '[0:v]'}split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/clips/${clipsmade + 1}.gif`, () => {
                                                                    resolve()
                                                                })
                                                            })
                                                        }

                                                        await encodeClip()

                                                        clipsmade++
                                                    }
                                                }

                                                clearInterval(clipeditinterval)
                                                clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                                                exec(`ffmpeg -f concat -i temp/file${currentcount}/clips/list.txt -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    clipsmessage.delete().catch(() => { })
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/clips`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams a -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, duration) => {
                                            duration = Number(duration.replace(/\n|\r/g, ''))
                                            var clipduration = duration / clips
                                            var clipsmade = 0
                                            var clipfiles = []

                                            var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                                            for (var i = 1; i <= (clips * repetitions); i++) {
                                                clipfiles.push(`file '${i}.mp3'`)
                                            }

                                            fs.writeFileSync(`temp/file${currentcount}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                                                return Math.random() - 0.5
                                            }).join('\n'))

                                            var clipeditinterval = setInterval(() => {
                                                clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                                            }, 5000)

                                            for (var h = 0; h < repetitions; h++) {
                                                for (var i = 0; i < clips; i++) {
                                                    var audio = 0
                                                    var audiofilters = []

                                                    for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                                        var audiofilter = filterslist.audio[Math.floor(Math.random() * filterslist.audio.length)]
                                                            .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                                            .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                                        audiofilters.push(audiofilter)
                                                        audio += 1
                                                    }

                                                    var audiofilter = audiofilters.join(';')

                                                    async function encodeClip() {
                                                        return new Promise(resolve => {
                                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} ${audiofilter.includes('afir') ? '-i templates/church.mp3 ' : ''}-t ${clipduration} -ss ${clipduration * i} ${audiofilter ? `-filter_complex ${audiofilter} -map "[a${audio}]" ` : ''}-preset ultrafast temp/file${currentcount}/clips/${clipsmade + 1}.mp3`, () => {
                                                                resolve()
                                                            })
                                                        })
                                                    }

                                                    await encodeClip()

                                                    clipsmade++
                                                }
                                            }

                                            clearInterval(clipeditinterval)
                                            clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                                            exec(`ffmpeg -f concat -i temp/file${currentcount}/clips/list.txt -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                                clipsmessage.delete().catch(() => { })
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "ytp <file> [-clips <number (max 200)>] [-repetitions <number (max 10)>] [-norandomize]",
            "value": "Turns the file into a YTP. Default clips is 10 and repetitions is 1."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["boomerang"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse[rv];[0:v][rv]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]areverse[ra];[0:a][ra]concat[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse[r];[0:v][r]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse[r];[0:v][r]concat,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]areverse[r];[0:a][r]concat[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "boomerang <file>",
            "value": "Plays the file until the end and reverses it back to the start."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["reverseboomerang", "rboomerang"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse[rv];[rv][0:v]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]areverse[ra];[ra][0:a]concat[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse[r];[r][0:v]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]reverse[r];[r][0:v]concat,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]areverse[r];[r][0:a]concat[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "reverseboomerang/rboomerang <file>",
            "value": "Reverses the file back to the start and plays it until the end."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hsl", "hsv"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var hue = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= -360 ? -360 : Number(String(args[1]).replace(/,/g, '')) >= 360 ? 360 : Number(String(args[1]).replace(/,/g, '')) || 0
            var saturation = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 1 : Number(String(args[2]).replace(/,/g, '')) <= -10 ? -10 : Number(String(args[2]).replace(/,/g, '')) >= 10 ? 10 : Number(String(args[2]).replace(/,/g, '')) || 1
            var lightness = isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= -10 ? -10 : Number(String(args[3]).replace(/,/g, '')) >= 10 ? 10 : Number(String(args[3]).replace(/,/g, '')) || 0
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=h=${hue}:s=${saturation}:b=${lightness}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]hue=h=${hue}:s=${saturation}:b=${lightness},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=h=${hue}:s=${saturation}:b=${lightness},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hsl/hsv [hue (from -360 to 360)] [saturation (from -10 to 10)] [lightness (from -10 to 10)] <file>",
            "value": "Changes the file's hue, saturation and lightness values."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["color"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var r = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[1]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[1]).replace(/,/g, '')) || 0
            var g = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 0 : Number(String(args[2]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[2]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[2]).replace(/,/g, '')) || 0
            var b = isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[3]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[3]).replace(/,/g, '')) || 0
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=s=0,curves=r='0/${r / 255} 1/1':g='0/${g / 255} 1/1':b='0/${b / 255} 1/1'[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]hue=s=0,curves=r='0/${r / 255} 1/1':g='0/${g / 255} 1/1':b='0/${b / 255} 1/1',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=s=0,curves=r='0/${r / 255} 1/1':g='0/${g / 255} 1/1':b='0/${b / 255} 1/1',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "color [r] [g] [b] <file>",
            "value": "Gives the file a new color depending on the RGB values, focusing more on lighter tones."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["color2"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var r = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[1]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[1]).replace(/,/g, '')) || 0
            var g = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 0 : Number(String(args[2]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[2]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[2]).replace(/,/g, '')) || 0
            var b = isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[3]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[3]).replace(/,/g, '')) || 0
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/${r / 255}':g='0/0 1/${g / 255}':b='0/0 1/${b / 255}'[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/${r / 255}':g='0/0 1/${g / 255}':b='0/0 1/${b / 255}',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/${r / 255}':g='0/0 1/${g / 255}':b='0/0 1/${b / 255}',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "color2 [r] [g] [b] <file>",
            "value": "Gives the file a new color depending on the RGB values, focusing more on darker tones."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["rotate", "rot"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var degrees = isNaN(Number(args[1])) ? 0 : Number(args[1]) <= -360 ? -360 : Number(args[1]) >= 360 ? 360 : Number(args[1]) || 0
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]rotate=${degrees}*PI/180:ow=rotw(${degrees}*PI/180):oh=roth(${degrees}*PI/180):c=0x00000000[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]rotate=${degrees}*PI/180:ow=rotw(${degrees}*PI/180):oh=roth(${degrees}*PI/180):c=0x00000000,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]rotate=${degrees}*PI/180:ow=rotw(${degrees}*PI/180):oh=roth(${degrees}*PI/180):c=0x00000000,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "rotate/rot {degrees (from -360 to 360)} <file>",
            "value": "Rotates the file by {degrees}."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["spin"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var duration = 1
            var durationindex = args.indexOf('-duration')
            if (durationindex > -1) {
                duration = isNaN(Number(args[durationindex + 1])) ? 1 : Number(args[durationindex + 1]) <= 0.1 ? 0.1 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -r 50 -stream_loop -1 -t ${duration} -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,rotate=t/${duration}*360*PI/180:ow='max(iw,ih)':oh=max'(iw,ih)':c=0x00000000,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r 50 -t ${duration} temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "spin <file> [-duration <seconds (max 10)>]",
            "value": "Continuously spins the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["volume"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var volume = isNaN(Number(args[1])) ? 100 : Number(args[1]) || 0
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter:a "volume=${volume / 100}" -filter:v "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter:a "volume=${volume / 100}" temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "volume {volume (by percentage)} <video/audio>",
            "value": "Changes the video's volume by {volume}%."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["volume2"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var volume = isNaN(Number(args[1])) ? 0 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 64 ? 64 : Number(args[1]) || 0
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter:a "acrusher=.1:1:${volume}:0:log" -filter:v "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter:a "acrusher=.1:1:${volume}:0:log" temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "volume2 {volume (from 1 to 64)} <video/audio>",
            "value": "Changes the video's volume by {volume}. This option includes earrape."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["reverb"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/church.mp3 -filter_complex "[0:a][1]afir=dry=10:wet=10[audio];[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[video]" -map "[video]" -map "[audio]" -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/church.mp3 -filter_complex "[0:a][1]afir=dry=10:wet=10[audio]" -map "[audio]" temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "reverb <video/audio>",
            "value": "Adds a reverb effect to the video."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["echo"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var delay = 1
            var delayindex = args.indexOf('-delay')
            if (delayindex > -1) {
                delay = isNaN(Number(args[delayindex + 1])) ? 1 : Number(args[delayindex + 1]) < 0 ? 0.1 : Number(args[delayindex + 1]) >= 90 ? 90 : Number(args[delayindex + 1]) || 1
            }
            var decay = 50
            var decayindex = args.indexOf('-decay')
            if (decayindex > -1) {
                decay = isNaN(Number(args[decayindex + 1])) ? 50 : Number(args[decayindex + 1]) <= 0 ? 0 : Number(args[decayindex + 1]) >= 100 ? 100 : Number(args[decayindex + 1]) || 50
            }
            var echoes = 1
            var echoesindex = args.indexOf('-echoes')
            if (echoesindex > -1) {
                echoes = isNaN(Number(args[echoesindex + 1])) ? 1 : Number(args[echoesindex + 1]) <= 1 ? 1 : Number(args[echoesindex + 1]) >= 99 ? 99 : Number(args[echoesindex + 1]) || 1
            }
            var echocode = `aecho=1:1:${delay * 1000}:${decay / 100}`
            var echocodes = []
            for (var i = 0; i < echoes; i++) echocodes.push(echocode)
            var echoescode = echocodes.join(',')
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, duration) => {
                                                    duration = duration.replace(/\n|\r/g, '')

                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]${echoescode}[audio];[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[video]" -map "[video]" -map "[audio]" -t ${duration} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]${echoescode}[audio]" -map "[audio]" temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "echo <video/audio> [-delay <seconds (max 90)>] [-decay <loudness (from 0 to 100)>] [-echoes <number (from 1 to 99)>]",
            "value": "Adds an echo effect to the video."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["glow", "holy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]inflate,inflate,inflate,inflate,inflate,inflate,inflate,inflate[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]inflate,inflate,inflate,inflate,inflate,inflate,inflate,inflate[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]inflate,inflate,inflate,inflate,inflate,inflate,inflate,inflate[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "glow/holy <file>",
            "value": "Adds a glow effect to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["dizzy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var distance = 5
            var distanceindex = args.indexOf('-distance')
            if (distanceindex > -1) {
                distance = isNaN(Number(args[distanceindex + 1])) ? 15 : Number(args[distanceindex + 1]) || 15
            }
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0]rgbashift=rh=${distance}:bv=${distance}:gh=${-distance},format=rgba[in2];[in2][0]scale2ref[in2][in1];[in1][in2]blend=overlay[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0]rgbashift=rh=${distance}:bv=${distance}:gh=${-distance},format=rgba[in2];[in2][0]scale2ref[in2][in1];[in1][in2]blend=overlay[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0]rgbashift=rh=${distance}:bv=${distance}:gh=${-distance},format=rgba[in2];[in2][0]scale2ref[in2][in1];[in1][in2]blend=overlay[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "dizzy <file> [-distance <distance>]",
            "value": "Adds a dizzy effect to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hflip"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hflip[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]hflip,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hflip,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hflip <file>",
            "value": "Flips the file horizontally."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["vflip"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]vflip[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]vflip,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]vflip,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "vflip <file>",
            "value": "Flips the file vertically."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["invert", "negate", "negative"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]negate[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]negate,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]negate,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "invert/negate/negative <file>",
            "value": "Inverts the file's colors."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["erode", "corrode"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var strength = 1
            var strengthindex = args.indexOf('-strength')
            if (strengthindex > -1) {
                strength = isNaN(Number(args[strengthindex + 1])) ? 1 : Number(args[strengthindex + 1]) <= 1 ? 1 : Number(args[strengthindex + 1]) >= 100 ? 100 : Math.round(Number(args[strengthindex + 1])) || 1
            }
            var erosioncode = `erosion`
            var erosioncodes = []
            for (var i = 0; i < strength; i++) erosioncodes.push(erosioncode)
            var erosionscode = erosioncodes.join(',')
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${erosionscode}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]${erosionscode},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${erosionscode},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "erode/corrode <file> [-strength <number (max 100)>]",
            "value": "Erodes the file's colors. Default strength is 1."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["dilate"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var strength = 1
            var strengthindex = args.indexOf('-strength')
            if (strengthindex > -1) {
                strength = isNaN(Number(args[strengthindex + 1])) ? 1 : Number(args[strengthindex + 1]) <= 1 ? 1 : Number(args[strengthindex + 1]) >= 100 ? 100 : Math.round(Number(args[strengthindex + 1])) || 1
            }
            var dilationcode = `dilation`
            var dilationcodes = []
            for (var i = 0; i < strength; i++) dilationcodes.push(dilationcode)
            var dilationscode = dilationcodes.join(',')
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${dilationscode}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]${dilationscode},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${dilationscode},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "dilate <file> [-strength <number (max 100)>]",
            "value": "Dilates the file's colors. Default strength is 1."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["lmirror", "mirrorl", "leftmirror", "mirrorleft"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "leftmirror/mirrorleft/lmirror/mirrorl <file>",
            "value": "Mirrors the left side of the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["rightmirror", "mirrorright", "rmirror", "mirrorr"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "rightmirror/mirrorright/rmirror/mirrorr <file>",
            "value": "Mirrors the right side of the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["topmirror", "mirrortop", "tmirror", "mirrort"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "topmirror/mirrortop/tmirror/mirrort <file>",
            "value": "Mirrors the top side of the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["bottommirror", "mirrorbottom", "bmirror", "mirrorb"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "bottommirror/mirrorbottom/bmirror/mirrorb <file>",
            "value": "Mirrors the bottom side of the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["seizure", "disco"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -stream_loop 24 -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/1':g='0/0 1/0':b='0/0 1/0',hue=H=8*PI*t,scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/1':g='0/0 1/0':b='0/0 1/0',hue=H=8*PI*t,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/1':g='0/0 1/0':b='0/0 1/0',hue=H=8*PI*t,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "seizure/disco <file>",
            "value": "Adds a seizure effect to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["penlarge", "pixelenlarge"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier}):flags=neighbor[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier}):flags=neighbor,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier}):flags=neighbor,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "penlarge/pixelenlarge [multiplier (from 1 to 6)] <file>",
            "value": "Enlarges the file in pixelated mode."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["enlarge"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier})[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier}),scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier}),split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "enlarge [multiplier (from 1 to 6)] <file>",
            "value": "Enlarges the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["shrink"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > exceptionsizelimit) {
                                msg.channel.send(`that file exceeds the exception size limit of ${exceptionsizelimit} mb hahahaha`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw/${multiplier}):round(ih/${multiplier})[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=round(iw/${multiplier}):round(ih/${multiplier}),scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw/${multiplier}):round(ih/${multiplier}),split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "shrink [multiplier (from 1 to 6)] <file>",
            "value": "Shrinks the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["hpstretch", "hpixelstretch", "phstretch", "pixelhstretch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):ih:flags=neighbor[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=round(iw*${multiplier}):ih:flags=neighbor,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width * multiplier)}:${height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):ih:flags=neighbor,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width * multiplier)}:${height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hpstretch/hpixelstretch/phstretch/pixelhstretch [multiplier (from 1 to 6)] <file>",
            "value": "Stretches the file horizontally in pixelated mode."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hstretch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):ih[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=round(iw*${multiplier}):ih,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width * multiplier)}:${height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw*${multiplier}):ih,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width * multiplier)}:${height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hstretch [multiplier (from 1 to 6)] <file>",
            "value": "Stretches the file horizontally."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["vstretch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw:round(ih*${multiplier})[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=iw:round(ih*${multiplier}),scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${width}:${Math.round(height * multiplier)} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw:round(ih*${multiplier}),split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${width}:${Math.round(height * multiplier)} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "vstretch [multiplier (from 1 to 6)] <file>",
            "value": "Stretches the file vertically."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["vshrink"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > exceptionsizelimit) {
                                msg.channel.send(`that file exceeds the exception size limit of ${exceptionsizelimit} mb hahahaha`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw:round(ih/${multiplier})[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=iw:round(ih/${multiplier}),scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${width}:${Math.round(height / multiplier)} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw:round(ih/${multiplier}),split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${width}:${Math.round(height / multiplier)} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "vshrink [multiplier (from 1 to 6)] <file>",
            "value": "Shrinks the file vertically."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["hshrink"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > exceptionsizelimit) {
                                msg.channel.send(`that file exceeds the exception size limit of ${exceptionsizelimit} mb hahahaha`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw/${multiplier}):ih[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=round(iw/${multiplier}):ih,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width / multiplier)}:${height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=round(iw/${multiplier}):ih,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width / multiplier)}:${height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hshrink [multiplier (from 1 to 6)] <file>",
            "value": "Shrinks the file horizontally."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["vpstretch", "vpixelstretch", "pvstretch", "pixelvstretch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw:round(ih*${multiplier}):flags=neighbor[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=iw:round(ih*${multiplier}):flags=neighbor,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width * multiplier)}:${height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw:round(ih*${multiplier}):flags=neighbor,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${Math.round(width * multiplier)}:${height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "vpstretch/vpixelstretch/pvstretch/pixelvstretch [multiplier (from 1 to 6)] <file>",
            "value": "Stretches the file vertically in pixelated mode."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hstack"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var stack = 1
            var stackindex = args.indexOf('-stack')
            if (stackindex > -1) {
                stack = isNaN(Number(args[stackindex + 1])) ? 1 : Number(args[stackindex + 1]) <= 1 ? 1 : Number(args[stackindex + 1]) >= 10 ? 10 : Math.round(Number(args[stackindex + 1])) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}hstack=inputs=${stack + 1}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]${'[0:v]'.repeat(stack)}hstack=inputs=${stack + 1}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${width * (stack + 1)}:${height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}hstack=inputs=${stack + 1}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hstack <file> [-stack <number (from 1 to 10)>]",
            "value": "Stacks the file horizontally."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["vstack"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var stack = 1
            var stackindex = args.indexOf('-stack')
            if (stackindex > -1) {
                stack = isNaN(Number(args[stackindex + 1])) ? 1 : Number(args[stackindex + 1]) <= 1 ? 1 : Number(args[stackindex + 1]) >= 10 ? 10 : Math.round(Number(args[stackindex + 1])) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}vstack=inputs=${stack + 1}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]${'[0:v]'.repeat(stack)}vstack=inputs=${stack + 1}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${width}:${height * (stack + 1)} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}vstack=inputs=${stack + 1}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "vstack <file> [-stack <number (from 1 to 10)>]",
            "value": "Stacks the file vertically."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["hd"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var hmult = Math.floor(Math.random() * 16) + 10
            var vmult = Math.floor(Math.random() * 16) + 10
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1},scale=iw/${hmult}:ih/${vmult},scale=${width}:${height}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -b:a 10k -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1},scale=iw/${hmult}:ih/${vmult},scale=${width}:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1},scale=iw/${hmult}:ih/${vmult},scale=${width}:${height},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hd <file>",
            "value": "Makes the file Ultra HD 4k 2160p Blu-ray"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["phd", "pixelhd"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var hmult = Math.floor(Math.random() * 16) + 10
            var vmult = Math.floor(Math.random() * 16) + 10
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1}:flags=neighbor,scale=iw/${hmult}:ih/${vmult}:flags=neighbor,scale=${width}:${height}:flags=neighbor[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -b:a 10k -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1}:flags=neighbor,scale=iw/${hmult}:ih/${vmult}:flags=neighbor,scale=${width}:${height}:flags=neighbor,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1}:flags=neighbor,scale=iw/${hmult}:ih/${vmult}:flags=neighbor,scale=${width}:${height}:flags=neighbor,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "phd/pixelhd <file>",
            "value": "Makes the file Ultra HD 4k 2160p Blu-ray (pixel edition!!)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["playbutton", "play", "pb"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/play.png -filter_complex "[0:v][1:v]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i templates/play.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i templates/play.png -filter_complex "[0:v][1:v]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "playbutton/play/pb <file>",
            "value": "Adds a play button to the file for epic pranks!!!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["fail", "norris"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/norris.png -filter_complex "[0:v]scale=508:257[frame];[1:v][frame]overlay=x=7:y=306:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i templates/norris.png -map 0:a? -filter_complex "[0:v]scale=508:257[frame];[1:v][frame]overlay=x=7:y=306:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i templates/norris.png -filter_complex "[0:v]scale=508:257[frame];[1:v][frame]overlay=x=7:y=306:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "fail/norris <file>",
            "value": "FAIL"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["frames", "extractframes", "getframes"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/frames`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -count_packets -show_entries stream=nb_read_packets -of csv=p=0 temp/file${currentcount}/input.${type.ext}`, async (_, frames) => {
                                            frames = Number(frames.replace(/\n|\r/g, ''))

                                            if (frames <= 500) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} temp/file${currentcount}/frames/frame_%04d.png`, async () => {
                                                    var output = fs.createWriteStream(`temp/file${currentcount}/output.zip`)
                                                    var archive = archiver('zip')
                                                    output.on('finish', async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.zip`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.zip`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.zip`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    });

                                                    archive.pipe(output)
                                                    archive.directory(`temp/file${currentcount}/frames`, false);
                                                    archive.finalize()
                                                })
                                            } else {
                                                await msg.channel.send(`The last ${frames - 500 === 1 ? '' : frames - 500} ${frames - 500 === 1 ? 'frame' : 'frames'} from the file will be ignored during the process.`).catch(() => { })
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 500 temp/file${currentcount}/frames/frame_%04d.png`, async () => {
                                                    var output = fs.createWriteStream(`temp/file${currentcount}/output.zip`)
                                                    var archive = archiver('zip')
                                                    output.on('finish', async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.zip`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.zip`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.zip`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    });

                                                    archive.pipe(output)
                                                    archive.directory(`temp/file${currentcount}/frames`, false);
                                                    archive.finalize()
                                                })
                                            }
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "frames/extractframes/getframes <video/gif>",
            "value": "Extracts all of the frames in the video/GIF and archives them in a ZIP file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["canyoufind", "find"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var size = 150
            var sizeindex = args.indexOf('-size')
            if (sizeindex > -1) {
                size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 1 ? 1 : Number(args[sizeindex + 1]) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext)))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)
            var frame = await Jimp.read(currenturl)
            var frame2 = await Jimp.read(currenturl2)
            var canyoufind = await Jimp.read(`templates/canyoufind.png`)
            var transparent = await Jimp.read(`templates/transparent.png`)
            var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
            frame2.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? size : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? size : Jimp.AUTO)
            var frame2stretched = frame2.clone()
            frame2stretched.resize(227, 53)
            canyoufind.composite(frame2stretched, 347, 8)
            frame.resize(canyoufind.bitmap.width, Jimp.AUTO)
            frame.composite(frame2, (Math.floor(Math.random() * (frame.bitmap.width + 1)) - 1) - frame2.bitmap.width / 2, (Math.floor(Math.random() * (frame.bitmap.height + 1)) - 1) - frame2.bitmap.height / 2)
            transparent.resize(frame.bitmap.width, frame.bitmap.height + canyoufind.bitmap.height)
            transparent.composite(canyoufind, 0, 0)
            transparent.composite(frame, 0, canyoufind.bitmap.height)
            transparent.write(`temp/file${currentcount}/output.png`);
            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
            if (!fileMsg) {
                try {
                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                if (fileLink) {
                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                    if (!fileLinkMsg) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                } else {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                }
            }
            msg.channel.stopTyping(true)
            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
        },
        help: {
            "name": "canyoufind/find <background> <tofind> [-size <pixels>]",
            "value": "Can you find mario (only works with static images though)\nExample usage: p:find https://images.herzindagi.info/image/2020/Jun/chocolate-parle-g-ice-cream.jpg https://pbs.twimg.com/media/BOgwprmCEAAvjq3.jpg -size 50"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["mixaudio", "mixsound", "mixmusic"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if ((i == 0 && !(type.mime.startsWith('audio') || type.mime.startsWith('image') || type.mime.startsWith('video'))) || (i == 1 && !(type.mime.startsWith('audio') || type.mime.startsWith('video')))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, (_, duration) => {
                                exec(`ffprobe -v error -select_streams a -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, (_, duration2) => {
                                    exec(`ffprobe -i temp/file${currentcount}/input.${filetype.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                        exec(`ffprobe -i temp/file${currentcount}/input2.${filetype2.ext} -show_streams -select_streams a -loglevel error`, async (_, audio2) => {
                                            if (audio2) {
                                                duration = duration.replace(/\n|\r/g, '')
                                                duration2 = duration2.replace(/\n|\r/g, '')

                                                exec(filetype.mime.startsWith('image') ? `ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -preset ultrafast -c:v libx264 -tune stillimage -c:a aac -pix_fmt yuv420p -shortest -t ${duration2} temp/file${currentcount}/output.mp4` : !audio ? `ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -c:v libx264 -tune stillimage -c:a aac -pix_fmt yuv420p -shortest -t ${duration} temp/file${currentcount}/output.mp4` : `ffmpeg -y -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[0:a][1:a]amix=inputs=2:duration=longest[a]" ${!(filetype.mime.startsWith('audio')) ? '-map 0:v ' : ''}-map "[a]" -preset ultrafast ${!(filetype.mime.startsWith('audio')) ? '-c:v libx264 -pix_fmt yuv420p ' : ''} -shortest -t ${duration} temp/file${currentcount}/output.${!(filetype.mime.startsWith('audio')) ? 'mp4' : 'mp3'}`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.${!(filetype.mime.startsWith('audio')) ? 'mp4' : 'mp3'}`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.${!(filetype.mime.startsWith('audio')) ? 'mp4' : 'mp3'}`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.${!(filetype.mime.startsWith('audio')) ? 'mp4' : 'mp3'}`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "mixaudio/mixsound/mixmusic <file> <audio>",
            "value": "Mixes the first file's audio with the second file's audio."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["addaudio", "addsound", "addmusic"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if ((i == 0 && !(type.mime.startsWith('image') || type.mime.startsWith('video'))) || (i == 1 && !(type.mime.startsWith('audio') || type.mime.startsWith('video')))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, (_, duration) => {
                                exec(`ffprobe -v error -select_streams a -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, (_, duration2) => {
                                    exec(`ffprobe -i temp/file${currentcount}/input2.${filetype2.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                        if (audio) {
                                            duration = Number(duration.replace(/\n|\r/g, ''))
                                            duration2 = Number(duration2.replace(/\n|\r/g, ''))

                                            exec(filetype.mime.startsWith('video') ? `ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -c:v libx264 -pix_fmt yuv420p -t ${duration2 <= duration ? duration2 : duration} temp/file${currentcount}/output.mp4` : `ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -c:v libx264 -tune stillimage -c:a aac -pix_fmt yuv420p -shortest -t ${duration2} temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else {
                                            await msg.channel.send('No audio stream detected.').catch(() => { })
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        }
                                    })
                                })
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "addaudio/addsound/addmusic <file> <audio>",
            "value": "Adds the second file's audio to the first file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["chromakey", "chroma"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var rgb = {
                r: 0,
                g: 255,
                b: 0,
            }
            var colorindex = args.indexOf('-color')
            if (colorindex > -1) {
                var r = args[colorindex + 1]
                var g = args[colorindex + 2]
                var b = args[colorindex + 3]
                rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
            }
            var rgbhex = `0x${rgb.r.toString(16).padStart(2, '0').toUpperCase()}${rgb.g.toString(16).padStart(2, '0').toUpperCase()}${rgb.b.toString(16).padStart(2, '0').toUpperCase()}`
            var similarity = 30
            var similarityindex = args.indexOf('-similarity')
            if (similarityindex > -1) {
                similarity = isNaN(Number(args[similarityindex + 1])) ? 30 : Number(args[similarityindex + 1]) <= 0 ? 0 : Number(args[similarityindex + 1]) >= 100 ? 100 : Number(args[similarityindex + 1]) || 30
            }
            var blend = 30
            var blendindex = args.indexOf('-blend')
            if (blendindex > -1) {
                blend = isNaN(Number(args[blendindex + 1])) ? 30 : Number(args[blendindex + 1]) <= 0 ? 0 : Number(args[blendindex + 1]) >= 100 ? 100 : Number(args[blendindex + 1]) || 30
            }
            var ox = 0
            var oy = 0
            var offsetindex = args.indexOf('-offset')
            if (offsetindex > -1) {
                ox = isNaN(Number(String(args[offsetindex + 1]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 1]).replace(/,/g, '')) || 0
                oy = isNaN(Number(String(args[offsetindex + 2]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 2]).replace(/,/g, '')) || 0
            }
            var size = 0
            var sizeindex = args.indexOf('-size')
            if (sizeindex > -1) {
                size = isNaN(Number(args[sizeindex + 1])) ? 0 : Number(args[sizeindex + 1]) <= 1 ? 1 : Number(args[sizeindex + 1]) || 0
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${filetype.ext}`, (_, scale) => {
                                scale = scale.replace(/\n|\r/g, '').split('x')
                                var height = Number(scale[1])

                                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size || height}[chroma];[0:v][chroma]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.png`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)) || (filetype2.mime.startsWith('video')))) {
                                    exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size || height}[chroma];[0:v][chroma]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[qout];[qout]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size || height}[chroma];[0:v][chroma]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if (filetype.mime.startsWith('video')) {
                                    exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -i temp/file${currentcount}/input2.${filetype2.ext} -map 0:a? -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size || height}[chroma];[0:v][chroma]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else {
                                    exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size || height}[chroma];[0:v][chroma]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                }
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "chromakey/chroma <file> <chromakey> [-color <r> <g> <b>] [-similarity (from 0 to 100)] [-blend (from 0 to 100)] [-offset <x> <y>] [-size <pixels>]",
            "value": "Adds the specified chroma key to the file. Default similarity and blend are 30."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["chromakeybg", "chromabg"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var rgb = {
                r: 0,
                g: 255,
                b: 0,
            }
            var colorindex = args.indexOf('-color')
            if (colorindex > -1) {
                var r = args[colorindex + 1]
                var g = args[colorindex + 2]
                var b = args[colorindex + 3]
                rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
            }
            var rgbhex = `0x${rgb.r.toString(16).padStart(2, '0').toUpperCase()}${rgb.g.toString(16).padStart(2, '0').toUpperCase()}${rgb.b.toString(16).padStart(2, '0').toUpperCase()}`
            var similarity = 30
            var similarityindex = args.indexOf('-similarity')
            if (similarityindex > -1) {
                similarity = isNaN(Number(args[similarityindex + 1])) ? 30 : Number(args[similarityindex + 1]) <= 0 ? 0 : Number(args[similarityindex + 1]) >= 100 ? 100 : Number(args[similarityindex + 1]) || 30
            }
            var blend = 30
            var blendindex = args.indexOf('-blend')
            if (blendindex > -1) {
                blend = isNaN(Number(args[blendindex + 1])) ? 30 : Number(args[blendindex + 1]) <= 0 ? 0 : Number(args[blendindex + 1]) >= 100 ? 100 : Number(args[blendindex + 1]) || 30
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/billboard.png -map 0:a? -filter_complex "[0:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/billboard.png -filter_complex "[0:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "chromakeybg/chromabg <file> [-color <r> <g> <b>]",
            "value": "Tries to remove the file's background with chroma key."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["overlay"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var ox = 0
            var oy = 0
            var offsetindex = args.indexOf('-offset')
            if (offsetindex > -1) {
                ox = isNaN(Number(String(args[offsetindex + 1]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 1]).replace(/,/g, '')) || 0
                oy = isNaN(Number(String(args[offsetindex + 2]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 2]).replace(/,/g, '')) || 0
            }
            var size = 0
            var sizeindex = args.indexOf('-size')
            if (sizeindex > -1) {
                size = isNaN(Number(args[sizeindex + 1])) ? 0 : Number(args[sizeindex + 1]) <= 1 ? 1 : Number(args[sizeindex + 1]) || 0
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${filetype.ext}`, (_, scale) => {
                                scale = scale.replace(/\n|\r/g, '').split('x')
                                var height = Number(scale[1])

                                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${size || height}[overlay];[0:v][overlay]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.png`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)) || (filetype2.mime.startsWith('video')))) {
                                    exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${size || height}[overlay];[0:v][overlay]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[qout];[qout]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${size || height}[overlay];[0:v][overlay]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if (filetype.mime.startsWith('video')) {
                                    exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -i temp/file${currentcount}/input2.${filetype2.ext} -map 0:a? -filter_complex "[1:v]scale=-1:${size || height}[overlay];[0:v][overlay]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else {
                                    exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${size || height}[overlay];[0:v][overlay]overlay=shortest=1:x=W/2-w/2+${Math.round(ox)}:y=H/2-h/2+${Math.round(oy)}:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                }
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "overlay <file> <overlay> [-offset <x> <y>] [-size <pixels>]",
            "value": "Adds the specified overlay to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["morph", "transform"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)
            fs.mkdirSync(`temp/file${currentcount}/frames`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -vf "scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease" -vframes 1 temp/file${currentcount}/static.png`, () => {
                                exec(`ffmpeg -i temp/file${currentcount}/input2.${filetype2.ext} -vf "scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease" -vframes 1 temp/file${currentcount}/static2.png`, () => {
                                    exec(`python templates/morph.py temp/file${currentcount}`, () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/frames/frame_%06d.png -filter_complex "[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.gif`, async (_, __, er) => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "morph/transform <file> <file2>",
            "value": "Morphs the first file into the second."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hmerge"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, async (_, fps) => {
                                fps = fps.replace(/\n|\r/g, '')

                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, async (_, fps2) => {
                                    fps2 = fps2.replace(/\n|\r/g, '')

                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${filetype.ext}`, (_, scale) => {
                                        scale = scale.replace(/\n|\r/g, '').split('x')
                                        var height = Number(scale[1])

                                        if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${height}[file2];[0:v][file2]hstack=shortest=1[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)) || (filetype2.mime.startsWith('video')))) {
                                            exec(`ffmpeg -stream_loop -1 -r ${fps2} -i temp/file${currentcount}/input.${filetype.ext} -r ${fps2} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${height}[file2];[0:v][file2]hstack=shortest=1[qout];[qout]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${height}[file2];[0:v][file2]hstack=shortest=1[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else if (filetype.mime.startsWith('video')) {
                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -map 0:a? -filter_complex "[1:v]scale=-1:${height}[file2];[0:v][file2]hstack=shortest=1[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else {
                                            exec(`ffmpeg -stream_loop -1 -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=-1:${height}[file2];[0:v][file2]hstack=shortest=1[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        }
                                    })
                                })
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "hmerge <file> <file2>",
            "value": "Merges the first file with the second one horizontally."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["vmerge"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, async (_, fps) => {
                                fps = fps.replace(/\n|\r/g, '')

                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, async (_, fps2) => {
                                    fps2 = fps2.replace(/\n|\r/g, '')

                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${filetype.ext}`, (_, scale) => {
                                        scale = scale.replace(/\n|\r/g, '').split('x')
                                        var width = Number(scale[0])

                                        if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                            exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=${width}:-1[file2];[0:v][file2]vstack=shortest=1[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)) || (filetype2.mime.startsWith('video')))) {
                                            exec(`ffmpeg -stream_loop -1 -r ${fps2} -i temp/file${currentcount}/input.${filetype.ext} -r ${fps2} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=${width}:-1[file2];[0:v][file2]vstack=shortest=1[qout];[qout]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=${width}:-1[file2];[0:v][file2]vstack=shortest=1[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else if (filetype.mime.startsWith('video')) {
                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -map 0:a? -filter_complex "[1:v]scale=${width}:-1[file2];[0:v][file2]vstack=shortest=1[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        } else {
                                            exec(`ffmpeg -stream_loop -1 -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -filter_complex "[1:v]scale=${width}:-1[file2];[0:v][file2]vstack=shortest=1[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        }
                                    })
                                })
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "vmerge <file> <file2>",
            "value": "Merges the first file with the second one vertically."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["transition"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var transitions = [
                'fade',
                'wipeleft',
                'wiperight',
                'wipeup',
                'wipedown',
                'slideleft',
                'slideright',
                'slideup',
                'slidedown',
                'circlecrop',
                'rectcrop',
                'distance',
                'fadeblack',
                'fadewhite',
                'radial',
                'smoothleft',
                'smoothright',
                'smoothup',
                'smoothdown',
                'circleopen',
                'circleclose',
                'vertopen',
                'vertclose',
                'horzopen',
                'horzclose',
                'dissolve',
                'pixelize',
                'diagtl',
                'diagtr',
                'diagbl',
                'diagbr',
                'hlslice',
                'hrslice',
                'vuslice',
                'vdslice',
                'random'
            ]
            var unsupported = [
                'hblur',
                'fadegrays',
                'wipetl',
                'wipetr',
                'wipebl',
                'wipebr',
                'squeezev',
                'squeezeh',
                'custom'
            ]
            var duration = 1
            var durationindex = args.indexOf('-duration')
            if (durationindex > -1) {
                duration = isNaN(Number(args[durationindex + 1])) ? 1 : Number(args[durationindex + 1]) <= 0.1 ? 0.1 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var currenturl2 = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
            if (args[2] === undefined) {
                var c = currenturl
                currenturl = currenturl2
                currenturl2 = c
            }
            var transition = 'fade'
            if (args[1] ? transitions.find(t => t === args[1].toLowerCase()) : false) {
                if (unsupported.find(t => t === args[1].toLowerCase())) {
                    msg.channel.send('Sorry, but that transition isn\'t supported...').catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
                if (args[1].toLowerCase() === 'random') {
                    transition = transitions[Math.floor(Math.random() * transitions.length)]
                } else {
                    transition = args[1].toLowerCase()
                }
            } else if (args[2] ? transitions.find(t => t === args[2].toLowerCase()) : false) {
                if (unsupported.find(t => t === args[2].toLowerCase())) {
                    msg.channel.send('Sorry, but that transition isn\'t supported...').catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
                if (args[2].toLowerCase() === 'random') {
                    transition = transitions[Math.floor(Math.random() * transitions.length)]
                } else {
                    transition = args[2].toLowerCase()
                }
            } else if (args[3] ? transitions.find(t => t === args[3].toLowerCase()) : false) {
                if (unsupported.find(t => t === args[3].toLowerCase())) {
                    msg.channel.send('Sorry, but that transition isn\'t supported...').catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
                if (args[3].toLowerCase() === 'random') {
                    transition = transitions[Math.floor(Math.random() * transitions.length)]
                } else {
                    transition = args[3].toLowerCase()
                }
            }
            var errors = {}
            var urlresponse = await fetch(currenturl).catch(err => errors.urlresponse = err.message)
            var urlresponse2 = await fetch(currenturl2).catch(err => errors.urlresponse2 = err.message)
            var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${currenturl}\``)
            var filetype2 = await fileType.fromStream(urlresponse2.body).catch(() => errors.filetype2 = `Unsupported file: \`${currenturl2}\``)
            var body = await urlresponse.text()
            if (body.length / 1048576 > sizelimit) {
                errors.size = `the first file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var body2 = await urlresponse2.text()
            if (body2.length / 1048576 > sizelimit) {
                errors.size2 = `the second file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
            }
            var filetypes = [filetype, filetype2]
            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${filetype.ext}`)

            require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                response.pipe(writeStream)
                writeStream.on('finish', async () => {
                    var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/input2.${filetype2.ext}`)

                    require(currenturl2.startsWith('https') ? 'https' : 'http').get(currenturl2, (response2) => {
                        response2.pipe(writeStream2)
                        writeStream2.on('finish', async () => {
                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${filetype.ext}`, (_, scale) => {
                                scale = scale.replace(/\n|\r/g, '').split('x')
                                var width = Number(scale[0])
                                var height = Number(scale[1])

                                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffmpeg -stream_loop -1 -t ${duration} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -t ${duration} -i temp/file${currentcount}/input2.${filetype2.ext} -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration},scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -loop 0 -t ${duration} temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, async (_, fps2) => {
                                        fps2 = fps2.replace(/\n|\r/g, '')

                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, (_, iduration2) => {
                                            iduration2 = Number(iduration2.includes('N/A') ? '0' : iduration2.replace(/\n|\r/g, ''))

                                            exec(`ffmpeg -stream_loop -1 -t ${iduration2} -r ${fps2} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -t ${iduration2} -r ${fps2} -i temp/file${currentcount}/input2.${filetype2.ext} -stream_loop -1 -t ${iduration2} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration >= iduration2 && !(filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext))) ? iduration2 : duration},scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -t ${iduration2} temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, async (_, fps) => {
                                        fps = fps.replace(/\n|\r/g, '')

                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.includes('N/A') ? '0' : iduration.replace(/\n|\r/g, ''))

                                            exec(`ffmpeg -stream_loop -1 -t ${iduration} -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -t ${iduration} -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -stream_loop -1 -t ${iduration} -r ${fps} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration}${iduration - duration > duration ? `:offset=${iduration - duration}` : ''},split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -t ${iduration} temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                                    exec(`ffprobe -i temp/file${currentcount}/input.${filetype.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                        exec(`ffprobe -i temp/file${currentcount}/input2.${filetype2.ext} -show_streams -select_streams a -loglevel error`, async (_, audio2) => {
                                            exec(filetype.mime.startsWith('video') ? `ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}` : `ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, async (_, fps) => {
                                                fps = fps.replace(/\n|\r/g, '')

                                                exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, (_, iduration) => {
                                                    iduration = Number(iduration.includes('N/A') ? '0' : iduration.replace(/\n|\r/g, ''))

                                                    exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input2.${filetype2.ext}`, (_, iduration2) => {
                                                        iduration2 = Number(iduration2.includes('N/A') ? '0' : iduration2.replace(/\n|\r/g, ''))

                                                        exec(`ffmpeg -i temp/file${currentcount}/input.${filetype.ext} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -video_track_timescale 30k -pix_fmt yuv420p -c:a aac -ac 6 -ar 44100 temp/file${currentcount}/concat.mp4`, async () => {
                                                            exec(`ffmpeg -i temp/file${currentcount}/input2.${filetype2.ext} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -video_track_timescale 30k -pix_fmt yuv420p -c:a aac -ac 6 -ar 44100 temp/file${currentcount}/concat2.mp4`, async () => {
                                                                exec(`ffmpeg -stream_loop -1 -t ${audio ? iduration : iduration + iduration2} -r ${fps} -i temp/file${currentcount}/concat.mp4 -stream_loop -1 -t ${iduration2} -r ${fps} -i temp/file${currentcount}/concat2.mp4 -stream_loop -1 -t ${iduration2} -r ${fps} -i templates/transparent.png ${!audio && audio2 ? `-stream_loop -1 -t ${iduration2} -r ${fps} -itsoffset ${iduration} -i temp/file${currentcount}/concat2.mp4 ` : ''}-filter_complex "[1:v]scale=-1:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[vid];[2:v]scale=${width}:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration >= iduration2 && !(filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext))) ? iduration2 : duration}${iduration - duration > duration ? `:offset=${iduration - duration}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]${audio && audio2 ? `;[0:a][1:a]acrossfade=d=${duration}[aout]` : ''}" -map "[out]" ${(audio && audio2) ? '-map "[aout]" ' : (audio && !audio2) ? '-map 0:a ' : (!audio && audio2) ? '-map 3:a ' : ''}-aspect ${width}:${height} -preset ultrafast -c:v libx264 -pix_fmt yuv420p -t ${iduration + iduration2} temp/file${currentcount}/output.mp4`, async () => {
                                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                                    if (!fileMsg) {
                                                                        try {
                                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                                        } catch (_) {
                                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                            msg.channel.stopTyping(true)
                                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                            return
                                                                        }
                                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                                        if (fileLink) {
                                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                            if (!fileLinkMsg) {
                                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                            }
                                                                        } else {
                                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                        }
                                                                    }
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                } else {
                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, async (_, fps) => {
                                        fps = fps.replace(/\n|\r/g, '')

                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.includes('N/A') ? '0' : iduration.replace(/\n|\r/g, ''))

                                            exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${filetype.ext}`, (_, iduration2) => {
                                                iduration2 = Number(iduration2.includes('N/A') ? '0' : iduration2.replace(/\n|\r/g, ''))

                                                exec(`ffmpeg -stream_loop -1 -t ${iduration} -r ${fps} -i temp/file${currentcount}/input.${filetype.ext} -stream_loop -1 -t ${iduration2} -r ${fps} -i temp/file${currentcount}/input2.${filetype2.ext} -stream_loop -1 -t ${iduration2} -r ${fps} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration >= iduration2 && !(filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext))) ? iduration2 : duration}${iduration - duration > duration ? `:offset=${iduration - duration}` : ''},split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -t ${iduration + iduration2} temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                }
                            })
                        })
                    })
                })
            })
        },
        help: {
            "name": "transition {transition (default is fade)} <file> <file2> [-duration <seconds (max 10)>]",
            "value": "Does a transition between the first file and the second one. A list of transitions can be found here, including random: https://trac.ffmpeg.org/wiki/Xfade"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["iceberg"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                msg.channel.send('What are the files?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var stages = 10
            var stageindex = args.indexOf('-stages')
            if (stageindex > -1) {
                stages = isNaN(Number(args[stageindex + 1])) ? 10 : Number(args[stageindex + 1]) <= 1 ? 1 : Number(args[stageindex + 1]) >= 10 ? 10 : Math.round(Number(args[stageindex + 1])) || 10
            }
            var stagewords = {}
            var stageimages = {}
            var stagewrdsdimensions = {
                stage1: [0, 0, 1263, 266],
                stage2: [0, 273, 1263, 263],
                stage3: [0, 543, 1263, 311],
                stage4: [0, 861, 1263, 277],
                stage5: [0, 1145, 1263, 282],
                stage6: [0, 1434, 1263, 251],
                stage7: [0, 1692, 1263, 269],
                stage8: [0, 1969, 1263, 270],
                stage9: [0, 2246, 1263, 292],
                stage10: [0, 2545, 1263, 270],
            }
            var stageimgdimensions = {
                stage1: [1287, 0, 293, 266],
                stage2: [1287, 273, 293, 263],
                stage3: [1287, 543, 293, 311],
                stage4: [1287, 861, 293, 277],
                stage5: [1287, 1145, 293, 282],
                stage6: [1287, 1434, 293, 251],
                stage7: [1287, 1692, 293, 269],
                stage8: [1287, 1969, 293, 270],
                stage9: [1287, 2246, 293, 292],
                stage10: [1287, 2545, 293, 270],
            }
            var stagematches = saidMessage.match(/-stage([1-9]|10)(words|image)/g)
            if (stagematches) {
                for (var i in stagematches) {
                    var stagematch = stagematches[i]
                    var stagematch2 = stagematch.match(/^-stage\d+(words|image)$/)
                    var argIndex = args.indexOf(stagematch)
                    var nextArgs = args.slice(argIndex + 1)
                    var arg = ''
                    for (var j in nextArgs) {
                        var nextArg = nextArgs[j]
                        if (nextArg.match(/^-stage\d+(words|image)$|^-stages$/)) break
                        arg += `${nextArg} `
                    }
                    arg = arg.substring(0, arg.length - 1)
                    var stagenumber = stagematch.substring(6, stagematch.length - stagematch2[1].length)
                    var stagetype = stagematch2[1]
                    if (stagetype === 'words') {
                        var words = arg.split(/ ?\| ?/)
                        stagewords['stage' + stagenumber] = words
                    } else {
                        stageimages['stage' + stagenumber] = arg
                    }
                }
            }

            var errors = {}
            var filetypes = {}
            var nofiles = true
            var lasturlserror = ''

            if (!(Object.keys(stageimages).length)) {
                var validfilecount = 0

                async function inspect(url) {
                    var lasturlerror = false
                    var urlresponse = await fetch(url).catch(err => {
                        lasturlerror = true
                        lasturlserror = err.message
                    })
                    if (lasturlerror) return
                    var filetype = await fileType.fromStream(urlresponse.body).catch(() => {
                        lasturlerror = true
                        lasturlserror = `Unsupported file: \`${currenturl}\``
                    })
                    if (lasturlerror || filetype == undefined) return
                    var body = await urlresponse.text()
                    if (body.length / 1048576 > sizelimit) {
                        lasturlerror = true
                        lasturlserror = `one of the files exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
                    }
                    if (lasturlerror) return
                    if (!(filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext)))) return
                    stageimages['stage' + (validfilecount + 1)] = url
                    nofiles = false
                    return true
                }

                for (var i in data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
                    var url = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'][i]
                    var success = await inspect(url)
                    if (success) validfilecount += 1
                    if (validfilecount >= 10) break
                }
            }

            for (var stage in stageimages) {
                var imageurl = stageimages[stage]
                var urlresponse = await fetch(imageurl).catch(err => errors.urlresponse = err.message)
                var filetype = await fileType.fromStream(urlresponse.body).catch(() => errors.filetype = `Unsupported file: \`${imageurl}\``)
                var body = await urlresponse.text()
                if (body.length / 1048576 > sizelimit) {
                    errors.size = `one of the files exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
                }
                filetypes[stage] = filetype
            }

            if (nofiles && lasturlserror) {
                msg.channel.send(lasturlserror, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.stopTyping(true)
                return
            }

            for (var i in errors) {
                var error = errors[i]
                if (error) {
                    msg.channel.send(error, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }

            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext)))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }

            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)

            var iceberg = await Jimp.read(`templates/iceberg.png`)
            var arialr = await Jimp.loadFont(`templates/fonts/ArialRed/ArialRed.fnt`)

            iceberg.crop(0, 0, iceberg.bitmap.width, stagewrdsdimensions['stage' + stages][1] + stagewrdsdimensions['stage' + stages][3])

            for (var i in stageimages) {
                async function composite() {
                    return new Promise((resolve) => {
                        var imageurl = stageimages[i]
                        var filetype = filetypes[i]
                        var dimensions = stageimgdimensions[i]
                        var writeStream = fs.createWriteStream(`temp/file${currentcount}/${i}.${filetype.ext}`)

                        require(imageurl.startsWith('https') ? 'https' : 'http').get(imageurl, (response) => {
                            response.pipe(writeStream)
                            writeStream.on('finish', async () => {
                                var image = await Jimp.read(`temp/file${currentcount}/${i}.${filetype.ext}`)
                                image.resize(dimensions[2], dimensions[3])
                                iceberg.composite(image, dimensions[0], dimensions[1])
                                resolve()
                            })
                        })
                    })
                }

                await composite()
            }

            for (var i in stagewords) {
                var words = stagewords[i]
                var wordsS = []
                for (var j in words) {
                    var word = words[j]
                    wordsS.push(word)
                    wordsS.push(' '.repeat(Math.floor((Math.floor(Math.random() * 61) + 30) / words.length / (word.length / 15))))
                }
                wordsS.splice(wordsS.length - 1)
                var text = wordsS.join('')
                var dimensions = stagewrdsdimensions[i]

                iceberg.print(arialr, dimensions[0], dimensions[1], { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, dimensions[2], dimensions[3])
            }

            iceberg.write(`temp/file${currentcount}/output.png`)

            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
            if (!fileMsg) {
                try {
                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                if (fileLink) {
                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                    if (!fileLinkMsg) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                } else {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                }
            }
            msg.channel.stopTyping(true)
            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
        },
        help: {
            "name": "iceberg {-stage<stagenumber>words <word1 | word2 | ...>} {-stage<stagenumber>image <image>} [-stages <stagenumber (from 1 to 10)>]",
            "value": "Makes a conspiracy iceberg by filling in random words and images. (only supports static image files)\nExample usage: p:iceberg -stage1words Stolen Assets | Deinx -stage1image https://cdn.discordapp.com/attachments/760223418968047629/862409703392149554/c85e3e8144c1012764074e60607c5e56.png -stage10words Vordath is Transexual -stage10image https://cdn.discordapp.com/attachments/760223418968047629/862410091814322216/output.png"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["makegif"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (args[1] === undefined && msg.attachments.size <= 0 && !(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'].length)) {
                msg.channel.send('What are the frames?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var frameurls = []
            var fpsIsLastArg = false
            if (!isNaN(Number(args[args.length - 1]))) {
                fpsIsLastArg = true
            }
            var nofiles = false
            if (args[fpsIsLastArg ? 2 : 1] === undefined && msg.attachments.size <= 0) nofiles = true
            var fps = !fpsIsLastArg ? undefined : Number(args[args.length - 1]) >= 60 ? 60 : Number(args[args.length - 1]) <= 0 ? 0 : Number(args[args.length - 1]) || undefined
            var saidMessage = args.splice(1, fpsIsLastArg ? args.length - 2 : args.length - 1).join(' ')
            var lasturlserror = ''
            if (nofiles) {
                var validfilecount = 0

                async function inspect(url) {
                    var lasturlerror = false
                    var urlresponse = await fetch(url).catch(err => {
                        lasturlerror = true
                        lasturlserror = err.message
                    })
                    if (lasturlerror) return
                    var filetype = await fileType.fromStream(urlresponse.body).catch(() => {
                        lasturlerror = true
                        lasturlserror = `Unsupported file: \`${currenturl}\``
                    })
                    if (lasturlerror || filetype == undefined) return
                    var body = await urlresponse.text()
                    if (body.length / 1048576 > sizelimit) {
                        lasturlerror = true
                        lasturlserror = `one of the files exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
                    }
                    if (lasturlerror) return
                    if (!(filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext)))) return
                    frameurls.push(url)
                    return true
                }

                for (var i in data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
                    var url = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'][i]
                    var success = await inspect(url)
                    if (success) validfilecount += 1
                    if (validfilecount >= 50) break
                }
            } else if (msg.attachments.size) {
                msg.attachments.forEach(attachment => {
                    frameurls.push(attachment.url)
                })
            } else {
                frameurls = saidMessage.split(' ')
            }
            var filetypes = []
            var error = ''

            for (var i in frameurls) {
                var url = frameurls[i]
                if (error) break
                var urlresponse = await fetch(url).catch(err => error = err.message)
                if (error) break
                var filetype = await fileType.fromStream(urlresponse.body).catch(() => error = `Unsupported file: \`${currenturl}\``)
                if (error) break
                var body = await urlresponse.text()
                if (body.length / 1048576 > sizelimit) {
                    error = `one of the files exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`
                }
                if (error) break
                filetypes.push(filetype)
            }

            if (nofiles && lasturlserror && !frameurls.length) {
                msg.channel.send(lasturlserror, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.stopTyping(true)
                return
            }

            if (error) {
                msg.channel.send(error, {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.stopTyping(true)
                return
            }

            for (var i in filetypes) {
                var type = filetypes[i]
                if (!(type.mime.startsWith('image') || gifFormats.find(f => f === type.ext))) {
                    msg.channel.send('Unsupported file types.', {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                }
            }

            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)
            fs.mkdirSync(`temp/file${currentcount}/frames`)
            var framesizes
            for (var i = 0; i < frameurls.length; i++) {
                var frameurl = frameurls[i]
                var frame = await Jimp.read(frameurl).catch(() => { })
                if (!frame) {
                    await msg.channel.send(`Unsupported file: \`${frameurl}\``, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                if (!framesizes) {
                    framesizes = { x: frame.bitmap.width, y: frame.bitmap.height }
                }
                frame.resize(framesizes.x, framesizes.y)
                frame.write(`temp/file${currentcount}/frames/${i + 1}.png`)
            }
            exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -vf palettegen=reserve_transparent=1 temp/file${currentcount}/palette.png`, () => {
                exec(`ffmpeg ${fps && `-r ${fps}` || ''} -i temp/file${currentcount}/frames/%d.png -i temp/file${currentcount}/palette.png -filter_complex "[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,mpdecimate[gif];[gif][1:v]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -vsync 0 -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                    if (!fileMsg) {
                        try {
                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                        } catch (_) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            msg.channel.stopTyping(true)
                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                            return
                        }
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                })
            })
        },
        help: {
            "name": "makegif <frames> {fps}",
            "value": "Makes a GIF out of the frames and FPS specified."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["country", "flag"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/country.png -filter_complex "[0:v]scale=283:168[frame];[1:v][frame]overlay=x=15:y=56:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/country.png -map 0:a? -filter_complex "[0:v]scale=283:168[frame];[1:v][frame]overlay=x=15:y=56:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/country.png -filter_complex "[0:v]scale=283:168[frame];[1:v][frame]overlay=x=15:y=56:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "country/flag <file>",
            "value": "It's my Mainland!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["notclickbait", "redcircle"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            var random = false
            if (saidMessage.includes('-random')) random = true
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/redcircle.png -filter_complex "[1:v]scale=${random ? `${(width + height) / 5}:-1` : `${squareS.constraint === 'width' ? -1 : width}:${squareS.constraint === 'height' ? -1 : height}`}[circle];[0:v][circle]overlay=x=${random ? (Math.floor(Math.random() * (width + 1)) - 1) + '-w/2' : 'W/2-w/2'}:y=${random ? (Math.floor(Math.random() * (height + 1)) - 1) + '-h/2' : 'H/2-h/2'}:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/redcircle.png -map 0:a? -filter_complex "[1:v]scale=${random ? `${(width + height) / 5}:-1` : `${squareS.constraint === 'width' ? -1 : width}:${squareS.constraint === 'height' ? -1 : height}`}[circle];[0:v][circle]overlay=x=${random ? (Math.floor(Math.random() * (width + 1)) - 1) + '-w/2' : 'W/2-w/2'}:y=${random ? (Math.floor(Math.random() * (height + 1)) - 1) + '-h/2' : 'H/2-h/2'}:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/redcircle.png -filter_complex "[1:v]scale=${random ? `${(width + height) / 5}:-1` : `${squareS.constraint === 'width' ? -1 : width}:${squareS.constraint === 'height' ? -1 : height}`}[circle];[0:v][circle]overlay=x=${random ? (Math.floor(Math.random() * (width + 1)) - 1) + '-w/2' : 'W/2-w/2'}:y=${random ? (Math.floor(Math.random() * (height + 1)) - 1) + '-h/2' : 'H/2-h/2'}:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "notclickbait/redcircle [-random] <file>",
            "value": "Real.\nExample usage: p:notclickbait -random https://imagesvc.meredithcorp.io/v3/mm/image?q=85&c=sc&poi=face&w=2000&h=1000&url=https%3A%2F%2Fstatic.onecms.io%2Fwp-content%2Fuploads%2Fsites%2F9%2F2013%2F12%2F06%2F201307-xl-spice-roasted-pork-tenderloin-2000.jpg"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["lefishe", "fishe"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var transparent = await Jimp.read('templates/transparent.png')
                                            var brushscript = await Jimp.loadFont('templates/fonts/BrushScript/BrushScript.fnt')
                                            transparent.resize(width, height)
                                            transparent.resize(500, Jimp.AUTO)
                                            transparent.print(brushscript, 50, 50, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 100, transparent.bitmap.height - 100)
                                            transparent.write(`temp/file${currentcount}/caption.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/caption.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var transparent = await Jimp.read('templates/transparent.png')
                                            var brushscript = await Jimp.loadFont('templates/fonts/BrushScript/BrushScript.fnt')
                                            transparent.resize(width, height)
                                            transparent.resize(500, Jimp.AUTO)
                                            transparent.print(brushscript, 50, 50, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 100, transparent.bitmap.height - 100)
                                            transparent.write(`temp/file${currentcount}/caption.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/caption.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var transparent = await Jimp.read('templates/transparent.png')
                                            var brushscript = await Jimp.loadFont('templates/fonts/BrushScript/BrushScript.fnt')
                                            transparent.resize(width, height)
                                            transparent.resize(500, Jimp.AUTO)
                                            transparent.print(brushscript, 50, 50, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 100, transparent.bitmap.height - 100)
                                            transparent.write(`temp/file${currentcount}/caption.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/caption.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "lefishe/fishe \"{name}\" <file>",
            "value": "au chocolat."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["meme4", "tenorcaption"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var size = 1
            var sizeindex = args.indexOf('-size')
            if (sizeindex > -1) {
                size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
            }
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""', '""']
            } else if (!matchedTextes[1]) {
                matchedTextes[1] = '""'
            }
            var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var text2 = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var rgb = {
                r: 255,
                g: 255,
                b: 255,
            }
            var colorindex = args.indexOf('-color')
            if (colorindex > -1) {
                var r = args[colorindex + 1]
                var g = args[colorindex + 2]
                var b = args[colorindex + 3]
                rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var transparent = await Jimp.read('templates/transparent.png')
                                            var ubuntu = await Jimp.loadFont('templates/fonts/Ubuntu/Ubuntu.fnt')
                                            transparent.resize(width, height)
                                            transparent.resize(Math.round(2000 * (1 / size)), Jimp.AUTO)
                                            var transparent2 = transparent.clone()
                                            transparent.print(ubuntu, 80, 80, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                                            transparent2.print(ubuntu, 80, 80, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                                            transparent.resize(width, height)
                                            transparent2.resize(width, height)
                                            transparent.write(`temp/file${currentcount}/caption.png`)
                                            transparent2.write(`temp/file${currentcount}/caption2.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/caption.png -i temp/file${currentcount}/caption2.png -filter_complex "[1:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[top];[2:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[bottom];[0:v][top]overlay=x=0:y=0:format=auto[caption];[caption][bottom]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var transparent = await Jimp.read('templates/transparent.png')
                                                var ubuntu = await Jimp.loadFont('templates/fonts/Ubuntu/Ubuntu.fnt')
                                                transparent.resize(width, height)
                                                transparent.resize(Math.round(2000 * (1 / size)), Jimp.AUTO)
                                                var transparent2 = transparent.clone()
                                                transparent.print(ubuntu, 80, 80, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                                                transparent2.print(ubuntu, 80, 80, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                                                transparent.resize(width, height)
                                                transparent2.resize(width, height)
                                                transparent.write(`temp/file${currentcount}/caption.png`)
                                                transparent2.write(`temp/file${currentcount}/caption2.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/caption.png -r ${fps} -i temp/file${currentcount}/caption2.png -map 0:a? -filter_complex "[1:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[top];[2:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[bottom];[0:v][top]overlay=x=0:y=0:format=auto[caption];[caption][bottom]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var transparent = await Jimp.read('templates/transparent.png')
                                                var ubuntu = await Jimp.loadFont('templates/fonts/Ubuntu/Ubuntu.fnt')
                                                transparent.resize(width, height)
                                                transparent.resize(Math.round(2000 * (1 / size)), Jimp.AUTO)
                                                var transparent2 = transparent.clone()
                                                transparent.print(ubuntu, 80, 80, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                                                transparent2.print(ubuntu, 80, 80, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                                                transparent.resize(width, height)
                                                transparent2.resize(width, height)
                                                transparent.write(`temp/file${currentcount}/caption.png`)
                                                transparent2.write(`temp/file${currentcount}/caption2.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/caption.png -r ${fps} -i temp/file${currentcount}/caption2.png -filter_complex "[1:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[top];[2:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[bottom];[0:v][top]overlay=x=0:y=0:format=auto[caption];[caption][bottom]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "meme4/tenorcaption \"{topText}\" \"[bottomText]\" <file> [-color <r> <g> <b>] [-size <multiplier (from 0.5 to 5)>]",
            "value": "Adds a Tenor GIF caption to the file.\nExample usage: p:tenorcaption \"You putrid fool\" https://cdn.discordapp.com/attachments/691444857108955196/855507735750901831/output.png -color 255 0 0"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["tord", "tordenask", "tordenaskwatermark"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/tordenask.png -filter_complex "[1:v]scale=${width}/1.5:-1[tord];[0:v][tord]overlay=x=0:y=H-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/tordenask.png -map 0:a? -filter_complex "[1:v]scale=${width}/1.5:-1[tord];[0:v][tord]overlay=x=0:y=H-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/tordenask.png -filter_complex "[1:v]scale=${width}/1.5:-1[tord];[0:v][tord]overlay=x=0:y=H-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "tord/tordenask/tordenaskwatermark <file>",
            "value": "Applies the Tordenask Watermark to the file. https://gizmo.moe/profile?user=2"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["idfsgs"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/idfsgs.png -filter_complex "[1:v]scale=${width}/1.5:-1,rotate=-3*PI/180:c=0x00000000[idfsgs];[0:v][idfsgs]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/idfsgs.png -map 0:a? -filter_complex "[1:v]scale=${width}/1.5:-1,rotate=-3*PI/180:c=0x00000000[idfsgs];[0:v][idfsgs]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/idfsgs.png -filter_complex "[1:v]scale=${width}/1.5:-1,rotate=-3*PI/180:c=0x00000000[idfsgs];[0:v][idfsgs]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "idfsgs <file>",
            "value": "Applies the IDFSGS Logo to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["install", "installnow"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/install.png -i templates/transparent.png -filter_complex "[1:v]scale=${width}:-1[install];[2:v][install]scale2ref=h=ih+${height}[transparent][install2];[transparent][0:v]overlay=x=0:y=0:format=auto[fout];[fout][install2]overlay=x=0:y=${height}:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i templates/install.png -filter_complex "[0:v]scale=${width}:-1[install]" -map "[install]" temp/file${currentcount}/install.png`, async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/install.png`, (_, bscale) => {
                                                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                    var bheight = Number(bscale[1])

                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/install.png -i templates/transparent.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref=h=ih+${height}[transparent][install2];[transparent][0:v]overlay=x=0:y=0:format=auto[fout];[fout][install2]overlay=x=0:y=${height}:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${width}:${height + bheight} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i templates/install.png -filter_complex "[0:v]scale=${width}:-1[install]" -map "[install]" temp/file${currentcount}/install.png`, async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/install.png`, (_, bscale) => {
                                                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                    var bheight = Number(bscale[1])

                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/install.png -i templates/transparent.png -filter_complex "[2:v][1:v]scale2ref=h=ih+${height}[transparent][install2];[transparent][0:v]overlay=x=0:y=0:format=auto[fout];[fout][install2]overlay=x=0:y=${height}:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${width}:${height + bheight} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "install/installnow <file>",
            "value": "Install Now"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["reddit"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var reddittop = await Jimp.read(`templates/reddittop.png`)
                                var ibm = await Jimp.loadFont(`templates/fonts/IBMPlexSans/IBMPlexSans.fnt`)
                                reddittop.print(ibm, 18, 315, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 364, 66)
                                reddittop.write(`temp/file${currentcount}/top.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${reddittop.bitmap.width}:-1[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/scaled.png`, async () => {
                                            exec(`ffmpeg -i temp/file${currentcount}/top.png -i temp/file${currentcount}/scaled.png -i templates/redditbottom.png -i templates/redditbg.png -filter_complex "vstack=inputs=3[transparent];[3:v][transparent]scale2ref[bg][transparent2];[bg][transparent2]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var reddittop = await Jimp.read(`templates/reddittop.png`)
                                var redditbottom = await Jimp.read(`templates/redditbottom.png`)
                                var ibm = await Jimp.loadFont(`templates/fonts/IBMPlexSans/IBMPlexSans.fnt`)
                                reddittop.print(ibm, 18, 315, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 364, 66)
                                reddittop.write(`temp/file${currentcount}/top.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=${reddittop.bitmap.width}:-1,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/scaled.mp4`, async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/scaled.mp4`, (_, scale) => {
                                                    scale = scale.replace(/\n|\r/g, '').split('x')
                                                    var width = Number(scale[0])
                                                    var height = Number(scale[1])

                                                    exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/top.png -r ${fps} -i temp/file${currentcount}/scaled.mp4 -r ${fps} -i templates/redditbottom.png -i templates/redditbg.png -map 1:a? -filter_complex "vstack=inputs=3[transparent];[3:v][transparent]scale2ref[bg][transparent2];[bg][transparent2]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${width}:${reddittop.bitmap.height + height + redditbottom.bitmap.height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var reddittop = await Jimp.read(`templates/reddittop.png`)
                                var ibm = await Jimp.loadFont(`templates/fonts/IBMPlexSans/IBMPlexSans.fnt`)
                                reddittop.print(ibm, 18, 315, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 364, 66)
                                reddittop.write(`temp/file${currentcount}/top.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${reddittop.bitmap.width}:-1,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/scaled.gif`, async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/scaled.gif`, (_, scale) => {
                                                    scale = scale.replace(/\n|\r/g, '').split('x')
                                                    var width = Number(scale[0])
                                                    var height = Number(scale[1])

                                                    exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/top.png -r ${fps} -i temp/file${currentcount}/scaled.gif -r ${fps} -i templates/redditbottom.png -i templates/redditbg.png -filter_complex "vstack=inputs=3[transparent];[3:v][transparent]scale2ref[bg][transparent2];[bg][transparent2]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${width}:${reddittop.bitmap.height + height + redditbottom.bitmap.height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "reddit {name} <file>",
            "value": "The kind stranger has arrived."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["emotegame", "emote"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/emote.png -filter_complex "[1:v]scale=${width}/2.5:-1,rotate=-5*PI/180:ow=rotw(-5*PI/180):oh=roth(-5*PI/180):c=0x00000000[emote];[0:v][emote]overlay=x=w/20:y=h/20:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/emote.png -map 0:a? -filter_complex "[1:v]scale=${width}/2.5:-1,rotate=-5*PI/180:ow=rotw(-5*PI/180):oh=roth(-5*PI/180):c=0x00000000[emote];[0:v][emote]overlay=x=w/20:y=h/20:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/emote.png -filter_complex "[1:v]scale=${width}/2.5:-1,rotate=-5*PI/180:ow=rotw(-5*PI/180):oh=roth(-5*PI/180):c=0x00000000[emote];[0:v][emote]overlay=x=w/20:y=h/20:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "emotegame/emote <file>",
            "value": "Applies the Emote Game Logo to the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["removebg"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]

            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                request.get({
                                    url: 'https://api.remove.bg/v1.0/account',
                                    headers: {
                                        'X-Api-Key': process.env.REMOVEBGKEY
                                    }
                                }, async (_, __, body) => {
                                    body = JSON.parse(body)
                                    var free_calls = Number(body.data.attributes.api.free_calls)
                                    request.post({
                                        url: 'https://api.remove.bg/v1.0/removebg',
                                        formData: {
                                            image_url: currenturl,
                                            size: 'auto',
                                        },
                                        headers: {
                                            'X-Api-Key': process.env.REMOVEBGKEY
                                        },
                                        encoding: null
                                    }, async (error, response, body) => {
                                        if (error) {
                                            msg.channel.send(error.message, {
                                                allowedMentions: {
                                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                            msg.channel.stopTyping(true)
                                            return
                                        };
                                        if (response.statusCode != 200) {
                                            JSON.parse(body).errors.forEach(error => {
                                                msg.channel.send(error.title + (response.statusCode == 402 && '. You can go to https://www.remove.bg/ and upload an image manually though.' || '')).catch(() => { })
                                            })
                                            msg.channel.stopTyping(true)
                                            return
                                        };
                                        var currentcount = filecount
                                        filecount = filecount + 1
                                        fs.mkdirSync(`temp/file${currentcount}`)
                                        fs.writeFileSync(`temp/file${currentcount}/output.png`, body);
                                        var fileMsg = await msg.channel.send(`Available command usages: **${free_calls - 1}**`, {
                                            files: [new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)]
                                        }).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.png`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(`Available command usages: **${free_calls - 1}**\n${fileLink}`).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "removebg <image>",
            "value": "Removes an image's background with remove.bg."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["backrooms", "backroom"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/backrooms.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/backrooms.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 6 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 6 : -1}[frame];[1:v][frame]overlay=x=68-(w/2):y=203-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/backrooms.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/backrooms.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 6 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 6 : -1}[frame];[1:v][frame]overlay=x=68-(w/2):y=203-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/backrooms.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/backrooms.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 6 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 6 : -1}[frame];[1:v][frame]overlay=x=68-(w/2):y=203-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "backrooms/backroom <file>",
            "value": "the arrival"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["higherpitch", "increasepitch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2 ? 2 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]aresample=44100,asetrate=44100*${speed},aresample=44100,atempo=1/${speed}[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]aresample=44100,asetrate=44100*${speed},aresample=44100,atempo=1/${speed}[a]" -map "[a]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "higherpitch/increasepitch [-pitch <number (from 1 to 2)>] <video/audio>",
            "value": "Increases the video's pitch. Default is 2."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["lowerpitch", "decreasepitch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]aresample=44100,asetrate=44100/${speed},aresample=44100,atempo=${speed}[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]aresample=44100,asetrate=44100/${speed},aresample=44100,atempo=${speed}[a]" -map "[a]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "lowerpitch [-pitch <number (from 1 to 6)>] <video/audio>",
            "value": "Lowers the video's pitch. Default is 2."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["bassy", "bass", "lowpass"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]lowpass=f=500[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]lowpass=f=500[a]" -map "[a]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "<:newpoopy:839191885310066729> bassy/bass/lowpass <video/audio>",
            "value": "Makes the video's audio bassy."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["trebling", "treble", "highpass"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]highpass=f=500[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]highpass=f=500[a]" -map "[a]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "<:newpoopy:839191885310066729> trebling/treble/highpass <video/audio>",
            "value": "Makes the video's audio treble."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["setfps"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var fps = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 1 ? 1 : Number(args[1]) || undefined
            if (fps === undefined) {
                msg.channel.send('What is the FPS?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p -r ${fps} temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r ${fps} temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "setfps <fps> <video/gif>",
            "value": "Sets the file's FPS to <fps>."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["meme"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var size = 1
            var sizeindex = args.indexOf('-size')
            if (sizeindex > -1) {
                size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
            }
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""', '""']
            } else if (!matchedTextes[1]) {
                matchedTextes[1] = '""'
            }
            var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var text2 = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var transparent = await Jimp.read('templates/transparent.png')
                                            var impact = await Jimp.loadFont('templates/fonts/Impact/Impact.fnt')
                                            transparent.resize(width, height)
                                            transparent.resize(Math.round(2000 * (1 / size)), Jimp.AUTO)
                                            var transparent2 = transparent.clone()
                                            transparent.print(impact, 20, 20, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                                            transparent2.print(impact, 20, 20, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                                            transparent.resize(width, height)
                                            transparent2.resize(width, height)
                                            transparent.write(`temp/file${currentcount}/caption.png`)
                                            transparent2.write(`temp/file${currentcount}/caption2.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/caption.png -i temp/file${currentcount}/caption2.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[caption];[caption][2:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var transparent = await Jimp.read('templates/transparent.png')
                                                var impact = await Jimp.loadFont('templates/fonts/Impact/Impact.fnt')
                                                transparent.resize(width, height)
                                                transparent.resize(Math.round(2000 * (1 / size)), Jimp.AUTO)
                                                var transparent2 = transparent.clone()
                                                transparent.print(impact, 20, 20, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                                                transparent2.print(impact, 20, 20, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                                                transparent.resize(width, height)
                                                transparent2.resize(width, height)
                                                transparent.write(`temp/file${currentcount}/caption.png`)
                                                transparent2.write(`temp/file${currentcount}/caption2.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/caption.png -r ${fps} -i temp/file${currentcount}/caption2.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[caption];[caption][2:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var transparent = await Jimp.read('templates/transparent.png')
                                                var impact = await Jimp.loadFont('templates/fonts/Impact/Impact.fnt')
                                                transparent.resize(width, height)
                                                transparent.resize(Math.round(2000 * (1 / size)), Jimp.AUTO)
                                                var transparent2 = transparent.clone()
                                                transparent.print(impact, 20, 20, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                                                transparent2.print(impact, 20, 20, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                                                transparent.resize(width, height)
                                                transparent2.resize(width, height)
                                                transparent.write(`temp/file${currentcount}/caption.png`)
                                                transparent2.write(`temp/file${currentcount}/caption2.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/caption.png -r ${fps} -i temp/file${currentcount}/caption2.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[caption];[caption][2:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "meme \"{topText}\" \"[bottomText]\" <file> [-size <multiplier (from 0.5 to 5)>]",
            "value": "Adds a meme caption to the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["meme2", "demotivator", "motivator"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""', '""']
            } else if (!matchedTextes[1]) {
                matchedTextes[1] = '""'
            }
            var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var text2 = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var black = await Jimp.read('templates/black.png')
                                            var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBig/TimesNewRomanBig.fnt')
                                            var arial = await Jimp.loadFont('templates/fonts/ArialSmallWhite/ArialSmallWhite.fnt')
                                            black.resize(width, height)
                                            black.resize(400, Jimp.AUTO)
                                            var whiteborder = black.clone()
                                            var blackborder = black.clone()
                                            var textblack = black.clone()
                                            var text2black = black.clone()
                                            var bottomblack = black.clone()
                                            var bgblack = black.clone()
                                            whiteborder.invert()
                                            whiteborder.resize(whiteborder.bitmap.width + 8, whiteborder.bitmap.height + 8)
                                            blackborder.resize(blackborder.bitmap.width + 4, blackborder.bitmap.height + 4)
                                            black.resize(500, black.bitmap.height + 60)
                                            black.composite(whiteborder, black.bitmap.width / 2 - whiteborder.bitmap.width / 2, black.bitmap.height / 2 - whiteborder.bitmap.height / 2)
                                            black.composite(blackborder, black.bitmap.width / 2 - blackborder.bitmap.width / 2, black.bitmap.height / 2 - blackborder.bitmap.height / 2)
                                            black.write(`temp/file${currentcount}/border.png`)
                                            var textheight = Jimp.measureTextHeight(tnr, text, 500 - 40)
                                            textblack.resize(500, textheight)
                                            textblack.print(tnr, 20, 0, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, textblack.bitmap.width - 40, textblack.bitmap.height)
                                            var text2height = Jimp.measureTextHeight(arial, text2, 500 - 40)
                                            text2black.resize(500, text2height + 10)
                                            text2black.print(arial, 20, 5, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, text2black.bitmap.width - 40, text2black.bitmap.height - 10)
                                            bottomblack.resize(500, 20)
                                            bgblack.resize(500, textblack.bitmap.height + text2black.bitmap.height + bottomblack.bitmap.height)
                                            bgblack.composite(textblack, 0, 0)
                                            bgblack.composite(text2black, 0, textblack.bitmap.height)
                                            bgblack.composite(bottomblack, 0, textblack.bitmap.height + text2black.bitmap.height)
                                            bgblack.write(`temp/file${currentcount}/captions.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/border.png -filter_complex "[0:v]scale=400:-1[scaled];[1:v][scaled]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/frame.png`, async () => {
                                                exec(`ffmpeg -i temp/file${currentcount}/frame.png -i temp/file${currentcount}/captions.png -filter_complex "vstack=inputs=2[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var black = await Jimp.read('templates/black.png')
                                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBig/TimesNewRomanBig.fnt')
                                                var arial = await Jimp.loadFont('templates/fonts/ArialSmallWhite/ArialSmallWhite.fnt')
                                                black.resize(width, height)
                                                black.resize(400, Jimp.AUTO)
                                                var whiteborder = black.clone()
                                                var blackborder = black.clone()
                                                var textblack = black.clone()
                                                var text2black = black.clone()
                                                var bottomblack = black.clone()
                                                var bgblack = black.clone()
                                                whiteborder.invert()
                                                whiteborder.resize(whiteborder.bitmap.width + 8, whiteborder.bitmap.height + 8)
                                                blackborder.resize(blackborder.bitmap.width + 4, blackborder.bitmap.height + 4)
                                                black.resize(500, black.bitmap.height + 60)
                                                black.composite(whiteborder, black.bitmap.width / 2 - whiteborder.bitmap.width / 2, black.bitmap.height / 2 - whiteborder.bitmap.height / 2)
                                                black.composite(blackborder, black.bitmap.width / 2 - blackborder.bitmap.width / 2, black.bitmap.height / 2 - blackborder.bitmap.height / 2)
                                                black.write(`temp/file${currentcount}/border.png`)
                                                var textheight = Jimp.measureTextHeight(tnr, text, 500 - 40)
                                                textblack.resize(500, textheight)
                                                textblack.print(tnr, 20, 0, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, textblack.bitmap.width - 40, textblack.bitmap.height)
                                                var text2height = Jimp.measureTextHeight(arial, text2, 500 - 40)
                                                text2black.resize(500, text2height + 10)
                                                text2black.print(arial, 20, 5, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, text2black.bitmap.width - 40, text2black.bitmap.height - 10)
                                                bottomblack.resize(500, 20)
                                                bgblack.resize(500, textblack.bitmap.height + text2black.bitmap.height + bottomblack.bitmap.height)
                                                bgblack.composite(textblack, 0, 0)
                                                bgblack.composite(text2black, 0, textblack.bitmap.height)
                                                bgblack.composite(bottomblack, 0, textblack.bitmap.height + text2black.bitmap.height)
                                                bgblack.write(`temp/file${currentcount}/captions.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/border.png -map 0:a? -filter_complex "[0:v]scale=400:-1[scaled];[1:v][scaled]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/frame.mp4`, async () => {
                                                    exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/frame.mp4 -r ${fps} -i temp/file${currentcount}/captions.png -map 0:a? -filter_complex "vstack=inputs=2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var black = await Jimp.read('templates/black.png')
                                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBig/TimesNewRomanBig.fnt')
                                                var arial = await Jimp.loadFont('templates/fonts/ArialSmallWhite/ArialSmallWhite.fnt')
                                                black.resize(width, height)
                                                black.resize(400, Jimp.AUTO)
                                                var whiteborder = black.clone()
                                                var blackborder = black.clone()
                                                var textblack = black.clone()
                                                var text2black = black.clone()
                                                var bottomblack = black.clone()
                                                var bgblack = black.clone()
                                                whiteborder.invert()
                                                whiteborder.resize(whiteborder.bitmap.width + 8, whiteborder.bitmap.height + 8)
                                                blackborder.resize(blackborder.bitmap.width + 4, blackborder.bitmap.height + 4)
                                                black.resize(500, black.bitmap.height + 60)
                                                black.composite(whiteborder, black.bitmap.width / 2 - whiteborder.bitmap.width / 2, black.bitmap.height / 2 - whiteborder.bitmap.height / 2)
                                                black.composite(blackborder, black.bitmap.width / 2 - blackborder.bitmap.width / 2, black.bitmap.height / 2 - blackborder.bitmap.height / 2)
                                                black.write(`temp/file${currentcount}/border.png`)
                                                var textheight = Jimp.measureTextHeight(tnr, text, 500 - 40)
                                                textblack.resize(500, textheight)
                                                textblack.print(tnr, 20, 0, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, textblack.bitmap.width - 40, textblack.bitmap.height)
                                                var text2height = Jimp.measureTextHeight(arial, text2, 500 - 40)
                                                text2black.resize(500, text2height + 10)
                                                text2black.print(arial, 20, 5, { text: text2, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, text2black.bitmap.width - 40, text2black.bitmap.height - 10)
                                                bottomblack.resize(500, 20)
                                                bgblack.resize(500, textblack.bitmap.height + text2black.bitmap.height + bottomblack.bitmap.height)
                                                bgblack.composite(textblack, 0, 0)
                                                bgblack.composite(text2black, 0, textblack.bitmap.height)
                                                bgblack.composite(bottomblack, 0, textblack.bitmap.height + text2black.bitmap.height)
                                                bgblack.write(`temp/file${currentcount}/captions.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/border.png -filter_complex "[0:v]scale=400:-1[scaled];[1:v][scaled]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/frame.gif`, async () => {
                                                    exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/frame.gif -r ${fps} -i temp/file${currentcount}/captions.png -filter_complex "vstack=inputs=2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "meme2/demotivator/motivator \"{topText}\" \"[bottomText]\" <file>",
            "value": "Adds a demotivator caption to the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["meme3"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""']
            }
            var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            if (text.length >= 400) {
                msg.channel.send('holy crap that caption is so long it might crash the bot').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var white = await Jimp.read('templates/white.png')
                                            var futura = await Jimp.loadFont('templates/fonts/FuturaCondensed/FuturaCondensed.fnt')
                                            white.resize(width, height)
                                            white.resize(2000, Jimp.AUTO)
                                            var textheight = Jimp.measureTextHeight(futura, text, 2000 - 160)
                                            white.resize(2000, textheight + 160)
                                            white.print(futura, 80, 80, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, white.bitmap.width - 160, white.bitmap.height - 160)
                                            white.resize(width, Jimp.AUTO)
                                            white.write(`temp/file${currentcount}/caption.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/caption.png -i temp/file${currentcount}/input.${type.ext} -filter_complex "vstack=inputs=2[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var white = await Jimp.read('templates/white.png')
                                                var futura = await Jimp.loadFont('templates/fonts/FuturaCondensed/FuturaCondensed.fnt')
                                                white.resize(width, height)
                                                white.resize(2000, Jimp.AUTO)
                                                var textheight = Jimp.measureTextHeight(futura, text, 2000 - 160)
                                                white.resize(2000, textheight + 160)
                                                white.print(futura, 80, 80, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, white.bitmap.width - 160, white.bitmap.height - 160)
                                                white.resize(width, Jimp.AUTO)
                                                white.write(`temp/file${currentcount}/caption.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/caption.png -r ${fps} -i temp/file${currentcount}/input.${type.ext} -map 1:a? -filter_complex "vstack=inputs=2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var white = await Jimp.read('templates/white.png')
                                                var futura = await Jimp.loadFont('templates/fonts/FuturaCondensed/FuturaCondensed.fnt')
                                                white.resize(width, height)
                                                white.resize(2000, Jimp.AUTO)
                                                var textheight = Jimp.measureTextHeight(futura, text, 2000 - 160)
                                                white.resize(2000, textheight + 160)
                                                white.print(futura, 80, 80, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, white.bitmap.width - 160, white.bitmap.height - 160)
                                                white.resize(width, Jimp.AUTO)
                                                white.write(`temp/file${currentcount}/caption.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/caption.png -r ${fps} -i temp/file${currentcount}/input.${type.ext} -filter_complex "vstack=inputs=2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "meme3 \"{text}\" <file>",
            "value": "Adds a white box caption to the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["stuff"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""']
            }
            var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            if (text.length >= 800) {
                msg.channel.send('holy crap that caption is so long it might crash the bot').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var stuff = await Jimp.read('templates/stuff.png')
                                            var caption = stuff
                                            var white = await Jimp.read('templates/white.png')
                                            var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBlack/TimesNewRomanBlack.fnt')
                                            var textheight = Jimp.measureTextHeight(tnr, text, 643)
                                            if (textheight > stuff.bitmap.height - 120) {
                                                caption = white
                                                white.resize(stuff.bitmap.width, textheight + 120)
                                                white.composite(stuff, 0, white.bitmap.height - stuff.bitmap.height)
                                            }
                                            caption.print(tnr, 60, 60, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 643, caption.bitmap.height - 120)
                                            caption.resize(width, Jimp.AUTO)
                                            caption.write(`temp/file${currentcount}/stuff.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/stuff.png -filter_complex "vstack=inputs=2[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var stuff = await Jimp.read('templates/stuff.png')
                                                var caption = stuff
                                                var white = await Jimp.read('templates/white.png')
                                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBlack/TimesNewRomanBlack.fnt')
                                                var textheight = Jimp.measureTextHeight(tnr, text, 643)
                                                if (textheight > stuff.bitmap.height - 120) {
                                                    caption = white
                                                    white.resize(stuff.bitmap.width, textheight + 120)
                                                    white.composite(stuff, 0, white.bitmap.height - stuff.bitmap.height)
                                                }
                                                caption.print(tnr, 60, 60, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 643, caption.bitmap.height - 120)
                                                caption.resize(width, Jimp.AUTO)
                                                caption.write(`temp/file${currentcount}/stuff.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/stuff.png -map 0:a? -filter_complex "vstack=inputs=2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var stuff = await Jimp.read('templates/stuff.png')
                                                var caption = stuff
                                                var white = await Jimp.read('templates/white.png')
                                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBlack/TimesNewRomanBlack.fnt')
                                                var textheight = Jimp.measureTextHeight(tnr, text, 643)
                                                if (textheight > stuff.bitmap.height - 120) {
                                                    caption = white
                                                    white.resize(stuff.bitmap.width, textheight + 120)
                                                    white.composite(stuff, 0, white.bitmap.height - stuff.bitmap.height)
                                                }
                                                caption.print(tnr, 60, 60, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 643, caption.bitmap.height - 120)
                                                caption.resize(width, Jimp.AUTO)
                                                caption.write(`temp/file${currentcount}/stuff.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/stuff.png -filter_complex "vstack=inputs=2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "stuff \"{text}\" <file>",
            "value": "I'm stuff"
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["snapchat"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""']
            }
            var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var snapchat = await Jimp.read('templates/snapchat.png')
                                            var helvetica = await Jimp.loadFont('templates/fonts/Helvetica/Helvetica.fnt')
                                            snapchat.resize(width, height)
                                            snapchat.resize(Jimp.AUTO, 2000)
                                            var textheight = Jimp.measureTextHeight(helvetica, text, snapchat.bitmap.width - 100)
                                            snapchat.resize(snapchat.bitmap.width, textheight + 100)
                                            snapchat.print(helvetica, 50, 50, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, snapchat.bitmap.width - 100, snapchat.bitmap.height - 100)
                                            snapchat.resize(width, Jimp.AUTO)
                                            snapchat.write(`temp/file${currentcount}/caption.png`)

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/caption.png -filter_complex "[0:v][1:v]overlay=x=(W-w)/2:y=H/5*4-h/2:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var snapchat = await Jimp.read('templates/snapchat.png')
                                                var helvetica = await Jimp.loadFont('templates/fonts/Helvetica/Helvetica.fnt')
                                                snapchat.resize(width, height)
                                                snapchat.resize(Jimp.AUTO, 2000)
                                                var textheight = Jimp.measureTextHeight(helvetica, text, snapchat.bitmap.width - 100)
                                                snapchat.resize(snapchat.bitmap.width, textheight + 100)
                                                snapchat.print(helvetica, 50, 50, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, snapchat.bitmap.width - 100, snapchat.bitmap.height - 100)
                                                snapchat.resize(width, Jimp.AUTO)
                                                snapchat.write(`temp/file${currentcount}/caption.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/caption.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=(W-w)/2:y=H/5*4-h/2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, async (_, scale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var snapchat = await Jimp.read('templates/snapchat.png')
                                                var helvetica = await Jimp.loadFont('templates/fonts/Helvetica/Helvetica.fnt')
                                                snapchat.resize(width, height)
                                                snapchat.resize(Jimp.AUTO, 2000)
                                                var textheight = Jimp.measureTextHeight(helvetica, text, snapchat.bitmap.width - 100)
                                                snapchat.resize(snapchat.bitmap.width, textheight + 100)
                                                snapchat.print(helvetica, 50, 50, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, snapchat.bitmap.width - 100, snapchat.bitmap.height - 100)
                                                snapchat.resize(width, Jimp.AUTO)
                                                snapchat.write(`temp/file${currentcount}/caption.png`)

                                                exec(`ffmpeg -r ${fps} -i temp/file${currentcount}/input.${type.ext} -r ${fps} -i temp/file${currentcount}/caption.png -filter_complex "[0:v][1:v]overlay=x=(W-w)/2:y=H/5*4-h/2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "snapchat \"{text}\" <file>",
            "value": "Adds a Snapchat caption to the file."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["speedup", "speed"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                                if (audio) {
                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]fps=fps=${fps}*${speed},setpts=(1/${speed})*PTS,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]atempo=${speed}[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                } else {
                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]fps=fps=${fps}*${speed},setpts=(1/${speed})*PTS,scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                }
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]atempo=${speed}[a]" -map "[a]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]fps=fps='min(50,${fps}*${speed})',setpts=(1/${speed})*PTS,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "speedup/speed [speed (from 1 to 6)] <file>",
            "value": "Speeds up the file by [speed]. Default is 2."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["trim", "cut"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, duration) => {
                                            duration = Number(duration.replace(/\n|\r/g, ''))
                                            var start = 0
                                            var startindex = args.indexOf('-start')
                                            if (startindex > -1) {
                                                start = isNaN(Number(args[startindex + 1])) ? 0 : Number(args[startindex + 1]) <= 0 ? 0 : Number(args[startindex + 1]) >= duration ? duration : Number(args[startindex + 1]) || 0
                                            }
                                            var end = duration
                                            var endindex = args.indexOf('-end')
                                            if (endindex > -1) {
                                                end = isNaN(Number(args[endindex + 1])) ? duration : Number(args[endindex + 1]) <= 0 ? 0 : Number(args[endindex + 1]) >= duration ? duration : Number(args[endindex + 1]) || duration
                                            }
                                            if (end <= start) {
                                                end = start
                                            }

                                            exec(`ffmpeg -ss ${start} -t ${end - start} -i temp/file${currentcount}/input.${type.ext} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams a -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, duration) => {
                                            duration = Number(duration.replace(/\n|\r/g, ''))
                                            var start = 0
                                            var startindex = args.indexOf('-start')
                                            if (startindex > -1) {
                                                start = isNaN(Number(args[startindex + 1])) ? 0 : Number(args[startindex + 1]) <= 0 ? 0 : Number(args[startindex + 1]) >= duration ? duration : Number(args[startindex + 1]) || 0
                                            }
                                            var end = duration
                                            var endindex = args.indexOf('-end')
                                            if (endindex > -1) {
                                                end = isNaN(Number(args[endindex + 1])) ? duration : Number(args[endindex + 1]) <= 0 ? 0 : Number(args[endindex + 1]) >= duration ? duration : Number(args[endindex + 1]) || duration
                                            }
                                            if (end <= start) {
                                                end = start
                                            }

                                            exec(`ffmpeg -ss ${start} -t ${end - start} -i temp/file${currentcount}/input.${type.ext} -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, duration) => {
                                            duration = Number(duration.replace(/\n|\r/g, ''))
                                            var start = 0
                                            var startindex = args.indexOf('-start')
                                            if (startindex > -1) {
                                                start = isNaN(Number(args[startindex + 1])) ? 0 : Number(args[startindex + 1]) <= 0 ? 0 : Number(args[startindex + 1]) >= duration ? duration : Number(args[startindex + 1]) || 0
                                            }
                                            var end = duration
                                            var endindex = args.indexOf('-end')
                                            if (endindex > -1) {
                                                end = isNaN(Number(args[endindex + 1])) ? duration : Number(args[endindex + 1]) <= 0 ? 0 : Number(args[endindex + 1]) >= duration ? duration : Number(args[endindex + 1]) || duration
                                            }
                                            if (end <= start) {
                                                end = start
                                            }

                                            exec(`ffmpeg -ss ${start} -t ${end - start} -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "<:newpoopy:839191885310066729> trim/cut [-start <timestamp (by seconds)>] [-end <timestamp (by seconds)>] <file>",
            "value": "Trims the file from the start timestamp and the end timestamp."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["slowdown", "slow"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
            var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2 ? 2 : Number(args[1]) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                                if (audio) {
                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps=${fps}/${speed},scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]atempo=(1/${speed})[a]" -map "[v]" -map "[a]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                } else {
                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps=${fps}/${speed},scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                }
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:a]atempo=(1/${speed})[a]" -map "[a]" -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, async (_, fps) => {
                                            fps = fps.replace(/\n|\r/g, '')

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps=${fps}/${speed},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "slowdown/slow [speed (from 1 to 2)] <file>",
            "value": "Slows down the file by [speed]. Default is 2."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["skin"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/skin.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 210 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 210 : -1}[frame];[1:v][frame]overlay=x=274-(w/2):y=360-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/skin.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 210 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 210 : -1}[frame];[1:v][frame]overlay=x=274-(w/2):y=360-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/skin.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 210 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 210 : -1}[frame];[1:v][frame]overlay=x=274-(w/2):y=360-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "skin <file>",
            "value": "NOOOO GET OUT OF THERE"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["heaven"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/heaven.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/heaven.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.75-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/heaven.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/heaven.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.75-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/heaven.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/heaven.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.75-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "heaven <file>",
            "value": "they get sent to heaven"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hell"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/hell.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/hell.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.2-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/hell.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/hell.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.2-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/hell.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/hell.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.2-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "hell <file>",
            "value": "they get sent to hell"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["rap", "fnf", "friday"],
        execute: async function (msg, args) {
            const rapping = [
                {
                    name: "1",
                    position: [109, 101],
                    angle: -3
                },
                {
                    name: "2",
                    position: [114, 102],
                    angle: -1
                },
                {
                    name: "3",
                    position: [128, 102],
                    angle: 9
                },
                {
                    name: "4",
                    position: [123, 106],
                    angle: 5
                },
                {
                    name: "5",
                    position: [122, 98],
                    angle: -14
                },
                {
                    name: "6",
                    position: [119, 100],
                    angle: -9
                },
                {
                    name: "7",
                    position: [109, 103],
                    angle: 10
                },
                {
                    name: "8",
                    position: [110, 102],
                    angle: 6
                }
            ]
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/frames`)
                                for (var i = 0; i < rapping.length; i++) {
                                    var rapFrame = rapping[i]
                                    var frame = await Jimp.read(currenturl)
                                    var rap = await Jimp.read(`templates/rapping/${rapFrame.name}.png`)
                                    var rapm = await Jimp.read(`templates/rappingmask/${rapFrame.name}.png`)
                                    var stage = await Jimp.read(`templates/stage.png`)
                                    var transparent = await Jimp.read(`templates/transparent.png`)
                                    var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                                    frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 70 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 70 : Jimp.AUTO)
                                    frame.rotate(rapFrame.angle)
                                    transparent.resize(stage.bitmap.width, stage.bitmap.height)
                                    transparent.composite(frame, rapFrame.position[0] - frame.bitmap.width / 2, rapFrame.position[1] - frame.bitmap.height + 10)
                                    transparent.mask(rapm, 0, 0)
                                    rap.composite(transparent, 0, 0)
                                    stage.composite(rap, 0, 0)
                                    stage.write(`temp/file${currentcount}/frames/${rapFrame.name}.png`)
                                }
                                exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -vf palettegen=reserve_transparent=1 temp/file${currentcount}/palette.png`, () => {
                                    exec(`ffmpeg -r 25/2 -i temp/file${currentcount}/frames/%d.png -i temp/file${currentcount}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/frames`)
                                exec(`ffmpeg -i ${currenturl} -vframes 1 temp/file${currentcount}/output.png`, async () => {
                                    for (var i = 0; i < rapping.length; i++) {
                                        var rapFrame = rapping[i]
                                        var frame = await Jimp.read(`temp/file${currentcount}/output.png`)
                                        var rap = await Jimp.read(`templates/rapping/${rapFrame.name}.png`)
                                        var rapm = await Jimp.read(`templates/rappingmask/${rapFrame.name}.png`)
                                        var stage = await Jimp.read(`templates/stage.png`)
                                        var transparent = await Jimp.read(`templates/transparent.png`)
                                        var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                                        frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 70 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 70 : Jimp.AUTO)
                                        frame.rotate(rapFrame.angle)
                                        transparent.resize(stage.bitmap.width, stage.bitmap.height)
                                        transparent.composite(frame, rapFrame.position[0] - frame.bitmap.width / 2, rapFrame.position[1] - frame.bitmap.height + 10)
                                        transparent.mask(rapm, 0, 0)
                                        rap.composite(transparent, 0, 0)
                                        stage.composite(rap, 0, 0)
                                        stage.write(`temp/file${currentcount}/frames/${rapFrame.name}.png`)
                                    }
                                    exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -vf palettegen=reserve_transparent=1 temp/file${currentcount}/palette.png`, () => {
                                        exec(`ffmpeg -r 25/2 -i temp/file${currentcount}/frames/%d.png -i temp/file${currentcount}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "rap/fnf/friday <file>",
            "value": "when i'm funny Rapping !!!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["choicegif"],
        execute: async function (msg, args) {
            const gifframes = [
                {
                    name: '{text}',
                    filename: '1.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'blue',
                                params: [-255]
                            },

                            {
                                apply: 'green',
                                params: [-255]
                            }
                        ])
                    },
                    name: 'Red {text}',
                    filename: '2.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'blue',
                                params: [-255]
                            },

                            {
                                apply: 'red',
                                params: [-255]
                            }
                        ])
                    },
                    name: 'Green {text}',
                    filename: '3.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'red',
                                params: [-255]
                            },

                            {
                                apply: 'green',
                                params: [-255]
                            }
                        ])
                    },
                    name: 'Blue {text}',
                    filename: '4.png'
                },

                {
                    edit: async function (frame) {
                        frame.convolute([
                            [-2, -1, 0],
                            [-1, 1, 1],
                            [0, 1, 2]
                        ])
                    },
                    name: 'MUGEN {text}',
                    filename: '5.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                    },
                    name: '50\'s {text}',
                    filename: '6.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width / 6, frame.bitmap.height / 6)
                    },
                    name: 'Tiny {text}',
                    filename: '7.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width * 3, frame.bitmap.height * 3)
                    },
                    name: 'Giant {text}',
                    filename: '8.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width / 4, frame.bitmap.height / 4, Jimp.RESIZE_NEAREST_NEIGHBOR)
                        frame.resize(frame.bitmap.width * 4, frame.bitmap.height * 4, Jimp.RESIZE_NEAREST_NEIGHBOR)
                    },
                    name: '8-bit {text}',
                    filename: '9.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width / 6, frame.bitmap.height / 6)
                        frame.resize(frame.bitmap.width * 6, frame.bitmap.height * 6)
                    },
                    name: 'Crunchy {text}',
                    filename: '10.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'green',
                                params: [-100]
                            },

                            {
                                apply: 'red',
                                params: [-100]
                            },

                            {
                                apply: 'blue',
                                params: [-100]
                            }
                        ])
                    },
                    name: 'Nightmare {text}',
                    filename: '11.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'green',
                                params: [70]
                            },

                            {
                                apply: 'red',
                                params: [70]
                            },

                            {
                                apply: 'blue',
                                params: [70]
                            }
                        ])
                    },
                    name: 'Ghost {text}',
                    filename: '12.png'
                },

                {
                    edit: async function (frame) {
                        frame.convolute([
                            [0, -1, 0],
                            [-1, 4, -1],
                            [0, -1, 0]
                        ])
                        frame.convolute([
                            [0, -1, 0],
                            [-1, 4, -1],
                            [0, -1, 0]
                        ])
                    },
                    name: 'what',
                    filename: '13.png'
                },

                {
                    edit: async function (frame) {
                        frame.convolute([
                            [-1, -1, -1],
                            [-1, 9, -1],
                            [-1, -1, -1]
                        ])
                        frame.convolute([
                            [-1, -1, -1],
                            [-1, 9, -1],
                            [-1, -1, -1]
                        ])
                    },
                    name: 'Distorted {text}',
                    filename: '14.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.contrast(1)
                    },
                    name: 'Silhouette {text}',
                    filename: '15.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width / 40, frame.bitmap.height / 40)
                    },
                    name: '{text} Bacteria',
                    filename: '16.png'
                },

                {
                    edit: async function (frame) {
                        frame.invert()
                    },
                    name: 'Inverted {text}',
                    filename: '17.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width, frame.bitmap.height / 4)
                    },
                    name: 'Squashed {text}',
                    filename: '18.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width, frame.bitmap.height * 4)
                    },
                    name: 'hi',
                    filename: '19.png'
                },

                {
                    edit: async function (frame) {
                        frame.color([
                            {
                                apply: 'green',
                                params: [255]
                            },
                        ])
                    },
                    name: 'Nuclear {text}',
                    filename: '20.png'
                },

                {
                    edit: async function (frame) {
                        frame.contrast(0.9)
                    },
                    name: '{text} Fry',
                    filename: '21.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'blue',
                                params: [-255]
                            },

                            {
                                apply: 'green',
                                params: [-100]
                            }
                        ])
                    },
                    name: 'Hot {text}',
                    filename: '22.png'
                },

                {
                    edit: async function (frame) {
                        frame.greyscale()
                        frame.color([
                            {
                                apply: 'red',
                                params: [-255]
                            },

                            {
                                apply: 'green',
                                params: [-100]
                            }
                        ])
                    },
                    name: 'Cold {text}',
                    filename: '23.png'
                },

                {
                    edit: async function (frame) {
                        frame.blur(5)
                    },
                    name: 'Blurred {text}',
                    filename: '24.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width * 12, frame.bitmap.height * 12)
                    },
                    name: 'Island-sized {text}',
                    filename: '25.png'
                },

                {
                    edit: async function (frame) {
                        frame.resize(frame.bitmap.width, 1, Jimp.RESIZE_NEAREST_NEIGHBOR)
                        frame.resize(frame.bitmap.width, 500, Jimp.RESIZE_NEAREST_NEIGHBOR)
                    },
                    name: '{text}\n{text}\n{text}\n{text}\n{text}\n{text}\n{text}',
                    filename: '26.png'
                },

                {
                    edit: async function (frame) {
                        var stripes = await Jimp.read('templates/stripes.png')
                        frame.greyscale()
                        stripes.resize(frame.bitmap.width, frame.bitmap.height)
                        frame.composite(stripes, 0, 0)
                        frame.convolute([
                            [0, -1, 0],
                            [-1, 4, -1],
                            [0, -1, 0]
                        ])
                    },
                    name: 'The Anonymous {text}',
                    filename: '27.png'
                },

                {
                    edit: async function (frame) {
                        var jail = await Jimp.read('templates/jailed.png')
                        jail.resize(frame.bitmap.width, frame.bitmap.height)
                        frame.composite(jail, 0, 0)
                    },
                    name: 'Jailed {text}',
                    filename: '28.png'
                },
            ]
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/frames`)
                                for (var i = 0; i < gifframes.length; i++) {
                                    var framedata = gifframes[i]
                                    var frame = await Jimp.read(currenturl)
                                    var white = await Jimp.read(`templates/white.png`)
                                    var arialsmall = await Jimp.loadFont('templates/fonts/ArialSmall/ArialSmall.fnt')
                                    var arialbig = await Jimp.loadFont('templates/fonts/ArialBig/ArialBig.fnt')
                                    var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                                    frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 180 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 180 : Jimp.AUTO)
                                    white.resize(304, 361)
                                    if (framedata.edit) {
                                        await framedata.edit(frame)
                                    }
                                    white.composite(frame, white.bitmap.width / 2 - frame.bitmap.width / 2, white.bitmap.height / 2 - frame.bitmap.height / 2)
                                    white.print(arialbig, 8, 8, { text: 'Choose your {text}'.replace(/{text}/g, text), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                                    white.print(arialsmall, 8, 280, { text: framedata.name.replace(/{text}/g, text), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                                    white.write(`temp/file${currentcount}/frames/${framedata.filename}`)
                                }
                                exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -vf palettegen=reserve_transparent=1 temp/file${currentcount}/palette.png`, () => {
                                    exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -i temp/file${currentcount}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.mkdirSync(`temp/file${currentcount}/frames`)
                                exec(`ffmpeg -i ${currenturl} -vframes 1 temp/file${currentcount}/output.png`, async () => {
                                    for (var i = 0; i < gifframes.length; i++) {
                                        var framedata = gifframes[i]
                                        var frame = await Jimp.read(`temp/file${currentcount}/output.png`)
                                        var white = await Jimp.read(`templates/white.png`)
                                        var arialsmall = await Jimp.loadFont('templates/fonts/ArialSmall/ArialSmall.fnt')
                                        var arialbig = await Jimp.loadFont('templates/fonts/ArialBig/ArialBig.fnt')
                                        var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                                        frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 180 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 180 : Jimp.AUTO)
                                        white.resize(304, 361)
                                        if (framedata.edit) {
                                            await framedata.edit(frame)
                                        }
                                        white.composite(frame, white.bitmap.width / 2 - frame.bitmap.width / 2, white.bitmap.height / 2 - frame.bitmap.height / 2)
                                        white.print(arialbig, 8, 8, { text: 'Choose your {text}'.replace(/{text}/g, text), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                                        white.print(arialsmall, 8, 280, { text: framedata.name.replace(/{text}/g, text), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                                        white.write(`temp/file${currentcount}/frames/${framedata.filename}`)
                                    }
                                    exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -vf palettegen=reserve_transparent=1 temp/file${currentcount}/palette.png`, () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/frames/%d.png -i temp/file${currentcount}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "choicegif \"{name}\" <file>",
            "value": "Creates one of those \"Choose your fighter\" gifs depending on the selected image."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["bloxys", "bloxy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var gotham = await Jimp.loadFont(`templates/fonts/Gotham/Gotham.fnt`)
                                var bloxys = await Jimp.read('templates/bloxys.png')
                                bloxys.print(gotham, 88, 190, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 221, 33)
                                bloxys.write(`temp/file${currentcount}/bloxy.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/bloxy.png -i templates/bloxys.mp3 -filter_complex "[0:v]scale=219:124[frame];[1:v][frame]overlay=x=89:y=64:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -shortest -map "[out]" -preset ultrafast -map 2:a:0 -c:v libx264 -pix_fmt yuv420p -t 00:00:07.05 -y temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "bloxys/bloxy \"{name}\" <file>",
            "value": "YOU WON A BLOXY!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["favorite"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i templates/favorite.gif -filter_complex "${height >= 212 ? `[1:v]scale=-1:${height >= 300 ? 300 : height}[ckout];` : ''}[${height >= 212 ? `ckout` : `1:v`}]colorkey=0x05FA04:0.3:0.3[jout];[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[lout];[lout][jout]overlay=shortest=1:x=W-w:y=0:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -stream_loop -1 -i templates/favorite.gif -map 0:a? -filter_complex "${height >= 212 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 212 ? `ckout` : `1:v`}]colorkey=0x05FA04:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W-w:y=0:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i templates/favorite.gif -filter_complex "${height >= 212 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 212 ? `ckout` : `1:v`}]colorkey=0x05FA04:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W-w:y=0:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "favorite <file>",
            "value": "Your GIF was favorited over 1000 times!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["playvideo"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i templates/playvideo.mp4 -filter_complex "${height >= 224 ? `[1:v]scale=-1:${height >= 300 ? 300 : height}[ckout];` : ''}[${height >= 224 ? `ckout` : `1:v`}]colorkey=0x66BB24:0.3:0.3[jout];[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[lout];[lout][jout]overlay=shortest=1:x=W/2-w/2:y=H-h:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -stream_loop -1 -i templates/playvideo.mp4 -map 0:a? -filter_complex "${height >= 224 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 224 ? `ckout` : `1:v`}]colorkey=0x66BB24:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H-h:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i templates/playvideo.mp4 -filter_complex "${height >= 224 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 224 ? `ckout` : `1:v`}]colorkey=0x66BB24:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H-h:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "playvideo <file>",
            "value": "Your video was played over 1000 times!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["desktopdestroy", "desktopdestroyer"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i templates/destroy.gif -filter_complex "${height >= 238 ? `[1:v]scale=-1:${height >= 300 ? 300 : height}[ckout];` : ''}[${height >= 238 ? `ckout` : `1:v`}]colorkey=0x00FF01:0.3:0.3[jout];[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[lout];[lout][jout]overlay=shortest=1:x=W/2-w/2:y=H/2-h/2:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -stream_loop -1 -i templates/destroy.gif -map 0:a? -filter_complex "${height >= 238 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 238 ? `ckout` : `1:v`}]colorkey=0x00FF01:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H/2-h/2:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -stream_loop -1 -i temp/file${currentcount}/input.${type.ext} -i templates/destroy.gif -filter_complex "${height >= 238 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 238 ? `ckout` : `1:v`}]colorkey=0x00FF01:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H/2-h/2:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "desktopdestroy/desktopdestroyer <file>",
            "value": "death"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["jumpscare", "fnaf"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var zoomspeed = 1
            var zoomsindex = args.indexOf('-zoomspeed')
            if (zoomsindex > -1) {
                zoomspeed = isNaN(Number(args[zoomsindex + 1])) ? 1 : Number(args[zoomsindex + 1]) <= 0.1 ? 0.1 : Number(args[zoomsindex + 1]) || 1
            }
            var zoomframes = 10
            var zoomfindex = args.indexOf('-zoomframes')
            if (zoomfindex > -1) {
                zoomframes = isNaN(Number(args[zoomfindex + 1])) ? 1 : Number(args[zoomfindex + 1]) <= 1 ? 1 : Number(args[zoomfindex + 1]) >= 300 ? 300 : Math.round(Number(args[zoomfindex + 1])) || 1
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -r 25 -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=-2:10*ih,zoompan=z=zoom+${zoomspeed / 20}:d=${zoomframes}:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)',scale=${width}:${height},scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -y -shortest -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, () => {
                                                exec(`ffmpeg -r 25 -i temp/file${currentcount}/frame.png -filter_complex "[0:v]scale=-2:10*ih,zoompan=z=zoom+${zoomspeed / 20}:d=${zoomframes}:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)',scale=${width}:${height},scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -y -shortest -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "jumpscare/fnaf <file> [-zoomspeed <speed>] [-zoomframes <frames>]",
            "value": "five nights. Default speed is 1 and frames is 10."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["loophole"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -r 25 -i temp/file${currentcount}/input.${type.ext} -stream_loop -1 -t 1 -r 25 -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=-2:10*ih,zoompan=z=zoom+0.25:d=25:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)',scale=${width}:${height}[zoomin];[1:v]scale=${width}*t:${height}*t:eval=frame[overlay];[zoomin][overlay]overlay=x=(W-w)/2:y=(H-h)/2,scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -y -shortest -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vframes 1 temp/file${currentcount}/frame.png`, () => {
                                                exec(`ffmpeg -r 25 -i temp/file${currentcount}/frame.png -stream_loop -1 -t 1 -r 25 -i temp/file${currentcount}/frame.png -filter_complex "[0:v]scale=-2:10*ih,zoompan=z=zoom+0.25:d=25:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)',scale=${width}:${height}[zoomin];[1:v]scale=${width}*t:${height}*t:eval=frame[overlay];[zoomin][overlay]overlay=x=(W-w)/2:y=(H-h)/2,scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -y -shortest -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "loophole <file>",
            "value": "Creates an infinite zooming in loophole with the file."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["bouncy", "bounce", "jumping", "jump"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -r 50 -stream_loop -1 -t 0.25 -i temp/file${currentcount}/input.${type.ext} -r 50 -stream_loop -1 -t 0.25 -i templates/transparent.png -filter_complex "[0:v]scale=100:100:force_original_aspect_ratio=decrease[overlay];[1:v]scale=300:300[transparent];[transparent][overlay]overlay=x=((W-w)/2)-cos(PI/2*(t*8))*100:y=((H-h)/2)-sin(PI/2*(t*8))*100[overlayed];[overlayed]split[normal][reverse];[reverse]reverse[reversed];[normal][reversed]concat,crop=300:200:0:0,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r 50 -t 0.5 temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "bouncy/bounce/jumping/jump <file>",
            "value": "Makes the file bounce around in a transparent background."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["circle"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -r 50 -stream_loop -1 -t 2 -i temp/file${currentcount}/input.${type.ext} -r 50 -stream_loop -1 -t 2 -i templates/transparent.png -filter_complex "[0:v]scale=100:100:force_original_aspect_ratio=decrease[overlay];[1:v]scale=300:300[transparent];[transparent][overlay]overlay=x=((W-w)/2)-cos(PI/2*(t*2))*100:y=((H-h)/2)-sin(PI/2*(t*2))*100,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r 50 -t 2 temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "circle <file>",
            "value": "Makes the file move around in a circle."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["infinity", "boss", "fly"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -r 50 -stream_loop -1 -t 2 -i temp/file${currentcount}/input.${type.ext} -r 50 -stream_loop -1 -t 2 -i templates/transparent.png -filter_complex "[0:v]scale=100:100:force_original_aspect_ratio=decrease[overlay];[1:v]scale=300:300[transparent];[transparent][overlay]overlay=x=((W-w)/2)-cos(PI/2*(t*2))*100:y=((H-h)/2)-sin(PI/2*(t*4))*100,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r 50 -t 2 temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "infinity/boss/fly <file>",
            "value": "Makes the file move around in an infinity symbol, like a boss battle."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["spazz", "shake"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var seed = Math.random() * 1000
            var seedindex = args.indexOf('-seed')
            if (seedindex > -1) {
                seed = isNaN(Number(args[seedindex + 1])) ? Math.random() * 1000 : Number(args[seedindex + 1]) || Math.random() * 1000
            }
            var radius = 300
            var radiusindex = args.indexOf('-radius')
            if (radiusindex > -1) {
                radius = isNaN(Number(args[radiusindex + 1])) ? 300 : Number(args[radiusindex + 1]) <= 100 ? 100 : Number(args[radiusindex + 1]) >= 300 ? 300 : Number(args[radiusindex + 1]) || 300
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -r 50 -stream_loop -1 -t 2 -i temp/file${currentcount}/input.${type.ext} -r 50 -stream_loop -1 -t 2 -i templates/transparent.png -filter_complex "[0:v]scale=100:100:force_original_aspect_ratio=decrease[overlay];[1:v]scale=${radius}:${radius}[transparent];[transparent][overlay]overlay=x=random(t*(random(0)*${seed}))*${radius - 100}:y=random(t*(random(0)*${seed}))*${radius - 100},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r 50 -t 2 temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "<:newpoopy:839191885310066729> spazz/shake <file> [-radius <number (from 100 to 300)>] [-seed <number>]",
            "value": "Makes the file spazz out."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["hankjump", "hank"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -r 50 -stream_loop -1 -t 0.35 -i temp/file${currentcount}/input.${type.ext} -r 50 -stream_loop -1 -t 0.35 -i templates/transparent.png -filter_complex "[0:v]scale=100:100:force_original_aspect_ratio=decrease,split=3[overlay][overlay2][overlay3];[1:v]scale=300:300,split=3[transparent][transparent2][transparent3];[overlay]rotate=sin(PI/2*(t*5.6))*10*PI/180:ow=rotw(45):oh=roth(45):c=0x00000000[roverlay];[overlay2]rotate=sin(PI/2*(t*5.6))*-10*PI/180:ow=rotw(45):oh=roth(45):c=0x00000000[roverlay2];[overlay3]rotate=t*2.8*360*PI/180:ow=rotw(45):oh=roth(45):c=0x00000000[roverlay3];[transparent][roverlay]overlay=x=((W-w)/2)+sin(PI/2*(t*5.6))*5:y=(((H-h)/2)-sin(PI/2*(t*5.6))*100)+100,split=5[jump1_1][jump1_2][jump1_3][jump1_4][jump1_5];[transparent2][roverlay2]overlay=x=((W-w)/2)+sin(PI/2*(t*5.6))*5:y=(((H-h)/2)-sin(PI/2*(t*5.6))*100)+100,split=4[jump2_1][jump2_2][jump2_3][jump2_4];[transparent3][roverlay3]overlay=x=((W-w)/2)+sin(PI/2*(t*5.6))*5:y=(((H-h)/2)-sin(PI/2*(t*5.6))*100)+100[jump3];[jump1_1][jump2_1][jump1_2][jump2_2][jump1_3][jump2_3][jump1_4][jump2_4][jump1_5][jump3]concat=n=10,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting -r 50 temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "<:newpoopy:839191885310066729> hankjump/hank <file>",
            "value": "hank jumping gif"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["rowley", "wimpy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/rowley.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/rowley.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=262:98[frame];[white][frame]overlay=x=80:y=0:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/rowley.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/rowley.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=262:98[frame];[white][frame]overlay=x=80:y=0:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/rowley.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/rowley.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=262:98[frame];[white][frame]overlay=x=80:y=0:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "rowley/wimpy <file>",
            "value": "society:"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["zekk", "zekkriel"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/zekkriel.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/zekkriel.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=108:99[frame];[white][frame]overlay=x=4:y=9:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/zekkriel.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/zekkriel.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=108:99[frame];[white][frame]overlay=x=4:y=9:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/zekkriel.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/zekkriel.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=108:99[frame];[white][frame]overlay=x=4:y=9:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "zekk/zekkriel <file>",
            "value": "Yup!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["bisexual", "bi"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/bisexual.png -filter_complex "[1:v][0:v]scale2ref[bi][frame];[frame][bi]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/bisexual.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[bi][frame];[frame][bi]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/bisexual.png -filter_complex "[1:v][0:v]scale2ref[bi][frame];[frame][bi]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "bisexual/bi <file>",
            "value": "Adds bisexual lighting to the image."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["flip", "fnepp"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/flip.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/flip.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=227:142[frame];[white][frame]overlay=x=255:y=8:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/flip.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/flip.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=227:142[frame];[white][frame]overlay=x=255:y=8:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/flip.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/flip.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=227:142[frame];[white][frame]overlay=x=255:y=8:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "flip/fnepp <file>",
            "value": "Yeah!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["cheeky"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/cheeky.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/cheeky.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=112:66[frame];[white][frame]overlay=x=244:y=74:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/cheeky.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/cheeky.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=112:66[frame];[white][frame]overlay=x=244:y=74:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/cheeky.png`, (_, bscale) => {
                                            bscale = bscale.replace(/\n|\r/g, '').split('x')
                                            var bwidth = Number(bscale[0])
                                            var bheight = Number(bscale[1])

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/cheeky.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=112:66[frame];[white][frame]overlay=x=244:y=74:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "cheeky <file>",
            "value": "BLOODY FUCKING HELL, IT'S SZEMTELEN MANO FROM THE HIT GAME VESZTESEG"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["larry"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/larry.png -i templates/white.png -i templates/transparent.png -filter_complex "[0:v]scale=57:39[frame];[2:v]scale=57:39[white];[3:v][1:v]scale2ref[transparent][larry];[white][frame]overlay=x=0:y=0:format=auto[wframe];[transparent][wframe]overlay=x=187:y=57:format=auto[twframe];[twframe][larry]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/larry.png -i templates/white.png -i templates/transparent.png -map 0:a? -filter_complex "[0:v]scale=57:39[frame];[2:v]scale=57:39[white];[3:v][1:v]scale2ref[transparent][larry];[white][frame]overlay=x=0:y=0:format=auto[wframe];[transparent][wframe]overlay=x=187:y=57:format=auto[twframe];[twframe][larry]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/larry.png -i templates/white.png -i templates/transparent.png -filter_complex "[0:v]scale=57:39[frame];[2:v]scale=57:39[white];[3:v][1:v]scale2ref[transparent][larry];[white][frame]overlay=x=0:y=0:format=auto[wframe];[transparent][wframe]overlay=x=187:y=57:format=auto[twframe];[twframe][larry]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "larry <file>",
            "value": "Step 1: Eat hot chip\nStep 2: Eat hot chip\nStep 3: Eat hot chip"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["crewmate", "amongus", "amogus"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/crewmate.png -i templates/crewmatemask.png -i templates/black.png -filter_complex "[3:v][1:v]scale2ref[black][crewmate];[0:v]scale=${squareS.constraint === 'width' ? -1 : 86}:${squareS.constraint === 'height' ? -1 : 86}[frame];[black][frame]overlay=x=136.5-w/2:y=78-h/2:format=auto[tframe];[tframe][crewmate]overlay=x=0:y=0:format=auto[cout];[cout][2:v]alphamerge[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/crewmate.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bwidth = Number(bscale[0])
                                                var bheight = Number(bscale[1])

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/crewmate.png -i templates/crewmatemaskv.png -i templates/black.png -map 0:a? -filter_complex "[3:v][1:v]scale2ref[black][crewmate];[0:v]scale=${squareS.constraint === 'width' ? -1 : 86}:${squareS.constraint === 'height' ? -1 : 86}[frame];[black][frame]overlay=x=136.5-w/2:y=78-h/2:format=auto[tframe];[tframe][crewmate]overlay=x=0:y=0:format=auto[cout];[cout][2:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/crewmate.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bwidth = Number(bscale[0])
                                                var bheight = Number(bscale[1])

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/crewmate.png -i templates/crewmatemaskg.png -i templates/black.png -filter_complex "[3:v][1:v]scale2ref[black][crewmate];[0:v]scale=${squareS.constraint === 'width' ? -1 : 86}:${squareS.constraint === 'height' ? -1 : 86}[frame];[black][frame]overlay=x=136.5-w/2:y=78-h/2:format=auto[tframe];[tframe][crewmate]overlay=x=0:y=0:format=auto[cout];[cout][2:v]overlay=x=0:y=0:format=auto,colorkey=0x00AC91:0.01:0[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${bwidth}:${bheight} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "crewmate/amongus/amogus <file>",
            "value": "HOP ON AMONG US!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["dumpy", "twerkmosaic", "amongmosaic", "amongusmosaic", "crewmateamosaic"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var resolution = 25
            var resolutionindex = args.indexOf('-resolution')
            if (resolutionindex > -1) {
                resolution = isNaN(Number(args[resolutionindex + 1])) ? 25 : Number(args[resolutionindex + 1]) <= 1 ? 1 : Number(args[resolutionindex + 1]) >= 40 ? 40 : Math.floor(Number(args[resolutionindex + 1])) || 25
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.copyFileSync(`templates/amongUs.jar`, `temp/file${currentcount}/amongUs.jar`)
                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`cd temp/file${currentcount} && java -jar amongUs.jar ${resolution} input.${type.ext}`, async () => {
                                            fs.renameSync(`temp/file${currentcount}/dumpy.gif`, `temp/file${currentcount}/output.gif`)
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "dumpy/twerkmosaic/amongmosaic/amongusmosaic/crewmateamosaic <image> [-resolution <number>]",
            "value": "Fun Fact: poopy has 3 among us related commands (powered by https://github.com/ThatOneCalculator/Among-Us-Dumpy-Gif-Maker)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["tdumpy", "trollfaced", "trollfacedmosaic"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var resolution = 25
            var resolutionindex = args.indexOf('-resolution')
            if (resolutionindex > -1) {
                resolution = isNaN(Number(args[resolutionindex + 1])) ? 25 : Number(args[resolutionindex + 1]) <= 1 ? 1 : Number(args[resolutionindex + 1]) >= 40 ? 40 : Math.floor(Number(args[resolutionindex + 1])) || 25
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.copyFileSync(`templates/trollfaced.jar`, `temp/file${currentcount}/trollfaced.jar`)
                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`cd temp/file${currentcount} && java -jar trollfaced.jar ${resolution} input.${type.ext}`, async () => {
                                            fs.renameSync(`temp/file${currentcount}/dumpy.gif`, `temp/file${currentcount}/output.gif`)
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "tdumpy/trollfaced/trollfacedmosaic <image> [-resolution <number>]",
            "value": "IT? created the trollfaced mosaic (powered by https://github.com/ThatOneCalculator/Among-Us-Dumpy-Gif-Maker)"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["battlecats", "bc"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/battlecats.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${height > (bheight / 1.1) ? -1 : 'iw'}:${height > (bheight / 1.1) ? bheight / 1.3 : 'ih'}[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/scaled.png`, async () => {
                                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/scaled.png`, (_, scale) => {
                                                        scale = scale.replace(/\n|\r/g, '').split('x')
                                                        var width = Number(scale[0])
                                                        height = Number(scale[1])

                                                        exec(`ffmpeg -i temp/file${currentcount}/scaled.png -i templates/battlecats.png -i templates/shadow.png -filter_complex "[2:v]scale=${width + 15}:10[shadow];[1:v][shadow]overlay=x=W/2-w/2:y=H/1.1-h/2:format=auto[bshadow];[bshadow][0:v]overlay=x=W/2-w/2:y=H/1.1-h:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                            if (!fileMsg) {
                                                                try {
                                                                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                                } catch (_) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                    return
                                                                }
                                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                                if (fileLink) {
                                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                    if (!fileLinkMsg) {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    }
                                                                } else {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            }
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/battlecats.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a? -filter_complex "[0:v]scale=${height > (bheight / 1.1) ? -1 : 'iw'}:${height > (bheight / 1.1) ? bheight / 1.3 : 'ih'}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/scaled.mp4`, async () => {
                                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/scaled.mp4`, (_, scale) => {
                                                        scale = scale.replace(/\n|\r/g, '').split('x')
                                                        var width = Number(scale[0])
                                                        height = Number(scale[1])

                                                        exec(`ffmpeg -i temp/file${currentcount}/scaled.mp4 -i templates/battlecats.png -i templates/shadow.png -map 0:a? -filter_complex "[2:v]scale=${width + 15}:10[shadow];[1:v][shadow]overlay=x=W/2-w/2:y=H/1.1-h/2:format=auto[bshadow];[bshadow][0:v]overlay=x=W/2-w/2:y=H/1.1-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                            if (!fileMsg) {
                                                                try {
                                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                                } catch (_) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                    return
                                                                }
                                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                                if (fileLink) {
                                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                    if (!fileLinkMsg) {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    }
                                                                } else {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            }
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/battlecats.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var height = Number(scale[1])
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bheight = Number(bscale[1])

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=${height > (bheight / 1.1) ? -1 : 'iw'}:${height > (bheight / 1.1) ? bheight / 1.3 : 'ih'}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/scaled.gif`, async () => {
                                                    exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/scaled.gif`, (_, scale) => {
                                                        scale = scale.replace(/\n|\r/g, '').split('x')
                                                        var width = Number(scale[0])
                                                        height = Number(scale[1])

                                                        exec(`ffmpeg -i temp/file${currentcount}/scaled.gif -i templates/battlecats.png -i templates/shadow.png -filter_complex "[2:v]scale=${width + 15}:10[shadow];[1:v][shadow]overlay=x=W/2-w/2:y=H/1.1-h/2:format=auto[bshadow];[bshadow][0:v]overlay=x=W/2-w/2:y=H/1.1-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                            if (!fileMsg) {
                                                                try {
                                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                                } catch (_) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                    return
                                                                }
                                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                                if (fileLink) {
                                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                    if (!fileLinkMsg) {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    }
                                                                } else {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            }
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "battlecats/bc <file>",
            "value": "Command your Cats with simple controls in a battle through space and time! No need to register to develop your own Cat Army! BATTLE WITH ALL THE CATS!!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["dababy"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/damask.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[1:v][${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale2ref[mask][frame];[frame][mask]alphamerge[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/damaskv.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[1:v][${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale2ref[mask][frame];[frame][mask]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/damaskg.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[1:v][${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale2ref[mask][frame];[frame][mask]overlay=x=0:y=0:format=auto,colorkey=0x00AC91:0.01:0[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "dababy <file>",
            "value": "dababy"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["babis", "infant", "kirby"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/babismask.png -i templates/babis.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=175:175[frame];[2:v][frame]overlay=x=120:y=60:format=auto[babis];[babis][1:v]overlay=x=120:y=60:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/babismask.png -i templates/babis.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=175:175[frame];[2:v][frame]overlay=x=120:y=60:format=auto[babis];[babis][1:v]overlay=x=120:y=60:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/babismask.png -i templates/babis.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=175:175[frame];[2:v][frame]overlay=x=120:y=60:format=auto[babis];[babis][1:v]overlay=x=120:y=60:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "babis/infant/kirby <file>",
            "value": "A silly baby. He loves HAMBURGAS!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["coin"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/coinmask.png -i templates/shadow.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=256:256[frame];[2:v][frame]scale2ref[shadow][sframe];[1:v][shadow]scale2ref[mask][sshadow];[sframe][mask]alphamerge[mframe];[sshadow][mframe]overlay=x=0:y=0:format=auto,convolution='-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2'[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/coinmaskv.png -i templates/shadow.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=256:256[frame];[2:v][frame]scale2ref[shadow][sframe];[1:v][shadow]scale2ref[mask][sshadow];[sframe][mask]overlay=x=0:y=0:format=auto[mframe];[sshadow][mframe]overlay=x=0:y=0:format=auto,convolution='-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2'[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/coinmaskg.png -i templates/shadow.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=256:256[frame];[2:v][frame]scale2ref[shadow][sframe];[1:v][shadow]scale2ref[mask][sshadow];[sframe][mask]overlay=x=0:y=0:format=auto[mframe];[sshadow][mframe]overlay=x=0:y=0:format=auto,colorkey=0x00AC91:0.01:0,convolution='-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2'[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "coin <file>",
            "value": "Make your own currency!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["loop", "repeat"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            var numToRepeat = typeof (Number(args[2])) === 'number' && ((Number(args[2]) >= 10 && 10) || (Number(args[2]) < 2 && 2)) || typeof (Number(args[1])) === 'number' && ((Number(args[1]) >= 10 && 10) || (Number(args[1]) < 2 && 2)) || 2
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var list = ''
                                        for (var i = 0; i < numToRepeat; i++) {
                                            list = `${list}file 'input.${type.ext}'\n`
                                        }
                                        fs.writeFileSync(`temp/file${currentcount}/list.txt`, list)
                                        exec(`ffmpeg -f concat -i temp/file${currentcount}/list.txt -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var list = ''
                                        for (var i = 0; i < numToRepeat; i++) {
                                            list = `${list}file 'input.${type.ext}'\n`
                                        }
                                        fs.writeFileSync(`temp/file${currentcount}/list.txt`, list)
                                        exec(`ffmpeg -f concat -i temp/file${currentcount}/list.txt -preset ultrafast -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var list = ''
                                        for (var i = 0; i < numToRepeat; i++) {
                                            list = `${list}file 'input.${type.ext}'\n`
                                        }
                                        fs.writeFileSync(`temp/file${currentcount}/list.txt`, list)
                                        exec(`ffmpeg -f concat -i temp/file${currentcount}/list.txt -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "loop/repeat <video/audio/gif> [times]",
            "value": "Loops the file, if [times] is supplied, it'll loop [times] times.\nExample usage: p:loop https://cdn.discordapp.com/attachments/621060031357517827/823936228323623023/video.mp4 3"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["phexoutro", "phexoniaoutro"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video') || type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, (_, audio) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])

                                                exec(`ffmpeg -i templates/phexoutro.mp4 -filter_complex "[0:v]scale=-1:ceil(${height}/2)*2[vid];[0:v]scale=ceil(${width}/2)*2:ceil(${height}/2)*2,gblur=sigma=5:steps=6[bg];[bg][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ultrafast -map 0:a -aspect ${width}:${height} -pix_fmt yuv420p temp/file${currentcount}/phexoutro2.mp4`, async () => {
                                                    exec(`ffmpeg -i temp/file${currentcount}/phexoutro2.mp4 -preset ultrafast -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 temp/file${currentcount}/phexoutro.ts`, async () => {
                                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vf "scale=ceil(${width}/2)*2:ceil(${height}/2)*2" -preset ultrafast -aspect ${width}:${height} -pix_fmt yuv420p temp/file${currentcount}/input2.mp4`, async () => {
                                                            exec(`ffmpeg -i temp/file${currentcount}/input2.mp4 -preset ultrafast -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 temp/file${currentcount}/input.ts`, async () => {
                                                                exec(`ffmpeg -i "concat:temp/file${currentcount}/input.ts|temp/file${currentcount}/phexoutro.ts" -c copy -preset ultrafast -bsf:a aac_adtstoasc temp/file${currentcount}/output.mp4`, async () => {
                                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                                    if (!fileMsg) {
                                                                        try {
                                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                                        } catch (_) {
                                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                            msg.channel.stopTyping(true)
                                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                            return
                                                                        }
                                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                                        if (fileLink) {
                                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                            if (!fileLinkMsg) {
                                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                            }
                                                                        } else {
                                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                        }
                                                                    }
                                                                    msg.channel.stopTyping(true)
                                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "phexoutro/phexoniaoutro <file>",
            "value": "Ends the file with Phexonia's outro."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["phexintro", "phexoniaintro"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video') || type.mime.startsWith('image')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])

                                            exec(`ffmpeg -i templates/phexintro.mp4 -filter_complex "[0:v]scale=-1:ceil(${height}/2)*2[vid];[0:v]scale=ceil(${width}/2)*2:ceil(${height}/2)*2,gblur=sigma=5:steps=6[bg];[bg][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ultrafast -map 0:a -aspect ${width}:${height} -pix_fmt yuv420p temp/file${currentcount}/phexintro2.mp4`, async () => {
                                                exec(`ffmpeg -i temp/file${currentcount}/phexintro2.mp4 -preset ultrafast -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 temp/file${currentcount}/phexintro.ts`, async () => {
                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vf "scale=ceil(${width}/2)*2:ceil(${height}/2)*2" -preset ultrafast -aspect ${width}:${height} -pix_fmt yuv420p -shortest temp/file${currentcount}/input2.mp4`, async () => {
                                                        exec(`ffmpeg -i temp/file${currentcount}/input2.mp4 -preset ultrafast -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 temp/file${currentcount}/input.ts`, async () => {
                                                            exec(`ffmpeg -i "concat:temp/file${currentcount}/phexintro.ts|temp/file${currentcount}/input.ts" -c copy -preset ultrafast -bsf:a aac_adtstoasc temp/file${currentcount}/output.mp4`, async () => {
                                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                                if (!fileMsg) {
                                                                    try {
                                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                                    } catch (_) {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                        msg.channel.stopTyping(true)
                                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                        return
                                                                    }
                                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                                    if (fileLink) {
                                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                        if (!fileLinkMsg) {
                                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                        }
                                                                    } else {
                                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    }
                                                                }
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "phexintro/phexoniaintro <file>",
            "value": "Starts the file with Phexonia's intro."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["extracrunch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > exceptionsizelimit) {
                                msg.channel.send(`that file exceeds the exception size limit of ${exceptionsizelimit} mb hahahaha`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -b:v 20k -b:a 10k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -b:a 10k -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -b:v 20k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/converted.mp4`, async () => {
                                            exec(`ffmpeg -i temp/file${currentcount}/converted.mp4 -preset ultrafast -vframes 1 temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -b:v 20k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/converted.mp4`, async () => {
                                            exec(`ffmpeg -i temp/file${currentcount}/converted.mp4 -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "extracrunch <file>",
            "value": "Lowers the file's quality to the lowest."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["crunch"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > exceptionsizelimit) {
                                msg.channel.send(`that file exceeds the exception size limit of ${exceptionsizelimit} mb hahahaha`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -b:v 50k -b:a 30k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('audio')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -b:a 30k -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -q:v 31 -preset ultrafast temp/file${currentcount}/output.jpg`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.jpg`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.jpg`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.jpg`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -preset ultrafast temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "crunch <file>",
            "value": "Lowers the file's quality."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["tomp4", "tovideo"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "tomp4/tovideo <gif>",
            "value": "Converts the GIF to mp4."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["togif"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var duration = 10
            var durationindex = args.indexOf('-duration')
            if (durationindex > -1) {
                duration = isNaN(Number(args[durationindex + 1])) ? 10 : Number(args[durationindex + 1]) < 0 ? 0.1 : Number(args[durationindex + 1]) >= 60 ? 60 : Number(args[durationindex + 1]) || 10
            }
            var fps = 20
            var fpsindex = args.indexOf('-fps')
            if (fpsindex > -1) {
                fps = isNaN(Number(args[fpsindex + 1])) ? 20 : Number(args[fpsindex + 1]) < 0 ? 0.1 : Number(args[fpsindex + 1]) >= 50 ? 50 : Number(args[fpsindex + 1]) || 20
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.replace(/\n|\r/g, ''))

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -t ${duration >= iduration ? iduration : duration} -r ${fps} -gifflags -offsetting -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "togif <video> [-duration <seconds (max 60)>] [-fps <fps (max 50)>]",
            "value": "Converts the video to GIF. Default duration is 10 and default FPS is 20."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["toapng"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var duration = 10
            var durationindex = args.indexOf('-duration')
            if (durationindex > -1) {
                duration = isNaN(Number(args[durationindex + 1])) ? 10 : Number(args[durationindex + 1]) < 0 ? 0.1 : Number(args[durationindex + 1]) >= 60 ? 60 : Number(args[durationindex + 1]) || 10
            }
            var fps = 20
            var fpsindex = args.indexOf('-fps')
            if (fpsindex > -1) {
                fps = isNaN(Number(args[fpsindex + 1])) ? 20 : Number(args[fpsindex + 1]) < 0 ? 0.1 : Number(args[fpsindex + 1]) >= 50 ? 50 : Number(args[fpsindex + 1]) || 20
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.replace(/\n|\r/g, ''))

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale='min(300,iw)':min'(300,ih)':force_original_aspect_ratio=decrease[out]" -map "[out]" -preset ultrafast -plays 0 -t ${duration >= iduration ? iduration : duration} -r ${fps} temp/file${currentcount}/output.apng`, async () => {
                                                try {
                                                    fs.renameSync(`temp/file${currentcount}/output.apng`, `temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && type.ext === 'gif') {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 temp/file${currentcount}/input.${type.ext}`, (_, iduration) => {
                                            iduration = Number(iduration.replace(/\n|\r/g, ''))

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -plays 0 -t ${duration >= iduration ? iduration : duration} -r ${fps} -preset ultrafast temp/file${currentcount}/output.apng`, async () => {
                                                try {
                                                    fs.renameSync(`temp/file${currentcount}/output.apng`, `temp/file${currentcount}/output.png`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "toapng <video/gif> [-duration <seconds (max 60)>] [-fps <fps (max 50)>]",
            "value": "Converts the video/GIF to APNG. Default duration is 10 and default FPS is 20."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["tomp3", "toaudio", "tosound"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -i temp/file${currentcount}/input.${type.ext} -show_streams -select_streams a -loglevel error`, async (_, audio) => {
                                            if (audio) {
                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -map 0:a -preset ultrafast temp/file${currentcount}/output.mp3`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp3`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp3`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp3`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            } else {
                                                await msg.channel.send('No audio stream detected.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            }
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "tomp3/toaudio/tosound <video>",
            "value": "Converts the video to mp3."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["enlongate", "long"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var videohex = fs.readFileSync(`temp/file${currentcount}/input.${type.ext}`)
                                        var mvhdindex = videohex.indexOf('mvhd')
                                        var subarray1 = videohex.subarray(0, mvhdindex + 18)
                                        var enlongate = Buffer.from('00017FFFFFFF', 'hex')
                                        var subarray2 = videohex.subarray(subarray1.length + enlongate.length, videohex.length)
                                        var newvideohex = Buffer.concat([subarray1, enlongate, subarray2])
                                        fs.writeFileSync(`temp/file${currentcount}/output.mp4`, newvideohex)
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "enlongate/long <video>",
            "value": "Manipulates the video's Hex Code to make it as long as possible."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["2xlength", "2xduration", "doublelength", "doubleduration"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var videohex = fs.readFileSync(`temp/file${currentcount}/input.${type.ext}`)
                                        var mvhdindex = videohex.indexOf('mvhd')
                                        var subarray1 = videohex.subarray(0, mvhdindex + 20)
                                        var doublehex = (Number('0x' + videohex.toString('hex').substring((mvhdindex + 20) * 2, (mvhdindex + 24) * 2)) * 2).toString(16).padStart(8, '0')
                                        var doublelength = Buffer.from(doublehex.substring(doublehex.length - 8, doublehex.length), 'hex')
                                        var subarray2 = videohex.subarray(subarray1.length + doublelength.length, videohex.length)
                                        var newvideohex = Buffer.concat([subarray1, doublelength, subarray2])
                                        fs.writeFileSync(`temp/file${currentcount}/output.mp4`, newvideohex)
                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                        if (!fileMsg) {
                                            try {
                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                            } catch (_) {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                return
                                            }
                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                            if (fileLink) {
                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                if (!fileLinkMsg) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            } else {
                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                            }
                                        }
                                        msg.channel.stopTyping(true)
                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "2xlength/2xduration/doublelength/doubleduration <video>",
            "value": "Manipulates the video's Hex Code to double its duration."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    /*{
        name: ["freeze"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)
                                fs.copyFileSync(`templates/freezeData.bin`, `temp/file${currentcount}/freezeData.bin`)
                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var inputhex = fs.readFileSync(`temp/file${currentcount}/input.${type.ext}`)
                                        var inputmvhdindex = inputhex.indexOf('mvhd')
                                        var inputduration = inputhex.subarray(inputmvhdindex + 18, inputmvhdindex + 24)
                                        console.log(inputduration)
                                        fs.writeFileSync(`temp/file${currentcount}/inputs.txt`, `file input.${type.ext}\nfile freezeData.bin`)

                                        exec(`ffmpeg -f concat -i temp/file${currentcount}/inputs.txt -c copy -y temp/file${currentcount}/long.mp4`, async () => {
                                            var longhex = fs.readFileSync(`temp/file${currentcount}/long.mp4`)
                                            var longmvhdindex = longhex.indexOf('mvhd')
                                            var subarray1 = longhex.subarray(0, longmvhdindex + 18)
                                            var subarray2 = longhex.subarray(subarray1.length + inputduration.length, longhex.length)
                                            var newvideohex = Buffer.concat([subarray1, inputduration, subarray2])

                                            fs.writeFileSync(`temp/file${currentcount}/output.mp4`, newvideohex)

                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                            if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "freeze <video>",
            "value": "Freezes the video when it ends."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },*/

    {
        name: ["noloop"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -loop -1 -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "noloop <gif>",
            "value": "Makes the GIF only loop once."
        },
        cooldown: 2500,
        type: "Balls"
    },

    {
        name: ["fixgif", "fix"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -filter_complex "[0:v]scale=iw-2:ih-2,scale=iw+2:ih+2,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                            if (!fileMsg) {
                                                try {
                                                    fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                } catch (_) {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    return
                                                }
                                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                if (fileLink) {
                                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                    if (!fileLinkMsg) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                } else {
                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                }
                                            }
                                            msg.channel.stopTyping(true)
                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "fixgif/fix <gif>",
            "value": "Fixes the quality for GIFs, mainly for ones like https://cdn.discordapp.com/attachments/535469236802551811/726167982149074954/output.gif"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["benson"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var benson = await Jimp.read(`templates/benson.png`)
                                var consolas = await Jimp.loadFont('templates/fonts/Consolas/Consolas.fnt')
                                benson.print(consolas, 3, 4, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 94, 33)
                                benson.write(`temp/file${currentcount}/benson.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/benson.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=74:74[frame];[1:v][frame]overlay=x=13:y=38:format=auto[benson];[benson]scale=iw*2:ih*2[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var benson = await Jimp.read(`templates/benson.png`)
                                var consolas = await Jimp.loadFont('templates/fonts/Consolas/Consolas.fnt')
                                benson.print(consolas, 3, 4, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 94, 33)
                                benson.write(`temp/file${currentcount}/benson.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/benson.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=74:74[frame];[1:v][frame]overlay=x=13:y=38:format=auto[benson];[benson]scale=iw*2:ih*2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var benson = await Jimp.read(`templates/benson.png`)
                                var consolas = await Jimp.loadFont('templates/fonts/Consolas/Consolas.fnt')
                                benson.print(consolas, 3, 4, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 94, 33)
                                benson.write(`temp/file${currentcount}/benson.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/benson.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=74:74[frame];[1:v][frame]overlay=x=13:y=38:format=auto[benson];[benson]scale=iw*2:ih*2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "benson \"{name}\" <file>",
            "value": "A.I. Level 20"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["yall", "twitterartist"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var yall = await Jimp.read(`templates/yall.png`)
                                var morton = await Jimp.loadFont('templates/fonts/Morton/Morton.fnt')
                                yall.print(morton, 274, 8, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 202, 77)
                                yall.write(`temp/file${currentcount}/yall.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/yall.png -i templates/transparent.png -filter_complex "[2:v]scale=249:368[transparent];[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 368 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 368 : -1}[frame];[transparent][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[cframe];[1:v][cframe]overlay=x=251:y=94:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var yall = await Jimp.read(`templates/yall.png`)
                                var morton = await Jimp.loadFont('templates/fonts/Morton/Morton.fnt')
                                yall.print(morton, 274, 8, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 202, 77)
                                yall.write(`temp/file${currentcount}/yall.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/yall.png -i templates/transparent.png -map 0:a? -filter_complex "[2:v]scale=249:368[transparent];[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 368 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 368 : -1}[frame];[transparent][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[cframe];[1:v][cframe]overlay=x=251:y=94:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var yall = await Jimp.read(`templates/yall.png`)
                                var morton = await Jimp.loadFont('templates/fonts/Morton/Morton.fnt')
                                yall.print(morton, 274, 8, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 202, 77)
                                yall.write(`temp/file${currentcount}/yall.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/yall.png -i templates/transparent.png -filter_complex "[2:v]scale=249:368[transparent];[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 368 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 368 : -1}[frame];[transparent][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[cframe];[1:v][cframe]overlay=x=251:y=94:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "yall/twitterartist \"[text]\" <file>",
            "value": "twitter artist"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["call", "phonecall"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
            if (!matchedTextes) {
                matchedTextes = ['""', '']
            }
            var text = matchedTextes[1]
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var call = await Jimp.read(`templates/call.png`)
                                var helvetica = await Jimp.loadFont('templates/fonts/HelveticaLight/HelveticaLight.fnt')
                                call.print(helvetica, 20, 59, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 333, 155)
                                call.write(`temp/file${currentcount}/call.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/call.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var ratio = width / height
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bwidth = Number(bscale[0])
                                                var bheight = Number(bscale[1])
                                                var bratio = bwidth / bheight

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/call.png -i templates/callbg.png -filter_complex "[0:v]scale=${ratio < bratio ? bwidth : ratio > bratio ? -1 : bwidth}:${ratio < bratio ? -1 : ratio > bratio ? bheight : bheight}[frame];[2:v][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[bg];[bg][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var call = await Jimp.read(`templates/call.png`)
                                var helvetica = await Jimp.loadFont('templates/fonts/HelveticaLight/HelveticaLight.fnt')
                                call.print(helvetica, 20, 59, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 333, 155)
                                call.write(`temp/file${currentcount}/call.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/call.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var ratio = width / height
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bwidth = Number(bscale[0])
                                                var bheight = Number(bscale[1])
                                                var bratio = bwidth / bheight

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/call.png -i templates/callbg.png -map 0:a? -filter_complex "[0:v]scale=${ratio < bratio ? bwidth : ratio > bratio ? -1 : bwidth}:${ratio < bratio ? -1 : ratio > bratio ? bheight : bheight}[frame];[2:v][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[bg];[bg][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var call = await Jimp.read(`templates/call.png`)
                                var helvetica = await Jimp.loadFont('templates/fonts/HelveticaLight/HelveticaLight.fnt')
                                call.print(helvetica, 20, 59, { text: text, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 333, 155)
                                call.write(`temp/file${currentcount}/call.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/call.png`, (_, bscale) => {
                                                scale = scale.replace(/\n|\r/g, '').split('x')
                                                var width = Number(scale[0])
                                                var height = Number(scale[1])
                                                var ratio = width / height
                                                bscale = bscale.replace(/\n|\r/g, '').split('x')
                                                var bwidth = Number(bscale[0])
                                                var bheight = Number(bscale[1])
                                                var bratio = bwidth / bheight

                                                exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/call.png -i templates/callbg.png -filter_complex "[0:v]scale=${ratio < bratio ? bwidth : ratio > bratio ? -1 : bwidth}:${ratio < bratio ? -1 : ratio > bratio ? bheight : bheight}[frame];[2:v][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[bg];[bg][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                    var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                    if (!fileMsg) {
                                                        try {
                                                            fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.stopTyping(true)
                                                            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                        var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                        if (fileLink) {
                                                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                            if (!fileLinkMsg) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        } else {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    }
                                                    msg.channel.stopTyping(true)
                                                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "call/phonecall \"[name]\" <file>",
            "value": "Poopy is calling."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["robloxgame", "rgame"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var dft = ['""', '"88"', '"1.3K"']
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = dft
            } else {
                for (var i in dft) {
                    var dfttext = dft[i]
                    var text = matchedTextes[i]
                    if (!text) {
                        matchedTextes[i] = dfttext
                    }
                }
            }
            var name = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var likepercentage = matchedTextes[1].substring(1, matchedTextes[1].length - 1) + '%'
            var playercount = matchedTextes[2].substring(1, matchedTextes[2].length - 1)
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var game = await Jimp.read(`templates/game.png`)
                                var gothamed = await Jimp.loadFont('templates/fonts/GothamMedium/GothamMedium.fnt')
                                var gothasm = await Jimp.loadFont('templates/fonts/GothamSmall/GothamSmall.fnt')
                                game.print(gothamed, 5, 165, { text: name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 150, 35)
                                game.print(gothasm, 22, 211, { text: likepercentage, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 138, 17)
                                game.print(gothasm, 79, 211, { text: playercount, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 81, 17)
                                game.write(`temp/file${currentcount}/game.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/game.png -i templates/gamebg.png -filter_complex "[2:v][1:v]scale2ref[bg][game];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=150:150[frame];[bg][frame]overlay=x=5:y=4:format=auto[bframe];[bframe][game]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var game = await Jimp.read(`templates/game.png`)
                                var gothamed = await Jimp.loadFont('templates/fonts/GothamMedium/GothamMedium.fnt')
                                var gothasm = await Jimp.loadFont('templates/fonts/GothamSmall/GothamSmall.fnt')
                                game.print(gothamed, 5, 165, { text: name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 150, 35)
                                game.print(gothasm, 22, 211, { text: likepercentage, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 138, 17)
                                game.print(gothasm, 79, 211, { text: playercount, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 81, 17)
                                game.write(`temp/file${currentcount}/game.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/game.png -i templates/gamebg.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref[bg][game];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=150:150[frame];[bg][frame]overlay=x=5:y=4:format=auto[bframe];[bframe][game]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${game.bitmap.width}:${game.bitmap.height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var game = await Jimp.read(`templates/game.png`)
                                var gothamed = await Jimp.loadFont('templates/fonts/GothamMedium/GothamMedium.fnt')
                                var gothasm = await Jimp.loadFont('templates/fonts/GothamSmall/GothamSmall.fnt')
                                game.print(gothamed, 5, 165, { text: name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 150, 35)
                                game.print(gothasm, 22, 211, { text: likepercentage, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 138, 17)
                                game.print(gothasm, 79, 211, { text: playercount, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 81, 17)
                                game.write(`temp/file${currentcount}/game.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/game.png -i templates/gamebg.png -filter_complex "[2:v][1:v]scale2ref[bg][game];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=150:150[frame];[bg][frame]overlay=x=5:y=4:format=auto[bframe];[bframe][game]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${game.bitmap.width}:${game.bitmap.height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "robloxgame/rgame \"{name}\" \"[likeRatio]\" \"[playerCount]\" <file>",
            "value": "Power your imagination."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["twitterban"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var dft = ['""', `"${msg.member.nickname || msg.author.username}"`, `"${msg.author.username}"`]
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = dft
            } else {
                for (var i in dft) {
                    var dfttext = dft[i]
                    var text = matchedTextes[i]
                    if (!text) {
                        matchedTextes[i] = dfttext
                    }
                }
            }
            var message = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var nickname = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var username = '@' + matchedTextes[2].substring(1, matchedTextes[2].length - 1)
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var twitter = await Jimp.read(`templates/twitter.png`)
                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRoman/TimesNewRoman.fnt')
                                var arialbold = await Jimp.loadFont('templates/fonts/ArialBold/ArialBold.fnt')
                                var arialblue = await Jimp.loadFont('templates/fonts/ArialBlue/ArialBlue.fnt')
                                twitter.print(tnr, 85, 437, { text: message, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 546, 21)
                                twitter.print(arialbold, 116, 131, { text: nickname, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                                twitter.print(arialbold, 143, 379, { text: nickname, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                                twitter.print(arialblue, 116, 147, { text: username, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                                twitter.print(arialblue, 143, 395, { text: username, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                                twitter.write(`temp/file${currentcount}/twitter.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/twitter.png -i templates/twitterbg.png -filter_complex "[2:v][1:v]scale2ref[bg][twitter];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=48:48,split[frame][frame2];[bg][frame]overlay=x=59:y=134:format=auto[bframe];[bframe][frame2]overlay=x=86:y=382:format=auto[bbframe];[bbframe][twitter]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var twitter = await Jimp.read(`templates/twitter.png`)
                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRoman/TimesNewRoman.fnt')
                                var arialbold = await Jimp.loadFont('templates/fonts/ArialBold/ArialBold.fnt')
                                var arialblue = await Jimp.loadFont('templates/fonts/ArialBlue/ArialBlue.fnt')
                                twitter.print(tnr, 85, 437, { text: message, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 546, 21)
                                twitter.print(arialbold, 116, 131, { text: nickname, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                                twitter.print(arialbold, 143, 379, { text: nickname, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                                twitter.print(arialblue, 116, 147, { text: username, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                                twitter.print(arialblue, 143, 395, { text: username, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                                twitter.write(`temp/file${currentcount}/twitter.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/twitter.png -i templates/twitterbg.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref[bg][twitter];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=48:48,split[frame][frame2];[bg][frame]overlay=x=59:y=134:format=auto[bframe];[bframe][frame2]overlay=x=86:y=382:format=auto[bbframe];[bbframe][twitter]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -aspect ${twitter.bitmap.width}:${twitter.bitmap.height} -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var twitter = await Jimp.read(`templates/twitter.png`)
                                var tnr = await Jimp.loadFont('templates/fonts/TimesNewRoman/TimesNewRoman.fnt')
                                var arialbold = await Jimp.loadFont('templates/fonts/ArialBold/ArialBold.fnt')
                                var arialblue = await Jimp.loadFont('templates/fonts/ArialBlue/ArialBlue.fnt')
                                twitter.print(tnr, 85, 437, { text: message, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 546, 21)
                                twitter.print(arialbold, 116, 131, { text: nickname, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                                twitter.print(arialbold, 143, 379, { text: nickname, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                                twitter.print(arialblue, 116, 147, { text: username, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                                twitter.print(arialblue, 143, 395, { text: username, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                                twitter.write(`temp/file${currentcount}/twitter.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/twitter.png -i templates/twitterbg.png -filter_complex "[2:v][1:v]scale2ref[bg][twitter];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=48:48,split[frame][frame2];[bg][frame]overlay=x=59:y=134:format=auto[bframe];[bframe][frame2]overlay=x=86:y=382:format=auto[bbframe];[bbframe][twitter]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -aspect ${twitter.bitmap.width}:${twitter.bitmap.height} -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "twitterban \"{message}\" \"{nickname}\" \"{username}\" <file>",
            "value": "banned for hating Pan | They/Them | #BLM | #ACAB | #GAYRIGHTS | #ProudPansexual | #ProudNon-Binary | #LGBTQRIGHTS | Hates Straights"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["pvz", "plant"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""', '""']
            } else if (!matchedTextes[1]) {
                matchedTextes[1] = '""'
            }
            var plantname = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var plantdescription = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var pvz = await Jimp.read(`templates/pvz.png`)
                                var dwarven = await Jimp.loadFont('templates/fonts/Dwarven/Dwarven.fnt')
                                var brianne = await Jimp.loadFont('templates/fonts/Brianne/Brianne.fnt')
                                pvz.print(dwarven, 155, 197, { text: plantname, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 189, 27)
                                pvz.print(brianne, 166, 223, { text: plantdescription, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 166, 66)
                                pvz.write(`temp/file${currentcount}/pvz.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/pvz.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 40 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 40 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=118-h/2:format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var pvz = await Jimp.read(`templates/pvz.png`)
                                var dwarven = await Jimp.loadFont('templates/fonts/Dwarven/Dwarven.fnt')
                                var brianne = await Jimp.loadFont('templates/fonts/Brianne/Brianne.fnt')
                                pvz.print(dwarven, 155, 197, { text: plantname, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 189, 27)
                                pvz.print(brianne, 166, 223, { text: plantdescription, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 166, 66)
                                pvz.write(`temp/file${currentcount}/pvz.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/pvz.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 40 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 40 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=118-h/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var pvz = await Jimp.read(`templates/pvz.png`)
                                var dwarven = await Jimp.loadFont('templates/fonts/Dwarven/Dwarven.fnt')
                                var brianne = await Jimp.loadFont('templates/fonts/Brianne/Brianne.fnt')
                                pvz.print(dwarven, 155, 197, { text: plantname, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 189, 27)
                                pvz.print(brianne, 166, 223, { text: plantdescription, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 166, 66)
                                pvz.write(`temp/file${currentcount}/pvz.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/pvz.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 40 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 40 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=118-h/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "pvz/plant \"{name}\" \"{description}\" <file>",
            "value": "You got a new plant!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["amazon"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var dft = ['""', '"19.99"', '"4.5"']
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = dft
            } else {
                for (var i in dft) {
                    var dfttext = dft[i]
                    var text = matchedTextes[i]
                    if (!text) {
                        matchedTextes[i] = dfttext
                    }
                }
            }
            var name = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var price = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var price1 = price.split('.')[0]
            var price2 = price.split('.')[1] || '00'
            var rating = matchedTextes[2].substring(1, matchedTextes[2].length - 1)
            var numberrating = isNaN(Number(rating)) ? 4.5 : Number(rating) <= 0 ? 0 : Number(rating) >= 5 ? 5 : Number(rating) || 0
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var amazon = await Jimp.read(`templates/amazon.png`)
                                var ystars = await Jimp.read(`templates/ystars.png`)
                                var wstars = await Jimp.read(`templates/wstars.png`)
                                var amazonemlink = await Jimp.loadFont('templates/fonts/AmazonEmberLink/AmazonEmberLink.fnt')
                                var amazonemsmall = await Jimp.loadFont('templates/fonts/AmazonEmberSmall/AmazonEmberSmall.fnt')
                                var amazonembig = await Jimp.loadFont('templates/fonts/AmazonEmberBig/AmazonEmberBig.fnt')
                                ystars.crop(0, 0, ystars.bitmap.width * (numberrating / 5), ystars.bitmap.height)
                                wstars.composite(ystars, 0, 0)
                                amazon.composite(wstars, 16, 299)
                                amazon.print(amazonemlink, 14, 219, { text: name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 209, 49)
                                amazon.print(amazonembig, 22, 275, { text: price1, alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 36, 18)
                                amazon.print(amazonemsmall, 60, 275, { text: price2, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 20, 12)
                                amazon.write(`temp/file${currentcount}/amazon.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/amazon.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 184 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 184 : -1}[frame];[1:v][frame]overlay=x=26+(184/2-w/2):y=22+(184/2-h/2):format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var amazon = await Jimp.read(`templates/amazon.png`)
                                var ystars = await Jimp.read(`templates/ystars.png`)
                                var wstars = await Jimp.read(`templates/wstars.png`)
                                var amazonemlink = await Jimp.loadFont('templates/fonts/AmazonEmberLink/AmazonEmberLink.fnt')
                                var amazonemsmall = await Jimp.loadFont('templates/fonts/AmazonEmberSmall/AmazonEmberSmall.fnt')
                                var amazonembig = await Jimp.loadFont('templates/fonts/AmazonEmberBig/AmazonEmberBig.fnt')
                                ystars.crop(0, 0, ystars.bitmap.width * (numberrating / 5), ystars.bitmap.height)
                                wstars.composite(ystars, 0, 0)
                                amazon.composite(wstars, 16, 299)
                                amazon.print(amazonemlink, 14, 219, { text: name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 209, 49)
                                amazon.print(amazonembig, 22, 275, { text: price1, alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 36, 18)
                                amazon.print(amazonemsmall, 60, 275, { text: price2, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 20, 12)
                                amazon.write(`temp/file${currentcount}/amazon.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/amazon.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 184 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 184 : -1}[frame];[1:v][frame]overlay=x=26+(184/2-w/2):y=22+(184/2-h/2):format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var amazon = await Jimp.read(`templates/amazon.png`)
                                var ystars = await Jimp.read(`templates/ystars.png`)
                                var wstars = await Jimp.read(`templates/wstars.png`)
                                var amazonemlink = await Jimp.loadFont('templates/fonts/AmazonEmberLink/AmazonEmberLink.fnt')
                                var amazonemsmall = await Jimp.loadFont('templates/fonts/AmazonEmberSmall/AmazonEmberSmall.fnt')
                                var amazonembig = await Jimp.loadFont('templates/fonts/AmazonEmberBig/AmazonEmberBig.fnt')
                                ystars.crop(0, 0, ystars.bitmap.width * (numberrating / 5), ystars.bitmap.height)
                                wstars.composite(ystars, 0, 0)
                                amazon.composite(wstars, 16, 299)
                                amazon.print(amazonemlink, 14, 219, { text: name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 209, 49)
                                amazon.print(amazonembig, 22, 275, { text: price1, alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 36, 18)
                                amazon.print(amazonemsmall, 60, 275, { text: price2, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 20, 12)
                                amazon.write(`temp/file${currentcount}/amazon.png`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/amazon.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 184 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 184 : -1}[frame];[1:v][frame]overlay=x=26+(184/2-w/2):y=22+(184/2-h/2):format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "amazon \"{name}\" \"[price]\" \"[rating (in stars)]\" <file>",
            "value": "Now ON SALE!!!"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["dontrepost", "3am", "donotrepost"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/dontrepost.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 374 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 374 : -1}[frame];[1:v][frame]overlay=x=37+(374/2-w/2):y=160+(374/2-h/2):format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/dontrepost.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 374 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 374 : -1}[frame];[1:v][frame]overlay=x=37+(374/2-w/2):y=160+(374/2-h/2):format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                            scale = scale.replace(/\n|\r/g, '').split('x')
                                            var width = Number(scale[0])
                                            var height = Number(scale[1])
                                            var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                            exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i templates/dontrepost.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 374 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 374 : -1}[frame];[1:v][frame]overlay=x=37+(374/2-w/2):y=160+(374/2-h/2):format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                if (!fileMsg) {
                                                    try {
                                                        fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                    } catch (_) {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                        return
                                                    }
                                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.stopTyping(true)
                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "dontrepost/3am/donotrepost <file>",
            "value": "DO NOT REPOST IT"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["error", "warning"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            if (data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                msg.channel.send('What is the file?!').catch(() => { })
                msg.channel.stopTyping(true)
                return;
            };
            var saidMessage = args.join(' ').substring(args[0].length + 1)
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var dft = ['""', '""', '""', '""', '""']
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = dft
            } else {
                for (var i in dft) {
                    var dfttext = dft[i]
                    var text = matchedTextes[i]
                    if (!text) {
                        matchedTextes[i] = dfttext
                    }
                }
            }
            var title = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var text = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var b1 = matchedTextes[2].substring(1, matchedTextes[2].length - 1)
            var b2 = matchedTextes[3].substring(1, matchedTextes[3].length - 1)
            var b3 = matchedTextes[4].substring(1, matchedTextes[4].length - 1)
            var b1g = ''
            var b2g = ''
            var b3g = ''
            if (saidMessage.includes('-lgray')) b1g = 'x'
            if (saidMessage.includes('-cgray')) b2g = 'x'
            if (saidMessage.includes('-rgray')) b3g = 'x'
            var style = 'xp'
            var styleindex = args.indexOf('-style')
            if (styleindex > -1) {
                if (args[styleindex + 1]) {
                    style = ['xp', '98'].find(st => st === args[styleindex + 1].toLowerCase()) ? args[styleindex + 1].toLowerCase() : 'xp'
                }
            }
            var currenturl = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
            fetch(currenturl)
                .then(response => {
                    fileType.fromStream(response.body)
                        .then(async type => {
                            var body = await response.text()
                            if (body.length / 1048576 > sizelimit) {
                                msg.channel.send(`that file exceeds the size limit of ${sizelimit} mb hahahaha (try to use the shrink or crunch commands)`)
                                msg.channel.stopTyping(true)
                                return;
                            }
                            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/error.png`)

                                        require('http').get(`http://atom.smasher.org/error/${encodeURIComponent(style)}.png.php?title=${encodeURIComponent(title)}&text=${encodeURIComponent(text)}&b1=${encodeURIComponent(b1)}&b1g=${encodeURIComponent(b1g)}&b2=${encodeURIComponent(b2)}&b2g=${encodeURIComponent(b2g)}&b3=${encodeURIComponent(b3)}&b3g=${encodeURIComponent(b3g)}`, (response2) => {
                                            response2.pipe(writeStream2)
                                            writeStream2.on('finish', async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                                    scale = scale.replace(/\n|\r/g, '').split('x')
                                                    var width = Number(scale[0])
                                                    var height = Number(scale[1])
                                                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/error.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 34 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 34 : -1}[frame];[1:v][frame]overlay=x=15+(34/2-w/2):y=36+(34/2-h/2):format=auto[out]" -map "[out]" -preset ultrafast temp/file${currentcount}/output.png`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.png`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('video')) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/error.png`)

                                        require('http').get(`http://atom.smasher.org/error/${encodeURIComponent(style)}.png.php?title=${encodeURIComponent(title)}&text=${encodeURIComponent(text)}&b1=${encodeURIComponent(b1)}&b1g=${encodeURIComponent(b1g)}&b2=${encodeURIComponent(b2)}&b2g=${encodeURIComponent(b2g)}&b3=${encodeURIComponent(b3)}&b3g=${encodeURIComponent(b3g)}`, (response2) => {
                                            response2.pipe(writeStream2)
                                            writeStream2.on('finish', async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                                    scale = scale.replace(/\n|\r/g, '').split('x')
                                                    var width = Number(scale[0])
                                                    var height = Number(scale[1])
                                                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/error.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 34 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 34 : -1}[frame];[1:v][frame]overlay=x=15+(34/2-w/2):y=36+(34/2-h/2):format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ultrafast -c:v libx264 -pix_fmt yuv420p temp/file${currentcount}/output.mp4`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.mp4`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.mp4`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.mp4`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                                var currentcount = filecount
                                filecount = filecount + 1
                                fs.mkdirSync(`temp/file${currentcount}`)

                                var writeStream = fs.createWriteStream(`temp/file${currentcount}/input.${type.ext}`)

                                require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                    response.pipe(writeStream)
                                    writeStream.on('finish', async () => {
                                        var writeStream2 = fs.createWriteStream(`temp/file${currentcount}/error.png`)

                                        require('http').get(`http://atom.smasher.org/error/${encodeURIComponent(style)}.png.php?title=${encodeURIComponent(title)}&text=${encodeURIComponent(text)}&b1=${encodeURIComponent(b1)}&b1g=${encodeURIComponent(b1g)}&b2=${encodeURIComponent(b2)}&b2g=${encodeURIComponent(b2g)}&b3=${encodeURIComponent(b3)}&b3g=${encodeURIComponent(b3g)}`, (response2) => {
                                            response2.pipe(writeStream2)
                                            writeStream2.on('finish', async () => {
                                                exec(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 temp/file${currentcount}/input.${type.ext}`, (_, scale) => {
                                                    scale = scale.replace(/\n|\r/g, '').split('x')
                                                    var width = Number(scale[0])
                                                    var height = Number(scale[1])
                                                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                                                    exec(`ffmpeg -i temp/file${currentcount}/input.${type.ext} -i temp/file${currentcount}/error.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 34 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 34 : -1}[frame];[1:v][frame]overlay=x=15+(34/2-w/2):y=36+(34/2-h/2):format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ultrafast -gifflags -offsetting temp/file${currentcount}/output.gif`, async () => {
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.gif`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            try {
                                                                fs.readFileSync(`temp/file${currentcount}/output.gif`)
                                                            } catch (_) {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                msg.channel.stopTyping(true)
                                                                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                                return
                                                            }
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`temp/file${currentcount}/output.gif`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.stopTyping(true)
                                                        fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            } else {
                                msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                    allowedMentions: {
                                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.stopTyping(true)
                                return
                            }
                        })
                        .catch(() => {
                            msg.channel.send(`Unsupported file: \`${currenturl}\``, {
                                allowedMentions: {
                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.stopTyping(true)
                            return
                        })
                })
                .catch(err => {
                    msg.channel.send(err.message, {
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.stopTyping(true)
                    return
                })
        },
        help: {
            "name": "error/warning \"{title}\" \"{message}\" \"[leftbutton]\" [-lgray] \"[centerbutton]\" [-cgray] \"[rightbutton]\" [-rgray] [-style <style (98 or XP)>] <file>",
            "value": "Sonic is hacking your computer"
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["sayorichoice", "schoice"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/â€™/g, '\'')
            symbolreplacements.forEach(symbolReplacement => {
                symbolReplacement.target.forEach(target => {
                    saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                })
            })
            var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
            if (!matchedTextes) {
                matchedTextes = ['""', '""']
            } else if (!matchedTextes[1]) {
                matchedTextes[1] = '""'
            }
            var bchoice = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
            var rchoice = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
            var currentcount = filecount
            filecount = filecount + 1
            fs.mkdirSync(`temp/file${currentcount}`)
            var sayori = await Jimp.read(`templates/sayori.png`)
            var bangers = await Jimp.loadFont('templates/fonts/Bangers/Bangers.fnt')
            sayori.print(bangers, 52, 35, { text: bchoice, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 176, 62)
            sayori.print(bangers, 487, 38, { text: rchoice, alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 228, 72)
            sayori.write(`temp/file${currentcount}/output.png`);
            var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/output.png`)).catch(() => { })
            if (!fileMsg) {
                try {
                    fs.readFileSync(`temp/file${currentcount}/output.png`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.stopTyping(true)
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                    return
                }
                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                var fileLink = await Catbox.upload(`temp/file${currentcount}/output.png`).catch(() => { })
                if (fileLink) {
                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                    if (!fileLinkMsg) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                } else {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                }
            }
            msg.channel.stopTyping(true)
            fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
        },
        help: {
            "name": "sayorichoice/schoice \"{blueChoice}\" \"{redChoice}\"",
            "value": "Creates an image with Sayori where you can choose between 2 options."
        },
        cooldown: 2500,
        type: "File Manipulation"
    },

    {
        name: ["arabottify"],
        execute: async function (msg, args) {
            msg.channel.startTyping().catch(() => { })
            var wordNumber = Math.floor(Math.random() * 40) + 1
            var wordsSpecified = false
            var noextrawords = false
            var nopunctuation = false
            var wordindex = args.indexOf('-words')
            if (wordindex > -1) {
                wordNumber = isNaN(Number(args[wordindex + 1])) ? Math.floor(Math.random() * 40) + 1 : Number(args[wordindex + 1]) <= 1 ? 1 : Number(args[wordindex + 1]) >= 10000 ? 10000 : Math.round(Number(args[wordindex + 1])) || 1
                wordsSpecified = true
                args.splice(wordindex, 2)
            }
            if (args.find(arg => arg === '-noextrawords')) {
                noextrawords = true
                args.splice(args.indexOf('-noextrawords'), 1)
            }
            if (args.find(arg => arg === '-nopunctuation')) {
                nopunctuation = true
                args.splice(args.indexOf('-nopunctuation'), 1)
            }
            if (args[1] === undefined || args.indexOf('-words') == 1) {
                var arabArray = []
                var dict = 1
                var conn = 1
                for (var i = 0; i < wordNumber; i++) {
                    var randomFactor = Math.floor(Math.random() * 8)
                    if (randomFactor === 8) {
                        dict = 1
                        conn = 1
                        arabArray.push(msg.member.nickname || msg.author.username + (((Math.floor(Math.random() * 5) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                    } else {
                        function chooseWord() {
                            if (Math.floor(Math.random() * dict) + 1 === (dict === 3 ? 0 : 1)) {
                                conn = 1
                                dict++
                                arabArray.push(arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + (((Math.floor(Math.random() * 5) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                            } else if (Math.floor(Math.random() * conn) + 1 === (conn === 3 ? 0 : 1)) {
                                dict = 1
                                conn++
                                arabArray.push(arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + (((Math.floor(Math.random() * 5) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                            } else {
                                chooseWord()
                            }
                        }

                        chooseWord()
                    }
                }
                msg.channel.send(arabArray.join(' '), {
                    allowedMentions: {
                        parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(async () => {
                    var currentcount = filecount
                    filecount = filecount + 1
                    fs.mkdirSync(`temp/file${currentcount}`)
                    fs.writeFileSync(`temp/file${currentcount}/arabottify.txt`, arabArray.join(' '))
                    await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/arabottify.txt`)).catch(() => { })
                    fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
                })
                msg.channel.stopTyping(true)
                return;
            };
            var arabArray = args.splice(1)
            var arabArray2 = []
            arabArray.forEach(word => {
                for (var i = 0; i < ((Math.floor(Math.random() * 5) === 1 && (noextrawords ? 1 : 2)) || 1); i++) {
                    arabArray2.push({ word: word + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                }
                if (Math.floor(Math.random() * 4) === 3 && !noextrawords) {
                    var randomFactor = Math.floor(Math.random() * 8)
                    if (randomFactor === 7) {
                        arabArray2.push({ word: msg.member.nickname || msg.author.username + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                    } else if (randomFactor >= 0 && randomFactor <= 3) {
                        arabArray2.push({ word: arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                    } else {
                        arabArray2.push({ word: arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                    }
                }
            })
            arabArray2.sort(function (a, b) {
                return a.randomness - b.randomness
            })
            arabArray = []
            arabArray2.forEach(word => {
                arabArray.push(word.word)
            })
            if (wordsSpecified) {
                arabArray.splice(wordNumber)
            }
            msg.channel.send(arabArray.join(' '), {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(async () => {
                var currentcount = filecount
                filecount = filecount + 1
                fs.mkdirSync(`temp/file${currentcount}`)
                fs.writeFileSync(`temp/file${currentcount}/arabottify.txt`, arabArray.join(' '))
                await msg.channel.send(new Discord.MessageAttachment(`temp/file${currentcount}/arabottify.txt`)).catch(() => { })
                fs.rmSync(`temp/file${currentcount}`, { force: true, recursive: true })
            })
            msg.channel.stopTyping(true)
        },
        help: {
            "name": "arabottify [message] [-words <wordNumber>] [-noextrawords] [-nopunctuation]",
            "value": "message. a Scramble BLACK. message. Scramble Poopy\nExample usage: p:arabottify -words 1 -nopunctuation"
        },
        type: "Fun"
    },

    {
        name: ["garbage"],
        execute: async function (msg) {
            var garbage = ''
            for (var i = 0; i < 600; i++) {
                garbage = garbage + String.fromCharCode(Math.floor(Math.random() * 15000))
            }
            msg.channel.send(garbage, {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(() => { })
        },
        help: {
            "name": "garbage",
            "value": "Generates random Unicode characters like ã†¯á¬‹ã§“ãŒ‘à§ˆâ¹·á³£â¨‡Û¯á´ƒßà£ƒáŠ®â²ââ–•â¾©ã™„à³…á·¬á¶—ã¨­à¤‘á¹²ãƒŠã“ºã“®á¸©Æ¸à¿«â¸½ã›»à –Þ¶áš¾à¹¬à»¢à¯Šà·–à »â´²Î­áŠ‘â¢…â›Êƒá…«à¥¸â¸¹â½“â¦¢á²©â­¦â¡­Øšà±˜âƒƒà¨¢à´³ã³ã•ºÐ¬à²§È—Î–à¢¿Æáƒ³à¶‘â²³á‘¸à·šá¹™â‹áœ€á¯ˆâœ»â²á·”Ã’Þ¡â®¯à®¥É®âƒ¤â¿³âŸ‹ã•Šá®¨Î‹à­¼á«±Ú¨ã¥Šãµã›†â£¾Û”Î­Ï°âª²â¬‰ã›°à¸¡ã¥ºà°žâŠºá¾´á§²á¥žá»¨á®•â£â¬šá­Œá›µ@à¸â³¨á¿¦Ý¯â±¢à¨´á‘˜iàµŒâ–‰à­°á¬à°¢âƒã‘…á³†ã‡‹á–á–™áŽ”Ï«à¡‘Ü¬â†¤á–àª©ã‚”áŽà¦·à«‚âš¿á¸¹Î¬â…¶â¼”à±¨á—¹"
        },
        cooldown: 2500,
        type: "Fun"
    },

    {
        name: ["ronald", "ronaldgif"],
        execute: async function (msg) {
            var ronald = [
                'https://tenor.com/view/ronald-gif-20323112',
                'https://tenor.com/view/ronald-gif-20323104',
                'https://tenor.com/view/mc-donalds-smile-thumbs-down-gif-15614678',
                'https://tenor.com/view/mc-donalds-smile-wave-hi-hello-gif-15614675',
                'https://tenor.com/view/shocked-surprised-what-huh-ronald-mcdonald-gif-17825301',
                'https://tenor.com/view/mcdonalds-ronald-mcdonald-no-bad-gif-18753679',
                'https://tenor.com/view/mcdonalds-oh-yeah-happy-dance-peace-gif-15790119',
                'https://tenor.com/view/ronald-mcdonald-mcdonalds-excited-happy-yay-gif-16178752',
                'https://tenor.com/view/clown-mcdonalds-good-thumbs-up-nice-gif-16704087',
                'https://tenor.com/view/clown-mcdonald-ronald-mcdonald-laugh-lol-gif-18842655',
                'https://tenor.com/view/mcdonalds-ronald-mcdonald-clown-makeup-costume-gif-15607172',
                'https://tenor.com/view/mcdonalds-ronald-mcdonald-clown-makeup-costume-gif-15607167',
                'https://tenor.com/view/mcdonalds-ronald-mcdonald-clown-makeup-costume-gif-15607170',
                'https://tenor.com/view/clown-mcdonalds-wink-pointing-smile-gif-16021556',
                'https://tenor.com/view/airsoftfatty-mcdonalds-dancing-deepfake-dance-gif-19807516',
                'https://tenor.com/view/clown-mcdonalds-oh-wow-surprised-gif-16021560'
            ]
            msg.channel.send(ronald[Math.floor(Math.random() * ronald.length)]).catch(() => { })
        },
        help: {
            "name": "ronald/ronaldgif",
            "value": "Sends a random Ronald McDonald GIF to the channel."
        },
        type: "Fun"
    },

    {
        name: ["ps", "phexoniastudios"],
        execute: async function (msg) {
            msg.channel.send(psFiles[Math.floor(Math.random() * psFiles.length)]).catch(() => { })
        },
        help: {
            "name": "ps/phexoniastudios",
            "value": "Sends a random Phexonia Studios related image, GIF or video to the channel."
        },
        type: "Fun"
    },

    {
        name: ["pspasta", "phexoniastudiospasta"],
        execute: async function (msg) {
            msg.channel.send(psPasta[Math.floor(Math.random() * psPasta.length)]).catch(() => { })
        },
        help: {
            "name": "pspasta/phexoniastudiospasta",
            "value": "Sends a random Phexonia Studios related copypasta or phrase to the channel."
        },
        type: "Fun"
    },

    {
        name: ["sayoriart"],
        execute: async function (msg) {
            var sayoriart = [
                'https://cdn.discordapp.com/attachments/551420953704267789/795630551884103730/Untitled60.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/796054157907066880/Untitled61.jpg',
                'https://cdn.discordapp.com/attachments/551420953704267789/797153799139491850/Untitled63_20210108172423.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797157702593413161/Untitled2.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797160861708845096/Untitled64_20210108175220.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797184032219463720/Untitled36.jpg',
                'https://cdn.discordapp.com/attachments/551420953704267789/797190453464137768/Untitled65_20210108195002.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797190453236989982/Untitled59_20210108194540.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797596839657865236/Untitled66_20210109224445.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797774413059719189/Untitled67_20210110103021.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/797818314667458590/Untitled68_20210110132437.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/802162903679107082/Untitled2_20210122130848.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/802165734708215818/Untitled72_20210122132003.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/803251889424564224/Untitled72.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/808013659661533216/Untitled2_20210207163738.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/810271247992619068/Untitled73_20210213220820.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/810477036010340403/Untitled73_20210214114544.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/816670891323687012/Untitled76_20210303133106.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/816670891080810506/Untitled77_20210303133812.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/816680265774268456/Untitled69_20210303140555.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/816772683206492239/Untitled73_2.jpg',
                'https://cdn.discordapp.com/attachments/551420953704267789/816773611422613544/Untitled78_20210303204617.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/816776152202739762/Untitled76.jpg',
                'https://cdn.discordapp.com/attachments/551420953704267789/816783783726284850/Untitled78_20210303212454.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/816798995576913980/Untitled79_20210303222717.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817004224952401940/Untitled80_20210304120203.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817065692695363644/Untitled76_20210304160634.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817086156574687303/Untitled73_20210304172826.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817094556956884992/Untitled81_20210304180138.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817105921859518514/Untitled82_20210304184640.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817114899967770624/1614884560332.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817123709633429544/Untitled73_20210304195526.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817125204400013322/1614888154869.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817732287458050068/1615032958778.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817831868178104320/1615056703266.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817835070618468352/1615057467701.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817848187984674856/1615060564454.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817842334342447124/1615059191441.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817850459011416094/1615061128520.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817852659792347176/1615061646277.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817853455787753472/1615061838855.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817854272955613204/1615062030416.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817855251977076766/1615062269660.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817856309449326612/1615062519318.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817856863969345586/1615062650227.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/817857858954985482/1615062894509.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818094044202008586/1615119196369.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818095291567439872/1615119502203.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818115633404575754/1615124338983.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818124672867893288/1615125179384.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818143523635068958/1615130977811.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818164602764132372/1615136016890.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818166927465250846/1615136533205.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818182167808311346/1615140203358.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818218179594551316/1615148780821.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818601276921085973/1615240118322.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818878668663160832/1615306271210.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/818925499202928641/1615317432385.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/819251650824110130/1615395205112.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/819684625156669480/1615492124858.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/819685437898489856/1615498609344.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/820011700455473182/1615576403672.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/820012868874272818/1615576686101.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/820014046366924820/1615576967508.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/821302296336007188/1615884091566.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/821821022411817010/1616007749761.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/822210956837781584/1616097770660.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/822582293360148542/1616189282475.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/829993684190625802/1617956267687.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/831581623958896680/1618334886397.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/831600780988776468/1618339452533.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/831622224674553896/1618344569315.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833022357857239070/16186783690472.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833024930924199966/Untitled84_20210417180316.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833030355291996210/Untitled85_202104171824372.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833073620656980008/Untitled86_20210417211645.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833078671971188756/1618691802285.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833080317627203624/1618692189559.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833091643305492510/1618694886205.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833287354247544852/Untitled88_20210418112551.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833299240477523968/Untitled89_20210418121324.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833776183954505808/Untitled90_20210419194244.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833787541521432646/Untitled91_20210419203339.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/833816032245186610/Untitled92_20210419222646.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834074465025523712/1618929228772.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834102884207296532/1618935963637.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834131763432521809/1618942887419.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834148818953175100/1618946957296.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834185144775475210/1618955614344.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834433626925039646/1619014856005.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834486815636848700/1619027541404.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834518477167263795/1619035094650.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834538102872997918/1619039760117.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834799699294027786/1619102114157.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834818859457314856/1619106695612.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834827622805536818/1619108799106.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834845098994827364/1619112967178.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/834879150912700496/1619121072923.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/835260424685092864/1619211981789.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/835647931293106226/1619304378985.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/835989031112015915/1619385691547.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/842513191401291806/1620941172487.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/842520895293620234/1620942993681.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/842674520044208178/1620979646515.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/842689379385999360/1620983189025.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/844646768313368606/1621449856188.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/844954615342170152/1621523264214.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/845442104271700028/1621639485763.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/852189852779020318/1623248266953.png',
                'https://cdn.discordapp.com/attachments/551420953704267789/846018326434021436/20210523_143344.jpg'
            ]
            msg.channel.send('This treasure was made by arainbowkrewfamteddie#2254.', {
                files: [new Discord.MessageAttachment(sayoriart[Math.floor(Math.random() * sayoriart.length)])]
            }).catch(() => { })
        },
        help: {
            "name": "sayoriart",
            "value": "Sends a random masterpiece from Sayori (arainbowkrewfamteddie#2254) to the channel, we can't let something so good go away."
        },
        type: "Fun"
    },

    {
        name: ["sayori"],
        execute: async function (msg, args) {
            async function sayoriAi(msg, fixedchoice) {
                var datamembers = data['guild-data'][msg.guild.id]['members'];
                var members = []
                for (var id in datamembers) {
                    var datamember = datamembers[id]
                    if (datamember.username) members.push(datamember.username)
                }
                var year = new Date(Date.now()).getFullYear()
                var sayoriAdjectives = ['HORNY', 'FARTING', 'RACIST', 'STUPID', 'FEMBOY', 'GAY', 'TRANS', 'UNDERAGED', 'RETARD', 'BITCH', 'ASSHOLE', 'MOTHERFUCKER']
                var adjectives = ['is trans', 'the femboy', 'the futa', 'the idiot', 'the stalker', 'the impostor', 'now sus', 'the nutter', 'the shitter', 'the burger', 'is very annoying', 'big', 'fat', 'is thin', 'is small', 'what', 'is funny', 'noob', 'wtf', 'with pp', 'peed his pants', 'is amongla', 'looks at porn lolololol'];
                var shipAdjectives = ['likes', 'you like', 'loves', 'you love', 'you are in love with', 'you should marry', 'with', 'hug', 'your game is now poopoo for'];
                var fnf = ['dad', 'gf', 'pico', 'skid and pump', 'monster', 'mom', 'senpai', 'tankman', 'whitty', 'carol', 'hex', 'ruv', 'sarvente', 'miku', 'tricky', 'zardy', 'matt', 'garcello', 'shaggy', 'annie', 'cheeky', 'bob', 'tabi', 'agoti', 'kapi', 'neon', 'nene', 'monika', 'cg5', 'updike', 'selever', 'tord', 'impostor', 'trollge', 'tree']
                var consoles = ['pc', 'mobile', 'tablet', 'xbox', 'nintendo switch', 'nintendo 3ds', 'nintendo 2ds', 'psp', 'ps1', 'ps2', 'gamecube', 'ps3', 'ps4', 'ps5', 'wii', 'xbox 360', 'xbox one', 'gameboy', 'nintendo 64', 'sega genesis', 'wii u']
                var options = [
                    { pings: false, text: 'lol https://tenor.com/view/sus-suspect-among-us-gif-18663592' },
                    { pings: false, text: 'https://tenor.com/view/madness-hank-new-grounds-jump-gif-17044581' },
                    { pings: false, text: 'https://tenor.com/view/friday-night-funkin-hey-boyfriend-gif-21180248' },
                    { pings: true, text: 'SHUT UP' },
                    { pings: true, text: 'sussy' },
                    { pings: false, text: 'lol' },
                    { pings: false, text: 'among us impostor in madness tricky mod' },
                    { pings: false, text: 'ehat', edit: 'what' },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + '.' },
                    { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fandom is dying' },
                    { pings: false, text: 'THE VS ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' MOD' },
                    { pings: false, text: 'WHAT A ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() },
                    { pings: false, text: 'they added the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' big ass' },
                    { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fetish' },
                    { pings: false, text: 'finally a ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' game to ' + consoles[Math.floor(Math.random() * consoles.length)] },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' was made in ' + (Math.floor(Math.random() * (year - 1980)) + 1980) + ' xd' },
                    { pings: false, text: 'this will be ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + (Math.floor(Math.random() * (year - 2000)) + 2000) },
                    { pings: false, text: 'YOU DONT KILL ' + (arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' ').repeat(2) + 'KILLS YOU!!!!!!!!!!!!!!!!' },
                    { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is in the ' + fnf[Math.floor(Math.random() * fnf.length)] + ' week' },
                    { pings: false, text: 'no not big ass ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: true, text: 'snat' },
                    { pings: false, text: 'STOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPPPPPPPPPPPPPPPP' },
                    { pings: false, text: 'WOOOOOOOOOOOOOOOOOOOOOOOOOOOOO' },
                    { pings: true, text: 'wjat', edit: 'what' },
                    { pings: false, text: 'NO' },
                    { pings: false, text: 'ðŸ¤£ ðŸ¤£ ðŸ¤£ ðŸ¤£ ðŸ¤£ ðŸ¤£' },
                    { pings: false, text: 'STOP' },
                    { pings: false, text: 'WHU', edit: 'WHY' },
                    { pings: true, text: 'WHY' },
                    { pings: false, text: 'GOD HELP ME' },
                    { pings: false, text: 'IM NOT' },
                    { pings: false, text: 'wtf' },
                    { pings: false, text: 'wow' },
                    { pings: false, text: 'no' },
                    { pings: false, text: 'not again' },
                    { pings: false, text: 'IM NOT ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                    { pings: false, text: 'im ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)].toLowerCase() },
                    { pings: false, text: 'nooooo' },
                    { pings: false, text: 'stol', edit: 'stop' },
                    { pings: false, text: 'Hope you realize that people can become not cringe. Maybe. Juuuust maybe. I have stopped doing shit with the "gay chains". If you tried not dwelling on the past maybe you could actually realize how annoying you are. Now let me guess youll respond with a short answer, not answer, respond with what I did, or completely change the topic.' },
                    { pings: true, text: 'no' },
                    { pings: false, text: 'gay' },
                    { pings: false, text: 'i dare someone to post porn on my dm\'s' },
                    { pings: false, text: '._.' },
                    { pings: true, text: '' },
                    { pings: false, text: msg.author.username.toUpperCase() + ' WHY' },
                    { pings: false, text: 'BRUH' },
                    { pings: false, text: 'SUS' },
                    { pings: false, text: 'im underaged' },
                    { pings: true, text: 'YOU SUSSY' },
                    { pings: false, text: 'AMOGUS' },
                    { pings: false, text: 'is that friday night porn' },
                    { pings: true, text: 'flop' },
                    { pings: false, text: 'i like porn ðŸ¥² ðŸ¥² ðŸ¥² ðŸ¥² ðŸ¥² ðŸ¥²' },
                    { pings: true, text: 'stupid ' + msg.author.username.toLowerCase() },
                    { pings: false, text: 'not ' + msg.author.username.toLowerCase() },
                    { pings: false, text: 'wth ' + msg.author.username.toLowerCase() },
                    { pings: false, text: 'lol ' + msg.author.username.toLowerCase() },
                    { pings: false, text: msg.author.username.toLowerCase() + ' ' + adjectives[Math.floor(Math.random() * adjectives.length)] },
                    { pings: false, text: msg.author.username.toLowerCase() + ': ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'no not ' + msg.author.username.toLowerCase() + ' with ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                    { pings: false, text: 'ahhhhhhhhhh' },
                    { pings: false, text: 'school suuucks' },
                    { pings: false, text: 'why am i a bot' },
                    { pings: false, text: msg.author.username.toLowerCase() + ' ' + shipAdjectives[Math.floor(Math.random() * shipAdjectives.length)] + ' ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                    { pings: false, text: 'is ' + members[Math.floor(Math.random() * members.length)].toLowerCase() + ' hot' },
                    { pings: false, text: 'im not pinging ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                    { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' NOT ME' },
                    { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS THE ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                    { pings: false, text: msg.author.username.toLowerCase() }
                ];

                var sayori = await bot.users.fetch('758638862590803968')

                var option = fixedchoice && (typeof (Number(fixedchoice)) == 'number' && (((Number(fixedchoice) - 1) >= options.length - 1 && options[options.length - 1]) || ((Number(fixedchoice) - 1) <= 0 && options[0]) || (isNaN(Number(fixedchoice)) && options[Math.floor(Math.random() * options.length)]) || options[Math.floor(Number(fixedchoice))]) || options[Math.floor(Math.random() * options.length)]) || options[Math.floor(Math.random() * options.length)]
                var optiontext
                if (option['pings'] === true) {
                    optiontext = '<@' + msg.author.id + '> ' + option['text']
                } else {
                    optiontext = option['text']
                }

                var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                if (webhooks ? webhooks.size : undefined) {
                    var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                    if (findWebhook) {
                        findWebhook.send(optiontext, {
                            username: sayori.username,
                            avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        })
                            .then(botmsg => {
                                if (option['edit']) {
                                    var editTimeout = setTimeout(() => {
                                        if (option['pings'] === true) {
                                            botmsg.delete().catch(() => { })
                                            findWebhook.send('<@' + msg.author.id + '> ' + option['edit'] + ' â½áµ‰áµˆá¶¦áµ—áµ‰áµˆâ¾', {
                                                username: sayori.username,
                                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                allowedMentions: {
                                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        } else {
                                            botmsg.delete().catch(() => { })
                                            findWebhook.send(option['edit'] + ' â½áµ‰áµˆá¶¦áµ—áµ‰áµˆâ¾', {
                                                username: sayori.username,
                                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                allowedMentions: {
                                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        }
                                        clearTimeout(editTimeout)
                                    }, 3000)
                                }
                            })
                            .catch(() => { })
                    } else {
                        var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                        if (!createdWebhook) {
                            msg.channel.send('I need admin for this command!').catch(() => { })
                            return
                        }
                        createdWebhook.send(optiontext, {
                            username: sayori.username,
                            avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        })
                            .then(botmsg => {
                                if (option['edit']) {
                                    var editTimeout = setTimeout(() => {
                                        if (option['pings'] === true) {
                                            botmsg.delete().catch(() => { })
                                            findWebhook.send('<@' + msg.author.id + '> ' + option['edit'] + ' â½áµ‰áµˆá¶¦áµ—áµ‰áµˆâ¾', {
                                                username: sayori.username,
                                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                allowedMentions: {
                                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        } else {
                                            botmsg.delete().catch(() => { })
                                            findWebhook.send(option['edit'] + ' â½áµ‰áµˆá¶¦áµ—áµ‰áµˆâ¾', {
                                                username: sayori.username,
                                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                allowedMentions: {
                                                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        }
                                        clearTimeout(editTimeout)
                                    }, 3000)
                                }
                            })
                            .catch(() => { })
                    }
                } else {
                    var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                    if (!createdWebhook) {
                        msg.channel.send('I need admin for this command!').catch(() => { })
                        return
                    }
                    createdWebhook.send(optiontext, {
                        username: sayori.username,
                        avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    })
                        .then(botmsg => {
                            if (option['edit']) {
                                var editTimeout = setTimeout(() => {
                                    if (option['pings'] === true) {
                                        botmsg.delete().catch(() => { })
                                        findWebhook.send('<@' + msg.author.id + '> ' + option['edit'] + ' â½áµ‰áµˆá¶¦áµ—áµ‰áµˆâ¾', {
                                            username: sayori.username,
                                            avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                            allowedMentions: {
                                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                    } else {
                                        botmsg.delete().catch(() => { })
                                        findWebhook.send(option['edit'] + ' â½áµ‰áµˆá¶¦áµ—áµ‰áµˆâ¾', {
                                            username: sayori.username,
                                            avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                            allowedMentions: {
                                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                    }
                                    clearTimeout(editTimeout)
                                }, 3000)
                            }
                        })
                        .catch(() => { })
                }
            };

            await sayoriAi(msg, args[1])
        },
        help: {
            "name": "sayori [phraseChoice]",
            "value": "no not sayori ai"
        },
        type: "Fun"
    },

    {
        name: ["araboword", "raleighword"],
        execute: async function (msg) {
            var vowels = ['a', 'e', 'i', 'o', 'u']
            var consonants = []
            for (i = 97; i <= 122; i++) {
                var char = String.fromCharCode(i)
                if (!vowels.find(letter => letter == char)) {
                    consonants.push(char)
                }
            }
            var word = ''
            for (i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                word += consonants[Math.floor(Math.random() * consonants.length)] + vowels[Math.floor(Math.random() * vowels.length)]
            }
            msg.channel.send(word).catch(() => { })
        },
        help: {
            "name": "araboword/raleighword",
            "value": "Generates a completely nonsensical word that doesn't even exist."
        },
        type: "Fun"
    },

    {
        name: ["randomword"],
        execute: async function (msg) {
            var wordJSON = JSON.parse(fs.readFileSync('./templates/json/words.json'))
            msg.channel.send(wordJSON.data[Math.floor(Math.random() * wordJSON.data.length)].word.value).catch(() => { })
        },
        help: {
            "name": "randomword",
            "value": "Generates a random word."
        },
        type: "Fun"
    },

    {
        name: ["randomimage"],
        execute: async function (msg) {
            var imageJSON = JSON.parse(fs.readFileSync('./templates/json/images.json'))
            var image = imageJSON.data[Math.floor(Math.random() * imageJSON.data.length)]
            msg.channel.send(image.description, {
                files: [new Discord.MessageAttachment('https://randomwordgenerator.com' + image.image_url)],
            }).catch(() => { })
        },
        help: {
            "name": "randomimage",
            "value": "Generates a random image."
        },
        type: "Fun"
    },

    {
        name: ["randomsentence"],
        execute: async function (msg) {
            var sentenceJSON = JSON.parse(fs.readFileSync('./templates/json/sentences.json'))
            msg.channel.send(sentenceJSON.data[Math.floor(Math.random() * sentenceJSON.data.length)].sentence).catch(() => { })
        },
        help: {
            "name": "randomsentence",
            "value": "Generates a random sentence."
        },
        type: "Fun"
    },

    {
        name: ["randomname"],
        execute: async function (msg) {
            var nameJSON = JSON.parse(fs.readFileSync('./templates/json/names.json'))
            var surnames = nameJSON.surname
            var names = nameJSON.male.concat(nameJSON.female)
            msg.channel.send(`${names[Math.floor(Math.random() * names.length)].name.value} ${surnames[Math.floor(Math.random() * surnames.length)].name.value}`).catch(() => { })
        },
        help: {
            "name": "randomname",
            "value": "Generates a random name."
        },
        type: "Fun"
    },

    {
        name: ["randomgif"],
        execute: async function (msg) {
            var word = tenorDictionary[Math.floor(Math.random() * tenorDictionary.length)].toLowerCase()
            request.get(`https://g.tenor.com/v1/search?q=${encodeURIComponent(word)}&key=${process.env.TENORKEY}&limit=20`, (_, __, body) => {
                var parsedBody = JSON.parse(body)
                msg.channel.send(parsedBody.results[Math.floor(Math.random() * parsedBody.results.length)].itemurl).catch(() => { })
            })
        },
        help: {
            "name": "randomgif",
            "value": "Sends a completely random Tenor GIF."
        },
        type: "Fun"
    },

    {
        name: ["clickhole"],
        execute: async function (msg) {
            request.get(`https://clickhole.com/category/news/`, (_, __, body) => {
                var $ = cheerio.load(body)
                var pages = Number($('.page-numbers')[3].children[0].data)
                var page = Math.floor(Math.random() * pages) + 1
                request.get(`https://clickhole.com/category/news/${page != 1 ? `page/${page}/` : ''}`, (_, __, body2) => {
                    var $2 = cheerio.load(body2)
                    var posts = $2('.post')
                    var post = posts[Math.floor(Math.random() * posts.length)]
                    msg.channel.send(post.children[1].children[1].children[0].attribs.href).catch(() => { })
                })
            })
        },
        help: {
            "name": "clickhole",
            "value": "Sends one of Clickhole's dumb news."
        },
        type: "Fun"
    },

    {
        name: ["randomcmd"],
        execute: async function (msg, args) {
            var cmd
            var type = 'Random'
            function chooseCmd() {
                if (type === 'Random' || type === 'Misc') {
                    cmd = commands[Math.floor(Math.random() * commands.length)]
                    if (cmd.type === 'Owner' || cmd.perms) {
                        chooseCmd()
                        return
                    }
                    return cmd
                } else {
                    var cmds = []
                    for (var i in shelpCmds) {
                        var shelpCmd = shelpCmds[i]
                        if (shelpCmd.type === type) {
                            for (var j in shelpCmd.commands) {
                                var command = shelpCmd.commands[j]
                                cmds.push(commands.find(c => c.help.name === command.name))
                            }
                        }
                    }
                    cmd = cmds[Math.floor(Math.random() * cmds.length)]
                    return cmd
                }
            }
            var typeindex = args.indexOf('-type')
            if (typeindex > -1) {
                if (types.find(type => type.toLowerCase() === args.slice(typeindex + 1).join(' ').toLowerCase())) {
                    type = types.find(type => type.toLowerCase() === args.slice(typeindex + 1).join(' ').toLowerCase())
                }
            }
            chooseCmd()
            var cmdmessage = await msg.channel.send(`Executing \`${cmd.name[0]}\`.`).catch(() => { })
            if (cmd.cooldown) {
                data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + cmd.cooldown
            }
            var deletetimeout = setTimeout(() => {
                if (!cmdmessage) return
                if (!cmdmessage.deleted) {
                    cmdmessage.delete().catch(() => { })
                }
                clearTimeout(deletetimeout)
            }, 3000)
            await cmd.execute(msg, args)
        },
        help: {
            "name": "randomcmd [args] [-type <commandType>]",
            "value": "Executes a completely random Poopy command.\nExample usage: p:randomcmd -type File Manipulation"
        },
        type: "Misc"
    }
].sort((a, b) => {
    if (a.name[0] > b.name[0]) {
        return 1;
    }
    if (a.name[0] < b.name[0]) {
        return -1;
    }
    return 0;
})

var helpCmds = []
var devCmds = []
var sections = []
var types = []

commands.forEach(command => {
    if (command.type === "Owner") {
        devCmds.push(command.help)
    } else {
        if (!helpCmds.find(typeList => typeList.type === command.type)) {
            helpCmds.push({
                type: command.type,
                commands: []
            })
            types.push(command.type)
        }

        helpCmds.find(typeList => typeList.type === command.type).commands.push(command.help)
    }
})

helpCmds = helpCmds.sort((a, b) => {
    if (a.type > b.type) {
        return 1;
    }
    if (a.type < b.type) {
        return -1;
    }
    return 0;
})

for (var i in helpCmds) {
    var type = helpCmds[i].type

    helpCmds[i].commands = helpCmds[i].commands.sort((a, b) => {
        if (a.name > b.name) {
            return 1;
        }
        if (a.name < b.name) {
            return -1;
        }
        return 0;
    })

    var packed = helpCmds[i].commands

    var chunked = chunkArray(packed, 10)

    for (var j in chunked) {
        var commandChunk = chunked[j]

        sections.push({
            type: type,
            commands: commandChunk
        })
    }
}

sections = sections.sort((a, b) => {
    if (a.type > b.type) {
        return 1;
    }
    if (a.type < b.type) {
        return -1;
    }
    return 0;
})

devCmds = devCmds.sort((a, b) => {
    if (a.name > b.name) {
        return 1;
    }
    if (a.name < b.name) {
        return -1;
    }
    return 0;
})

var shelpCmds = sections

var statuses = [
    {
        name: "the cycle of poopy",
        type: "WATCHING"
    },
    {
        name: "berezaa",
        type: "WATCHING"
    },
    {
        name: "beans",
        type: "WATCHING"
    },
    {
        name: "the vent",
        type: "WATCHING"
    },
    {
        name: "Deinx abusing admin",
        type: "LISTENING"
    },
    {
        name: "Soup",
        type: "PLAYING"
    },
    {
        name: "Garfield Kart",
        type: "PLAYING"
    },
    {
        name: "Mirror World",
        type: "PLAYING"
    },
    {
        name: "heaven with Soup God",
        type: "COMPETING"
    },
    {
        name: "Troll Boxing",
        type: "COMPETING"
    },
    {
        name: "the Soup Bible giveaway",
        type: "COMPETING"
    },
    {
        name: "the Annoying Orange",
        type: "STREAMING"
    },
    {
        name: ":hole",
        type: "LISTENING"
    },
    {
        name: "Among Us Trap Remix",
        type: "LISTENING"
    },
    {
        name: "â €",
        type: "WATCHING"
    },
    {
        name: "Emote Game sweating because of Soup",
        type: "WATCHING"
    },
    {
        name: "Roblox moderation fail",
        type: "WATCHING"
    },
    {
        name: "nine",
        type: "STREAMING"
    },
    {
        name: "simple steps on how to make a chocolate generator",
        type: "STREAMING"
    },
]
var statusChanges = 'true';
var filecount = 0;
var cps = 0;
var chromeWindow = false
var statusInterval;

var messageCallback = async msg => {
    const dmPhrases = [
        'Yo.',
        'ADMIN?',
        'I don\'t care how long I have to keep this up, I\'ll make a post daily, or maybe even more frequently until one of two things happen. Deinbag\'s cheated level is removed from the leaderboard, or Calm gets its One Winged Angel theme back. I will not put up with two major things I cared about in the game be influenced by the developers when they had no good reason. And until it gets fixed, you\'ll be seeing this message over and over, no matter the platform.',
        'Eat your chair',
        'same feel',
        'NO WAY HE',
        'What.',
        'That\'s spicy.',
        'SAME!',
        '<:poopy:621064531908755467> this is me',
        'Wait, what the hell is the peedapocalypse?',
        'Cool.',
        'NaN',
        'undefined',
        'nil',
        'Good work.',
        'That deserves a reward!',
        'but how can',
        'YES',
        'DAMN DANIEL!',
        'Hello everybody my name is Markiplier and today we\'ll <@454732245425455105>',
        'Why does it smell like fart',
        'Mama Luigi? MAMA LUIGI?!?!',
        'ballfishe',
        'Don\'t expect to see lore here anytime soon.',
        '** **',
        'that\'s stupid',
        'Epic School Prank',
        'I feel like I\'ve heard that before...',
        ':deciduous_tree:',
        'no......',
        'So Phil, is it?',
        'it was',
        'it wasn\'t',
        'FINE I DO IT',
        'HI DEINX',
        'INPOSSINBLE',
        'Poop shit. Idiot Dream Hotel Mario. You are a man\'s friend for a moment.',
        'how do i help you',
        'AWESOME! i died',
        'just like that, my life became a misery',
        'ROAST',
        'bmmptsmptshmptsptsptsptsptsmhmptsmmhmmptsptsptsptsmhptsmmhptsmmmptshmptsptsptsmmptsmptshhptsmmptsmmmhmmmhmm',
        'POOPY. HEAD.',
        'Descend to hell.',
        'Ascend to heaven.',
        'SHUT UP YOU RACIS TIDITO!!!!!',
        'coel',
        'erectile dysfunction',
        'brb i\'m gonna block you for fun',
        'omg!!!! creator',
        'I blew up Malaysia',
        'Oh? On god?',
        'funy',
        'You May Insert',
        'O_o',
        'Genius.',
        'let\'s get this thing viral',
        '2b2t',
        'NUMBER',
        'epica moment',
        'https://www.youtube.com/watch?v=RR856dzGhv8',
        'ARE YOU GORK\'S MOTHER!?!?!?!',
        '```bat\ncd desktop\ncd poopy\nnode .\n```',
        '```lua\ngame.Players.PlayerAdded:Connect(function(plr)\n    plr.Kick()\nend)```',
        'Bro tip number 80:\nsuicide is the answer',
        'now you understand what that ominous entity was',
        'it was minecraft steve, he\'s turned your world into his, and now he wants to kill you',
        'wholesome 100',
        'cringe',
        'TABLE.',
        'Pufferfish Defense',
        'my mom',
        'I blew up',
        'my skin is rotting slowly',
        `<@${msg.author.id}>`,
        'seen that already',
        'I knew it.',
        'bye bye troller',
        'we don\'t need you',
        'I can track your location',
        'fuck'
    ]

    if (!data['bot-data']) {
        data['bot-data'] = {}
    }

    if (!data['bot-data']['bot']) {
        data['bot-data']['bot'] = {}
    }

    if (!data['bot-data']['bot']['messages']) {
        data['bot-data']['bot']['messages'] = 0
    }

    if (!data['bot-data']['bot']['commands']) {
        data['bot-data']['bot']['commands'] = 0
    }

    if (!data['bot-data']['bot']['filecount']) {
        data['bot-data']['bot']['filecount'] = 0
    }

    data['bot-data']['bot']['messages']++

    if (msg.channel.type === 'dm') {
        if (msg.author.bot) return;
        setTimeout(function () {
            msg.channel.startTyping().catch(() => { })
            setTimeout(function () {
                msg.channel.send(dmPhrases[Math.floor(Math.random() * dmPhrases.length)]).catch(() => { })
                msg.channel.stopTyping(true)
            }, Math.floor(Math.random() * 500) + 500)
        }, Math.floor(Math.random() * 500) + 500)
        return
    };

    if (!data['user-data']) {
        data['user-data'] = {}
    }

    if (!msg.webhookID) {
        if (!data['user-data'][msg.author.id]) {
            data['user-data'][msg.author.id] = {}
        }

        if (!data['user-data'][msg.author.id]['username']) {
            data['user-data'][msg.author.id]['username'] = msg.author.username
        }

        if (!data['user-data'][msg.author.id]['health']) {
            data['user-data'][msg.author.id]['health'] = 100
        }

        if (!data['user-data'][msg.author.id]['dms'] === undefined) {
            data['user-data'][msg.author.id]['dms'] = true
        }
    }

    if (!data['guild-data']) {
        data['guild-data'] = {}
    }

    if (!data['guild-data'][msg.guild.id]) {
        data['guild-data'][msg.guild.id] = {}
    }

    if (!data['guild-data'][msg.guild.id]['gettingData']) {
        data['guild-data'][msg.guild.id]['gettingData'] = 0
    }

    if (!data['guild-data'][msg.guild.id]['restricted']) {
        data['guild-data'][msg.guild.id]['restricted'] = false
    }

    if (!data['guild-data'][msg.guild.id]['prefix']) {
        data['guild-data'][msg.guild.id]['prefix'] = globalPrefix
    }

    if (!data['guild-data'][msg.guild.id]['channels']) {
        data['guild-data'][msg.guild.id]['channels'] = {}
    }

    if (!data['guild-data'][msg.guild.id]['channels'][msg.channel.id]) {
        data['guild-data'][msg.guild.id]['channels'][msg.channel.id] = {}
    }

    if (!data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']) {
        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = undefined
    }

    if (!data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2']) {
        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = undefined
    }

    if (!data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = []
    }

    if (!msg.webhookID) {
        if (!data['guild-data'][msg.guild.id]['members']) {
            data['guild-data'][msg.guild.id]['members'] = {}
        }

        if (!data['guild-data'][msg.guild.id]['members'][msg.author.id]) {
            data['guild-data'][msg.guild.id]['members'][msg.author.id] = {}
        }

        if (!data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
            data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
        }

        if (!data['guild-data'][msg.guild.id]['members'][msg.author.id]['username']) {
            data['guild-data'][msg.guild.id]['members'][msg.author.id]['username'] = msg.author.username
        }
    }

    if (!data['guild-data'][msg.guild.id]['disabled']) {
        data['guild-data'][msg.guild.id]['disabled'] = []
    }

    if (!data['guild-data'][msg.guild.id]['localcmds']) {
        data['guild-data'][msg.guild.id]['localcmds'] = []
    }

    if (!data2[msg.guild.id]) {
        data2[msg.guild.id] = {}
    }

    if (!data2[msg.guild.id][msg.author.id]) {
        data2[msg.guild.id][msg.author.id] = {}
    }

    if (!data2[msg.guild.id][msg.author.id]['promises']) {
        data2[msg.guild.id][msg.author.id]['promises'] = []
    }

    if (!data2[msg.author.id]) {
        data2[msg.author.id] = {}
    }

    if (!data2[msg.author.id]['promises']) {
        data2[msg.author.id]['promises'] = []
    }

    var lastDataGather = Date.now() - data['guild-data'][msg.guild.id]['gettingData']
    if (lastDataGather >= 600000) {
        async function gather() {
            var cantFetch = false

            for (var id in data['guild-data'][msg.guild.id]['members']) {
                var member = data['guild-data'][msg.guild.id]['members'][id]
                if (member.username === undefined) {
                    if (!cantFetch) data['guild-data'][msg.guild.id]['gettingData'] = Date.now()
                    var user = await bot.users.fetch(id).catch(() => { })
                    if (user) {
                        data['guild-data'][msg.guild.id]['members'][id]['username'] = user.username
                    } else {
                        delete data['guild-data'][msg.guild.id]['members'][id]
                    }
                }
            }
        }

        gather()
    }

    var prefix = testing ? `2${data['guild-data'][msg.guild.id]['prefix']}` : data['guild-data'][msg.guild.id]['prefix']
    var ignored = ['eval', 'execute', 'localcommands', 'localcmds']

    async function getKeywordsFor(string) {
        for (var k in special.keys) {
            var key = special.keys[k].func
            async function changeAllWords(c) {
                var change = await key(msg)
                c = c.replace(new RegExp(k, 'i'), change)
                if (c.match(new RegExp(k, 'i'))) {
                    return changeAllWords(c)
                }
                return c
            }
            string = await changeAllWords(string)
        }

        for (var f in special.functions) {
            var func = special.functions[f].func
            async function changeAllWords(c) {
                var match = c.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))
                if (match) {
                    var change = await func(match[0], msg, string.substring(prefix.length))
                    c = c.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'), change)
                    if (c.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'i'))) {
                        return changeAllWords(c)
                    }
                    return c
                } else {
                    return string
                }
            }
            string = await changeAllWords(string)
        }

        return string
    }

    if (!(ignored.find(name => msg.content.includes(`${prefix}${name}`)))) {
        msg.content = await getKeywordsFor(msg.content)
    }

    async function updateUrls() {
        if (msg.content) {
            var words = msg.content.split(/[\s]+| ?-\|- ?/)
            var wordsreverse = words.reverse()

            for (var i in wordsreverse) {
                var word = wordsreverse[i]
                if (validUrl.test(word)) {
                    if (word.startsWith('https://tenor.com/view/') && word.match(/\d+/g)) {
                        async function getTenorBody(url) {
                            return new Promise((resolve) => {
                                request.get(url, (_, __, body) => {
                                    resolve(body)
                                })
                            })
                        }

                        var ids = word.match(/\d+/g)
                        var body = JSON.parse(await getTenorBody(`https://g.tenor.com/v1/gifs?ids=${ids[ids.length - 1]}&key=${process.env.TENORKEY}`))
                        if (body.results.length) {
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = body.results[0].media[0].gif.url
                            var lastUrls = [body.results[0].media[0].gif.url].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        } else {
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = word
                            var lastUrls = [word].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        }
                    } else if (word.startsWith('https://gyazo.com/')) {
                        var gifurl = word.replace('https://gyazo.com/', 'https://i.gyazo.com/') + '.gif'
                        var mp4url = word.replace('https://gyazo.com/', 'https://i.gyazo.com/') + '.mp4'
                        var pngurl = word.replace('https://gyazo.com/', 'https://i.gyazo.com/') + '.png'
                        var gyazourls = [gifurl, mp4url, pngurl]
                        var gyazourl = undefined
                        for (var i in gyazourls) {
                            var url = gyazourls[i]
                            var response = await fetch(url)
                            if (response.status == 200) {
                                gyazourl = url
                                break
                            }
                        }
                        if (gyazourl) {
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = gyazourl
                            var lastUrls = [gyazourl].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        } else {
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = word
                            var lastUrls = [word].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        }
                    } else if (word.startsWith('https://imgur.com/')) {
                        var mp4url = word.replace('https://imgur.com/', 'https://i.imgur.com/') + '.mp4'
                        var pngurl = word.replace('https://imgur.com/', 'https://i.imgur.com/') + '.png'
                        var imgurls = [mp4url, pngurl]
                        var imgurl = undefined
                        for (var i in imgurls) {
                            var url = imgurls[i]
                            var response = await fetch(url)
                            if (response.status == 200) {
                                imgurl = url
                                break
                            }
                        }
                        if (imgurl) {
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = imgurl
                            var lastUrls = [imgurl].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        } else {
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = word
                            var lastUrls = [word].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        }
                    } else {
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = word
                        var lastUrls = [word].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                        lastUrls.splice(100)
                        data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                    }
                }
            };
        }

        if (msg.attachments.size) {
            msg.attachments.array().reverse().forEach(attachment => {
                data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = attachment.url
                var lastUrls = [attachment.url].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                lastUrls.splice(100)
                data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
            })
        }
    }

    if (msg.content ? msg.content.toLowerCase().includes(prefix.toLowerCase()) : undefined) {
        var useridmatch = msg.content.match(/\d{10,}/g)
        if (useridmatch) {
            useridmatch = useridmatch.reverse()
            for (var i in useridmatch) {
                var id = useridmatch[i]
                var user = await bot.users.fetch(id).catch(() => { })
                if (user) {
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                    var lastUrls = [user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                    lastUrls.splice(100)
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                }
            }
        }
        var demojimatch = msg.content.match(/<a?:.+?:\d+>/g)
        if (demojimatch) {
            demojimatch = demojimatch.reverse()
            for (var i in demojimatch) {
                var demojiidmatch = demojimatch[i].match(/\d+/g)
                var demojiid = demojiidmatch[demojiidmatch.length - 1]
                var gifurl = `https://cdn.discordapp.com/emojis/${demojiid}.gif?size=1024`
                var pngurl = `https://cdn.discordapp.com/emojis/${demojiid}.png?size=1024`
                var demojiurls = [gifurl, pngurl]
                var demojiurl = undefined
                for (var i in demojiurls) {
                    var url = demojiurls[i]
                    var response = await fetch(url)
                    if (response.status == 200) {
                        demojiurl = url
                        break
                    }
                }
                if (demojiurl) {
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = demojiurl
                    var lastUrls = [demojiurl].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                    lastUrls.splice(100)
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                }
            }
        }
        var emojimatch = msg.content.match(emojiRegex)
        if (emojimatch) {
            emojimatch = emojimatch.reverse()
            for (var i in emojimatch) {
                var emoji = emojimatch[i]
                var codepoints = []
                for (var j = 0; j < [...emoji].length; j++) {
                    codepoints.push([...emoji][j].codePointAt().toString(16).padStart(4, '0'))
                }
                var emojiurl = emojiImages.find(url => url.endsWith(`${codepoints.join('-')}.png`) || url.endsWith(`${codepoints.join('-')}_${codepoints[codepoints.length - 1]}.png`))
                if (emojiurl) {
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = emojiurl
                    var lastUrls = [emojiurl].concat(data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                    lastUrls.splice(100)
                    data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                }
            }
        }

        await updateUrls()
    } else {
        await updateUrls()
    }

    if (msg.webhookID) return

    if (data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']) {
        if (typeof (data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']) === 'object' && !msg.deleted && (msg.content || msg.attachments.size)) {
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
            if (webhooks ? webhooks.size : undefined) {
                var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                if (findWebhook) {
                    await findWebhook.send(msg.content, {
                        username: data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name'],
                        avatarURL: data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['avatar'],
                        files: attachments,
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).then(() => {
                        if (!msg.deleted) {
                            msg.delete().catch(() => { })
                        }
                    })
                        .catch(() => { })
                } else {
                    var createdWebhook = msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                    if (!createdWebhook) {
                        await msg.channel.send(`I need admin to turn you into ${data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']}.`).catch(() => { })
                    } else {
                        await createdWebhook.send(msg.content, {
                            username: data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name'],
                            avatarURL: data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['avatar'],
                            files: attachments,
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).then(() => {
                            if (!msg.deleted) {
                                msg.delete().catch(() => { })
                            }
                        })
                            .catch(() => { })
                    }
                }
            } else {
                var createdWebhook = msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                console.log(createdWebhook)
                if (!createdWebhook) {
                    await msg.channel.send(`I need admin to turn you into ${data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']}.`).catch(() => { })
                } else {
                    await createdWebhook.send(msg.content, {
                        username: data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name'],
                        avatarURL: data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['avatar'],
                        files: attachments,
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).then(() => {
                        if (!msg.deleted) {
                            msg.delete().catch(() => { })
                        }
                    })
                        .catch(() => { })
                }
            }
        }
    } else if (data['guild-data'][msg.guild.id]['members'][msg.author.id]['impostor']) {
        if (data['guild-data'][msg.guild.id]['members'][msg.author.id]['impostor'] === true && !msg.deleted && (msg.content || msg.attachments.size)) {
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new Discord.MessageAttachment(attachment.url))
            });
            var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
            if (webhooks ? webhooks.size : undefined) {
                var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                if (findWebhook) {
                    await findWebhook.send(msg.content, {
                        username: msg.member.nickname || msg.author.username,
                        avatarURL: 'https://cdn.discordapp.com/attachments/760223418968047629/835923486668750888/imposter.jpg',
                        files: attachments,
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).then(() => {
                        if (!msg.deleted) {
                            msg.delete().catch(() => { })
                        }
                    })
                        .catch(() => { })

                } else {
                    var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                    if (!createdWebhook) {
                        await msg.channel.send(`I need admin to turn you into the impostor.`).catch(() => { })
                    } else {
                        await createdWebhook.send(msg.content, {
                            username: msg.member.nickname || msg.author.username,
                            avatarURL: 'https://cdn.discordapp.com/attachments/760223418968047629/835923486668750888/imposter.jpg',
                            files: attachments,
                            allowedMentions: {
                                parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).then(() => {
                            if (!msg.deleted) {
                                msg.delete().catch(() => { })
                            }
                        })
                            .catch(() => { })
                    }
                }
            } else {
                var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                if (!createdWebhook) {
                    await msg.channel.send(`I need admin to turn you into the impostor.`).catch(() => { })
                } else {
                    await createdWebhook.send(msg.content, {
                        username: msg.member.nickname || msg.author.username,
                        avatarURL: 'https://cdn.discordapp.com/attachments/760223418968047629/835923486668750888/imposter.jpg',
                        files: attachments,
                        allowedMentions: {
                            parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).then(() => {
                        if (!msg.deleted) {
                            msg.delete().catch(() => { })
                        }
                    })
                        .catch(() => { })
                }
            }
        }
    }

    var usedCommand = false

    if (!ownerids.find(id => id == msg.author.id) && testing && !allowtesting) {
        msg.channel.send('you won\'t use me any time soon')
        return
    };

    if (msg.content.toLowerCase().includes(prefix.toLowerCase()) && !msg.author.bot) {
        if (data['guild-data'][msg.guild.id]['restricted'] === 'true' && !(msg.member.hasPermission('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id) && !illKillYouIfYouUseEval.find(id => id === msg.guild.id)))) {
            msg.react('âŒ').catch(() => { })
            return;
        }
        var cmds = msg.content.split(/ ?-\|- ?/);
        if (data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
            if ((data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0) {
                msg.channel.send(`Calm down! Wait more ${(data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`).catch(() => { })
                return;
            } else {
                data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
            }
        }

        if (cmds.length > 5) {
            msg.channel.send('Number of commands to run at the same time must be smaller or equal to **5**!').catch(() => { })
            return;
        };

        cmds.forEach(async cmd => {
            if (cmd.toLowerCase().startsWith(prefix.toLowerCase())) {
                var args = cmd.substring(prefix.toLowerCase().length).split(' ');
                var findCmd = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === args[0].toLowerCase()))
                var findLocalCmd = data['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === args[0].toLowerCase())
                var similarCmds = []

                if (args[0].length) {
                    for (var i in commands) {
                        var fcmd = commands[i]
                        for (var j in fcmd.name) {
                            var fcmdname = fcmd.name[j]
                            similarCmds.push({
                                name: fcmd.name[j],
                                similarity: similarity(fcmdname, args[0].toLowerCase())
                            })
                        }
                    }
                }

                similarCmds.sort((a, b) => Math.abs(1 - a.similarity) - Math.abs(1 - b.similarity))

                if (findCmd) {
                    usedCommand = true
                    if (data['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === args[0].toLowerCase()))) {
                        msg.channel.send('This command is disabled in this server.').catch(() => { })
                    } else {
                        if (findCmd.cooldown) {
                            data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown
                        }
                        cps++
                        data['bot-data']['bot']['commands']++
                        var t = setTimeout(() => {
                            cps--;
                            clearTimeout(t)
                        }, 1000)
                        await findCmd.execute(msg, args).catch(err => {
                            msg.channel.send(err.message).catch(() => { })
                            msg.channel.stopTyping(true)
                        })
                        data['bot-data']['bot']['filecount'] = filecount
                    }
                } else if (findLocalCmd) {
                    usedCommand = true
                    cps++
                    data['bot-data']['bot']['commands']++
                    var t = setTimeout(() => {
                        cps--;
                        clearTimeout(t)
                    }, 1000)
                    msg.channel.startTyping().catch(() => { })
                    var phrase = await getKeywordsFor(findLocalCmd.phrase)
                    await msg.channel.send(phrase).catch(() => { })
                    msg.channel.stopTyping(true)
                    data['bot-data']['bot']['filecount'] = filecount
                } else if (similarCmds ? similarCmds.find(fcmd => fcmd.similarity >= 0.5) : undefined) {
                    usedCommand = true
                    var buttonRow = new disbut.MessageActionRow()
                    var yesbutton = new disbut.MessageButton()
                        .setStyle('green')
                        .setEmoji('874406154619469864')
                        .setID('874406154619469864')
                    var nobutton = new disbut.MessageButton()
                        .setStyle('red')
                        .setEmoji('874406183933444156')
                        .setID('874406183933444156')
                    buttonRow.addComponent(yesbutton)
                    buttonRow.addComponent(nobutton)
                    msg.channel.send(`Did you mean to use \`${similarCmds[0].name}\`?`, { components: buttonRow }).then(async similarMsg => {
                        var filter = async (button) => {
                            if (!(button.clicker.user.id === msg.author.id && button.clicker.user.id !== bot.user.id && !button.clicker.user.bot)) {
                                button.defer()
                                return
                            }
                            if (button.id === '874406154619469864') {
                                similarMsg.delete().catch(() => { })
                                var findCmd = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === similarCmds[0].name))
                                if (findCmd.cooldown) {
                                    data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown
                                }
                                cps++
                                data['bot-data']['bot']['commands']++
                                var t = setTimeout(() => {
                                    cps--;
                                    clearTimeout(t)
                                }, 1000)
                                await findCmd.execute(msg, args).catch(err => {
                                    msg.channel.send(err.message).catch(() => { })
                                    msg.channel.stopTyping(true)
                                })
                                data['bot-data']['bot']['filecount'] = filecount
                            } else if (button.id === '874406183933444156') {
                                similarMsg.delete().catch(() => { })
                            } else {
                                button.defer()
                            }
                        }
                        similarMsg.awaitButtons(filter, { time: 60000 }).then(() => {
                            if (!similarMsg) return
                            similarMsg.edit('No response.', { components: [] }).catch(() => { })
                        })
                    })
                }
            }
        });
    };

    fs.writeFile('data.json', JSON.stringify(data), () => { });
    if (!testing) updateAllData(data).catch(() => { })

    if (msg.mentions.members.find(member => member.user.id === bot.user.id) && !msg.author.bot && !usedCommand) {
        if (msg.content.includes('prefix') && msg.content.includes('reset')) {
            var findCmd = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === 'setprefix'))
            usedCommand = true
            if (findCmd.cooldown) {
                data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown
            }
            await findCmd.execute(msg, ['setprefix', 'p:']).catch(err => {
                msg.channel.send(err.message).catch(() => { })
                msg.channel.stopTyping(true)
            })
        } else if (msg.content.includes('\?')) {
            const answers = ['I don\'t know.', 'Maybe...', 'I think so.', 'Of course.', 'I don\'t think so.', 'I can afirm.', 'No, that\'s wrong.', 'Yes, that\'s right.', 'I assume so.', 'Yes.', 'No.', 'I have no answers.', 'That\'s true.', 'That\'s false.']
            msg.channel.send(answers[Math.floor(Math.random() * answers.length)]).catch(() => { })
        } else if (msg.content.toLowerCase().includes('lore')) {
            msg.channel.send('Well... If you played a little bit with `p:poop`, I could give you some...').catch(() => { })
        } else if ((msg.content.toLowerCase().includes('how') && msg.content.toLowerCase().includes('are') && msg.content.toLowerCase().includes('you')) || (msg.content.toLowerCase().includes('what') && msg.content.toLowerCase().includes('up')) || msg.content.toLowerCase().includes('wassup') || (msg.content.toLowerCase().includes('how') && msg.content.toLowerCase().includes('it') && msg.content.toLowerCase().includes('going'))) {
            var activity = bot.user.presence.activities[0]
            msg.channel.send('Ya know, just ' + activity.type.toLowerCase() + ' ' + ((activity.type === "COMPETING" && 'in ') || (activity.type === "LISTENING" && 'to ') || '') + activity.name + '.', {
                allowedMentions: {
                    parse: ((!msg.member.hasPermission('ADMINISTRATOR') && !msg.member.hasPermission('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                }
            }).catch(() => { })
        } else if (msg.content.toLowerCase().includes('thank')) {
            msg.channel.send('You\'re welcome!').catch(() => { })
        } else if (msg.content.toLowerCase().includes('mom') || msg.content.toLowerCase().includes('bitch') || msg.content.toLowerCase().includes('goatfucker') || msg.content.toLowerCase().includes('loser') || msg.content.toLowerCase().includes('asshole') || msg.content.toLowerCase().includes('dipshit') || msg.content.toLowerCase().includes('fucker') || msg.content.toLowerCase().includes('retard') || msg.content.toLowerCase().includes('shitass') || msg.content.toLowerCase().includes('moron') || msg.content.toLowerCase().includes('buffoon') || msg.content.toLowerCase().includes('idiot') || msg.content.toLowerCase().includes('stupid') || msg.content.toLowerCase().includes('gay') || msg.content.toLowerCase().includes('dumbass')) {
            msg.channel.send('Shut up.').catch(() => { })
        } else if (msg.content.toLowerCase().includes('hi') || msg.content.toLowerCase().includes('yo') || msg.content.toLowerCase().includes('hello') || msg.content.toLowerCase().includes('howdy')) {
            msg.channel.send('Yo! What\'s up?').catch(() => { })
        } else if (msg.content.toLowerCase().includes('no') || msg.content.toLowerCase().includes('nah')) {
            msg.channel.send(':(').catch(() => { })
        } else if (msg.content.toLowerCase().includes('ye') || msg.content.toLowerCase().includes('yup')) {
            msg.channel.send(':)').catch(() => { })
        } else {
            msg.channel.send(`My prefix here is \`${prefix}\``).catch(() => { })
        }
    }
}

bot.on('ready', async () => {
    async function getAllDataLoop() {
        var data = await getAllData().catch(() => { })
        if (!data) return getAllDataLoop()
        return data
    }

    console.log(`${bot.user.username} is online, RUN`);
    bot.user.setPresence({
        status: 'idle',
        activity: {
            name: 'gathering data...',
            type: 'COMPETING',
            url: 'https://www.youtube.com/watch?v=hr7GyFM7pX4'
        },
    });
    data = await getAllDataLoop()
    if (data) fs.writeFile('data.json', JSON.stringify(data), () => { })

    if (!data['bot-data']) {
        data['bot-data'] = {}
    }

    if (!data['bot-data']['bot']) {
        data['bot-data']['bot'] = {}
    }

    filecount = data['bot-data']['bot']['filecount'] || 0
    await noblox.setCookie(process.env.ROBLOXCOOKIE).catch(() => { })
    psFiles = await getPsFiles().catch(() => { })
    psPasta = await getPsPasta().catch(() => { })
    emojiImages = await getEmojiImages().catch(() => { })
    if (!fs.existsSync('temp')) {
        fs.mkdirSync('temp')
    }
    var choosenStatus = statuses[Math.floor(Math.random() * statuses.length)]
    bot.user.setPresence({
        status: 'online',
        activity: {
            name: choosenStatus['name'] + ' | p:help',
            type: choosenStatus['type'],
            url: 'https://www.youtube.com/watch?v=hr7GyFM7pX4'
        },
    });
    statusInterval = setInterval(function () {
        if (bot && statusChanges === 'true') {
            var choosenStatus = statuses[Math.floor(Math.random() * statuses.length)]
            bot.user.setPresence({
                status: 'online',
                activity: {
                    name: choosenStatus['name'] + ' | p:help',
                    type: choosenStatus['type'],
                    url: 'https://www.youtube.com/watch?v=hr7GyFM7pX4',
                },
            });
        }
    }, 300000)
    bot.on('message', messageCallback)
})

bot.login(TOKEN);